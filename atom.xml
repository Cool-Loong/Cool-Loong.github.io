<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dragon&#39;s Blog</title>
  
  <subtitle>loong</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Cool-Loong.github.io/"/>
  <updated>2019-09-10T04:30:06.295Z</updated>
  <id>https://Cool-Loong.github.io/</id>
  
  <author>
    <name>Loong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Filter过滤器</title>
    <link href="https://Cool-Loong.github.io/2019/09/10/Filter%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <id>https://Cool-Loong.github.io/2019/09/10/Filter过滤器/</id>
    <published>2019-09-10T04:28:49.000Z</published>
    <updated>2019-09-10T04:30:06.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="过滤器的介绍"><a href="#过滤器的介绍" class="headerlink" title="过滤器的介绍"></a>过滤器的介绍</h2><p>filter是对客户端访问资源的过滤，符合条件放行，不符合条件不放行，并且可以对目    标资源访问前后进行逻辑处理</p><h3 id="过滤的目的："><a href="#过滤的目的：" class="headerlink" title="过滤的目的："></a>过滤的目的：</h3><ul><li>安全</li><li>干净<br>实际上在JavaEE中，使用过滤器的目的也就是这两个，过滤器在java EE中也叫做Servlet程序，后面讲解的监听器也属于Servlet范畴<br>Servlet有三种：</li><li>标准的Servlet</li><li>过滤的Servlet</li><li>监听的Servlet<br>过滤器是在Servlet2.3加入的新功能，当用户需要限制某些操作的时候，就可以进行过滤器进行过滤，是以一种组件的形式绑定到web程序中，与其他组件不同的是，过滤器采用的是链式的方式进行处理。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>过滤器目前在开发中，主要的作用有三个：</p><ul><li>过滤非法文字</li><li>请求请求统一编码的设置</li><li>过滤非法用户<h2 id="过滤器的实现"><a href="#过滤器的实现" class="headerlink" title="过滤器的实现"></a>过滤器的实现</h2>在java EE中过滤器的实现非常简单，只需要实现一个过滤接口：Filter接口，这个接口中有三个方法：</li><li>过滤器服务方法：void doFilter(ServletRequest request,  ServletResponse response,  FilterChain chain) </li><li>过滤器的销毁：void destroy()</li><li>过滤器的初始化：void init(FilterConfig filterConfig)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line"></span><br><span class="line">public class FilterDemo01 implements Filter &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">System.out.println(&quot;过滤器销毁&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line">System.out.println(&quot;过滤器doFilter&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void init(FilterConfig arg0) throws ServletException &#123;</span><br><span class="line">System.out.println(&quot;过滤器初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器写好了之后，目前没有运行，因为过滤器还需要进行配置，配置的形式有两种：</p><ul><li>配置web.xml文件</li><li>使用注解<br><code>第一种：在web.xml中配置过滤器</code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置过滤器 --&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;过滤器名字&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;过滤器的类的地址&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;过滤器名字&lt;/filter-name&gt;</span><br><span class="line">&lt;!-- 表示过滤器仅仅过滤/index.jsp 这个请求地址 * 表示过滤所有的请求地址 --&gt;</span><br><span class="line">&lt;url-pattern&gt;过滤的请求地址&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul><p>以上配置的Servlet只能在地址栏请求index.jsp的时候才会执行，但是在开发中，过滤器一般都是配置所有请求，也就是说过滤器会过滤所有的请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line">System.out.println(&quot;过滤器doFilter&quot;);</span><br><span class="line">//如果想要继续执行操作的话可以使用</span><br><span class="line">filterChain.doFilter(request, response);//继续向下执行</span><br><span class="line">//这个时候过滤器的操作就很明显了 只要按照特定的要求是否能够继续向下执行问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>第二种：通过注解的方式完成过滤器配置</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebFilter(&quot;*&quot;)</span><br></pre></td></tr></table></figure></p><p>通过运行发现过滤器的生命周期：</p><ul><li>在tomcat启动的时候Filter会进行初始化</li><li>每次浏览器访问过滤器过滤的地址的时候，过滤器的doFilter方法都会执行</li><li>过滤器的销毁是在tomcat关闭的时候销毁<h2 id="过滤具体的使用"><a href="#过滤具体的使用" class="headerlink" title="过滤具体的使用"></a>过滤具体的使用</h2></li><li><p>过滤非法文字：比如提交的内容中，还有反动话语，或者骂人的脏话，不能够向下执行。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;过滤器doFilter&quot;);</span><br><span class="line">boolean flag = true;</span><br><span class="line">Enumeration&lt;String&gt; names = request.getParameterNames();</span><br><span class="line">while(names.hasMoreElements()) &#123;</span><br><span class="line">if(request.getParameter(names.nextElement()).equals(&quot;TMD&quot;)) &#123;</span><br><span class="line">System.out.println(&quot;非法文字&quot;);</span><br><span class="line">flag = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(flag) &#123;</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对请求编码进行统一的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line">System.out.println(&quot;过滤器doFilter&quot;);</span><br><span class="line">request.setCharacterEncoding(&quot;utf-8&quot;);//设置请求的统一编码</span><br><span class="line">filterChain.doFilter(request, response);//继续向下执行</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>过滤非法用户：比如我们网银系统，没有登录的人是不能够查询账户信息、余额、交易记录的，再比如我们的教务系统，没有登录是什么也不能做的。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line">@WebFilter(&quot;*&quot;)</span><br><span class="line">public class LoginFilter implements Filter &#123;</span><br><span class="line">public void destroy() &#123;</span><br><span class="line">&#125;</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class="line">//过滤非法用户：没有登录的用户只能够访问登录页面</span><br><span class="line">/*</span><br><span class="line"> * session域中有name名称对应的内容的话，不用过滤</span><br><span class="line"> * 登录页面不能过滤</span><br><span class="line"> * 登录验证的Servlet不能过滤</span><br><span class="line"> * 如果存在注册的功能的话，注册和注册Servlet也是不能过滤的</span><br><span class="line"> * */</span><br><span class="line">HttpSession session = req.getSession();</span><br><span class="line">//获取请求的url地址</span><br><span class="line">String url = req.getRequestURL().toString();</span><br><span class="line">String uri = req.getRequestURI();</span><br><span class="line">System.out.println(url + &quot;===========&quot; +uri);</span><br><span class="line">if(null != session.getAttribute(&quot;name&quot;) || //session已经存在</span><br><span class="line">uri.indexOf(&quot;login.jsp&quot;) != -1 || //登录页面不能过滤</span><br><span class="line">uri.indexOf(&quot;loginServlet&quot;) != -1 || //登录验证不能过滤</span><br><span class="line">uri.indexOf(&quot;regeister.jsp&quot;) !=-1 || //注册页面不能过滤</span><br><span class="line">uri.indexOf(&quot;regeisterServlet&quot;) != -1) &#123; //注册servlet不能过滤</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">String path = req.getContextPath();</span><br><span class="line">resp.sendRedirect(path+&quot;/login.jsp&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void init(FilterConfig fConfig) throws ServletException &#123;</span><br><span class="line">System.out.println(&quot;loginFilter初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>过滤器属于一种自动的Servlet，能够自动的执行</li><li>过滤器的配置有两种方式，一种是通过web.xml配置，第二种是通过注解的形式完成</li><li>过滤的常见的操作就是过滤非法文字、非法用户和设置统一的编码</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h1&gt;&lt;h2 id=&quot;过滤器的介绍&quot;&gt;&lt;a href=&quot;#过滤器的介绍&quot; class=&quot;headerlink&quot; title=&quot;过滤器的介绍&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="javaee" scheme="https://Cool-Loong.github.io/tags/javaee/"/>
    
      <category term="Filter" scheme="https://Cool-Loong.github.io/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Listener监听器</title>
    <link href="https://Cool-Loong.github.io/2019/09/10/Listener%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>https://Cool-Loong.github.io/2019/09/10/Listener监听器/</id>
    <published>2019-09-10T04:25:15.000Z</published>
    <updated>2019-09-10T04:29:25.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><h2 id="监听器的基本的介绍"><a href="#监听器的基本的介绍" class="headerlink" title="监听器的基本的介绍"></a>监听器的基本的介绍</h2><p>监听器就是第三种Servlet，叫做监听的Servlet，主要负责监听web程序执行的各个过程，当相关的被监听事件执行之后，监听器会自动执行，在web中可以对application、request和session三种操作进行监听，比如服务的启动和关闭，session域对象的设置和取消，request域对象的设置和取消，request请求等等都可以被监听。监听的实现主要是依靠各种监听接口完成。</p><h2 id="对application的监听"><a href="#对application的监听" class="headerlink" title="对application的监听"></a>对application的监听</h2><p>对于application监听<br>实际上就是对ServletContext的监听<br>主要的监听接口有两个：</p><ul><li>ServletContextListener：对服务器的关闭和启动进行监听</li><li>ServletContextAttributeListener：对application设置的域对象信息监听  <h3 id="对服务器的启动和关闭进行监听"><a href="#对服务器的启动和关闭进行监听" class="headerlink" title="对服务器的启动和关闭进行监听"></a>对服务器的启动和关闭进行监听</h3>主要方法有两个：</li><li>void contextInitialized(ServletContextEvent sce)：监听服务器的启动</li><li>void contextDestroyed(ServletContextEvent sce)：监听服务器的关闭<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.ServletContextEvent;</span><br><span class="line">import javax.servlet.ServletContextListener;</span><br><span class="line"></span><br><span class="line">public class WebServletContextListener implements ServletContextListener &#123;</span><br><span class="line"></span><br><span class="line">//监听服务器的关闭</span><br><span class="line">@Override</span><br><span class="line">public void contextDestroyed(ServletContextEvent arg0) &#123;</span><br><span class="line">System.out.println(&quot;tomcat 关闭了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//监听服务器的启动</span><br><span class="line">@Override</span><br><span class="line">public void contextInitialized(ServletContextEvent arg0) &#123;</span><br><span class="line">System.out.println(&quot;tomcat 启动了&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>监听器要运行的话，必须和Servlet或者Filter一样，需要进行配置到Web工程中，配置方式也有两种：</p><ul><li>配置web.xml文件</li><li>通过注解的方式完成配置<h4 id="第一种配置："><a href="#第一种配置：" class="headerlink" title="第一种配置："></a>第一种配置：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置监听器 --&gt;</span><br><span class="line">  &lt;listener&gt;</span><br><span class="line">  &lt;listener-class&gt;com.wanbangee.listener.WebServletContextListener&lt;/listener-class&gt;</span><br><span class="line">  &lt;/listener&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@WebListener</span><br></pre></td></tr></table></figure><p>启动tomcat的过程中执行了监听器中监听服务器启动的方法，关闭服务器的时候，执行了监听服务器关闭的方法。</p><h3 id="对application范围域对象进行监听"><a href="#对application范围域对象进行监听" class="headerlink" title="对application范围域对象进行监听"></a>对application范围域对象进行监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@WebListener</span><br><span class="line">public class WebServletContextAttributeListener implements ServletContextAttributeListener &#123;</span><br><span class="line">         /*</span><br><span class="line"> * 比如修改：event获取的是修改前的信息</span><br><span class="line"> * 比如删除：event获取的是删除前的信息</span><br><span class="line"> * </span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">//监听application访问的域对象的设置</span><br><span class="line">    public void attributeAdded(ServletContextAttributeEvent event)  &#123; </span><br><span class="line">    System.out.println(&quot;设置了application域对象的信息&quot;);</span><br><span class="line">    System.out.println(&quot;设置域对象的名称：&quot;+event.getName());</span><br><span class="line">    System.out.println(&quot;设置域对象的值：&quot;+event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">//监听application访问的域对象的移除</span><br><span class="line">    public void attributeRemoved(ServletContextAttributeEvent event)  &#123; </span><br><span class="line">    System.out.println(&quot;移除了application域对象的信息&quot;);</span><br><span class="line">    System.out.println(&quot;移除域对象的名称：&quot;+event.getName());</span><br><span class="line">    System.out.println(&quot;移除域对象的值：&quot;+event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">//监听application访问的域对象的修改</span><br><span class="line">    public void attributeReplaced(ServletContextAttributeEvent event)  &#123; </span><br><span class="line">    System.out.println(&quot;修改了application域对象的信息&quot;);</span><br><span class="line">    System.out.println(&quot;修改域对象的名称：&quot;+event.getName());</span><br><span class="line">    System.out.println(&quot;修改域对象的值：&quot;+event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对session的监听"><a href="#对session的监听" class="headerlink" title="对session的监听"></a>对session的监听</h2><h3 id="对session的监听常用的监听接口有两个："><a href="#对session的监听常用的监听接口有两个：" class="headerlink" title="对session的监听常用的监听接口有两个："></a>对session的监听常用的监听接口有两个：</h3><h4 id="监听session的创建和session的销毁"><a href="#监听session的创建和session的销毁" class="headerlink" title="监听session的创建和session的销毁"></a>监听session的创建和session的销毁</h4><p>监听接口为HttpSessionListener，方法有：</p><ul><li>监听session的创建 ： sessionCreate()</li><li>监听session的销毁 : sessionDestoryed()<h4 id="监听session域对象信息的设置、修改和删除"><a href="#监听session域对象信息的设置、修改和删除" class="headerlink" title="监听session域对象信息的设置、修改和删除"></a>监听session域对象信息的设置、修改和删除</h4>监听接口为HttpSessionAttributeListener，方法有：</li><li>监听session域对象的设置：attributeAdded()</li><li>监听session域对象的修改：attributeReplaced()</li><li>监听session域对象的删除：attributeRemoved()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import javax.servlet.annotation.WebListener;</span><br><span class="line">import javax.servlet.http.HttpSessionAttributeListener;</span><br><span class="line">import javax.servlet.http.HttpSessionBindingEvent;</span><br><span class="line">import javax.servlet.http.HttpSessionEvent;</span><br><span class="line">import javax.servlet.http.HttpSessionListener;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Application Lifecycle Listener implementation class WebSessionListener</span><br><span class="line"> */</span><br><span class="line">@WebListener</span><br><span class="line">public class WebSessionListener implements HttpSessionListener, HttpSessionAttributeListener &#123;</span><br><span class="line"></span><br><span class="line">//监听session创建</span><br><span class="line">    public void sessionCreated(HttpSessionEvent event)  &#123; </span><br><span class="line">    System.out.println(&quot;浏览器连接到了服务器。。。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //监听session的销毁</span><br><span class="line">    public void sessionDestroyed(HttpSessionEvent event)  &#123; </span><br><span class="line">    System.out.println(&quot;session 失效了&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //监听session域对象的设置</span><br><span class="line">    public void attributeAdded(HttpSessionBindingEvent event)  &#123; </span><br><span class="line">    System.out.println(&quot;session域对象设置了&quot;);</span><br><span class="line">    System.out.println(&quot;session属性的名称：&quot; + event.getName());</span><br><span class="line">    System.out.println(&quot;session属性的值：&quot; + event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    //监听session域对象的移除</span><br><span class="line">    public void attributeRemoved(HttpSessionBindingEvent event)  &#123; </span><br><span class="line">    System.out.println(&quot;session域对象移除了&quot;);</span><br><span class="line">    System.out.println(&quot;session属性的名称：&quot; + event.getName());</span><br><span class="line">    System.out.println(&quot;session属性的值：&quot; + event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    //监听session域对象的修改</span><br><span class="line">    public void attributeReplaced(HttpSessionBindingEvent event)  &#123; </span><br><span class="line">    System.out.println(&quot;session域对象修改了&quot;);</span><br><span class="line">    System.out.println(&quot;session属性的名称：&quot; + event.getName());</span><br><span class="line">    System.out.println(&quot;session属性的值：&quot; + event.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对request的监听"><a href="#对request的监听" class="headerlink" title="对request的监听"></a>对request的监听</h2><h3 id="对request的监听常用的监听接口有两个："><a href="#对request的监听常用的监听接口有两个：" class="headerlink" title="对request的监听常用的监听接口有两个："></a>对request的监听常用的监听接口有两个：</h3><h4 id="监听request的创建和request的销毁"><a href="#监听request的创建和request的销毁" class="headerlink" title="监听request的创建和request的销毁"></a>监听request的创建和request的销毁</h4><p>监听接口为ServletRequestListener，方法有：</p><ul><li>监听request的创建 ： requestCreate()</li><li>监听request的销毁 :  requestDestoryed()<h4 id="监听request域对象信息的设置、修改和删除"><a href="#监听request域对象信息的设置、修改和删除" class="headerlink" title="监听request域对象信息的设置、修改和删除"></a>监听request域对象信息的设置、修改和删除</h4>监听接口为ServletRequestAttributeListener，方法有：</li><li>监听ServletRequest域对象的设置：attributeAdded()</li><li>监听ServletRequest域对象的修改：attributeReplaced()</li><li>监听ServletRequest域对象的删除：attributeRemoved()</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>使用监听可以对application、session和request的范围属性进行监听  </li><li>使用ServletContextListener可以监听服务器的启动和关闭  </li><li>使用HttpSessionListener可以监听session的创建和session的注销  </li><li>使用ServletRequestListener可以监听请求的创建和销毁  </li><li>监听器的配置主要是使用注解的方式完成  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监听器&quot;&gt;&lt;a href=&quot;#监听器&quot; class=&quot;headerlink&quot; title=&quot;监听器&quot;&gt;&lt;/a&gt;监听器&lt;/h1&gt;&lt;h2 id=&quot;监听器的基本的介绍&quot;&gt;&lt;a href=&quot;#监听器的基本的介绍&quot; class=&quot;headerlink&quot; title=&quot;监听器
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="javaee" scheme="https://Cool-Loong.github.io/tags/javaee/"/>
    
      <category term="Listener" scheme="https://Cool-Loong.github.io/tags/Listener/"/>
    
  </entry>
  
  <entry>
    <title>JavaBean</title>
    <link href="https://Cool-Loong.github.io/2019/09/06/JavaBean/"/>
    <id>https://Cool-Loong.github.io/2019/09/06/JavaBean/</id>
    <published>2019-09-06T13:31:21.000Z</published>
    <updated>2019-09-07T00:54:00.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaBean的介绍"><a href="#JavaBean的介绍" class="headerlink" title="JavaBean的介绍"></a>JavaBean的介绍</h1><p>实际上Javabean在开发中使用很多.  在比较早的时候，有一句话：如果一个程序员不懂JavaBean，那么就不懂jsp，在jsp中可以使用javaBean减少jsp中的Java代码量，使用整个JSP开起来更加的整洁、干净，当然主要的原因还是在于解除jsp中的Java代码和html代码仅仅的耦合在一起的问题，以便于提高程序的可读性和可维护性，jsp搭配JavaBean使用的，</p><h2 id="有以下几点优势："><a href="#有以下几点优势：" class="headerlink" title="有以下几点优势："></a>有以下几点优势：</h2><ul><li>可以将html代码和java代码相分离，我们的最终目标就是在jsp中看不到java代码，这样以后维护会比较方便。</li><li>可以使用JavaBean的优点，将经常需要使用的操作编写成一个JavaBean的组件，在jsp调用的时候，只需要调用javaBean的组件来执行用户需要去的操作，不需要再编写相同形式的程序，减少代码的冗余。简单来说，就是将一些复杂的java代码放在java类中编写，方便调用，而不是在jsp中写大量的复杂的java代码。  <h2 id="JavaBean的开发要求："><a href="#JavaBean的开发要求：" class="headerlink" title="JavaBean的开发要求："></a>JavaBean的开发要求：</h2></li><li>JavaBean本身是一个类，属于java面向对象编程</li><li>所有的JavaBean必须放在包中</li><li>所以的JavaBean必须以public class声明</li><li>所有的JavaBean类中的属性都必须封装，然后提供准确的get和set方法</li><li>在一个JavaBean中，必须存在无参数的构造器</li></ul><p><code>例子</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.wanbangee.entties;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">public class Person &#123;</span><br><span class="line">private int personId;</span><br><span class="line">private String personName;</span><br><span class="line">private String personPass;</span><br><span class="line">private int personAge;</span><br><span class="line">private Date personBirthday;</span><br><span class="line">public int getPersonId() &#123;</span><br><span class="line">return personId;</span><br><span class="line">&#125;</span><br><span class="line">public void setPersonId(int personId) &#123;</span><br><span class="line">this.personId = personId;</span><br><span class="line">&#125;</span><br><span class="line">public String getPersonName() &#123;</span><br><span class="line">return personName;</span><br><span class="line">&#125;</span><br><span class="line">public void setPersonName(String personName) &#123;</span><br><span class="line">this.personName = personName;</span><br><span class="line">&#125;</span><br><span class="line">public String getPersonPass() &#123;</span><br><span class="line">return personPass;</span><br><span class="line">&#125;</span><br><span class="line">public void setPersonPass(String personPass) &#123;</span><br><span class="line">this.personPass = personPass;</span><br><span class="line">&#125;</span><br><span class="line">public int getPersonAge() &#123;</span><br><span class="line">return personAge;</span><br><span class="line">&#125;</span><br><span class="line">public void setPersonAge(int personAge) &#123;</span><br><span class="line">this.personAge = personAge;</span><br><span class="line">&#125;</span><br><span class="line">public Date getPersonBirthday() &#123;</span><br><span class="line">return personBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public void setPersonBirthday(Date personBirthday) &#123;</span><br><span class="line">this.personBirthday = personBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public Person(int personId, String personName, String personPass, int personAge, Date personBirthday) &#123;</span><br><span class="line">super();</span><br><span class="line">this.personId = personId;</span><br><span class="line">this.personName = personName;</span><br><span class="line">this.personPass = personPass;</span><br><span class="line">this.personAge = personAge;</span><br><span class="line">this.personBirthday = personBirthday;</span><br><span class="line">&#125;</span><br><span class="line">public Person() &#123;</span><br><span class="line">super();</span><br><span class="line">// TODO Auto-generated constructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="可执行的Web的标准目录："><a href="#可执行的Web的标准目录：" class="headerlink" title="可执行的Web的标准目录："></a>可执行的Web的标准目录：</h2><ul><li>WebContent<ul><li>jsp ：专门存放jsp文件</li><li>js：专门存放外部的js文件</li><li>css: 专门存放样式文件</li><li>img ： 专门存放图片</li><li>index.jsp/index.html : 一般是欢迎页面</li><li>WEB-INF<br>  -web.xml：web工程的部署描述符<ul><li>lib：所有的jar都存放在此  </li><li>classes：所有的java程序编译后都放在此目录中  <blockquote><p>javabean编译后的class文件就放在WEB-INF的classes目录中。</p></blockquote><h1 id="JavaBean的使用"><a href="#JavaBean的使用" class="headerlink" title="JavaBean的使用"></a>JavaBean的使用</h1>在jsp中Javabean使用有两种语法：</li></ul></li></ul></li><li>使用scriptlet来调用javabean</li><li>使用jsp标签完成<h2 id="第一种方式：使用scriptlet来调用javabean"><a href="#第一种方式：使用scriptlet来调用javabean" class="headerlink" title="第一种方式：使用scriptlet来调用javabean"></a>第一种方式：使用scriptlet来调用javabean</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">Person person = new Person();</span><br><span class="line">person.setPersonId(10);</span><br><span class="line">person.setPersonAge(20);</span><br><span class="line">person.setPersonName(&quot;张大炮&quot;);</span><br><span class="line">person.setPersonPass(&quot;123456&quot;);</span><br><span class="line">person.setPersonBirthday(new Date());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;&lt;%=person %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></li></ul><p>以上在jsp中使用JavaBean和我们之前的写法没有任何的区别。</p><h2 id="第二种方式：使用jsp标签完成"><a href="#第二种方式：使用jsp标签完成" class="headerlink" title="第二种方式：使用jsp标签完成"></a>第二种方式：使用jsp标签完成</h2><h3 id="jsp中使用JavaBean的方式："><a href="#jsp中使用JavaBean的方式：" class="headerlink" title="jsp中使用JavaBean的方式："></a>jsp中使用JavaBean的方式：</h3><ul><li>id ： 对应的是javaBean的对象名称</li><li>class ： 对应的是Javabean的全类名</li><li>scope ： JavaBean的范围，对应4中范围，page、request、session、application</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=&quot;person&quot; class=&quot;com.wanbangee.entties.Person&quot; scope=&quot;page&quot;&gt;</span><br><span class="line">&lt;/jsp:useBean&gt;</span><br><span class="line">&lt;%</span><br><span class="line">person.setPersonId(10);</span><br><span class="line">person.setPersonAge(20);</span><br><span class="line">person.setPersonName(&quot;张大炮&quot;);</span><br><span class="line">person.setPersonPass(&quot;123456&quot;);</span><br><span class="line">person.setPersonBirthday(new Date());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;h1&gt;&lt;%=person %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h1 id="JavaBean的作用"><a href="#JavaBean的作用" class="headerlink" title="JavaBean的作用"></a>JavaBean的作用</h1><p>以上讲解的JavaBean在jsp中如何调用的问题<br>那么JavaBean在jsp中如何使用呢？<br>这就是JavaBean在jsp中最大的作用：在接收传递参数的问题上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/jsp/javabean/page04.jsp&quot; method=&apos;post&apos;&gt;</span><br><span class="line"></span><br><span class="line">personId:&lt;input type=&quot;text&quot; name = &apos;personId&apos;&gt;&lt;br/&gt;</span><br><span class="line">personName:&lt;input type=&quot;text&quot; name = &apos;personName&apos;&gt;&lt;br/&gt;</span><br><span class="line">personPass:&lt;input type=&quot;text&quot; name = &apos;personPass&apos;&gt;&lt;br/&gt;</span><br><span class="line">personAge:&lt;input type=&quot;text&quot; name = &apos;personAge&apos;&gt;&lt;br/&gt;</span><br><span class="line">personBirthday:&lt;input type=&quot;date&quot; name = &apos;personBirthday&apos;&gt;&lt;br/&gt;</span><br><span class="line">&lt;button&gt;Submit&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">/* 抛弃此种接收参数的方式 */</span><br><span class="line">//String personName = request.getParameter(&quot;personName&quot;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;person&quot; class=&quot;com.wanbangee.entties.Person&quot; scope=&quot;page&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">`&lt;jsp:setProperty property=&quot;*&quot; name=&quot;person&quot;/&gt;`</span><br><span class="line">&lt;h1&gt;&lt;%=person %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><p>jsp:setProperty表示装配对象的属性，根据javaBean风格属性名称和参数名称自动装配，调用的是setter方法将参数设置到javabean的属性上去的，实际上有四种用法：  </p><ul><li>自动装配：&lt;jsp:setProperty property=’*’name=’对象名’/&gt;  </li><li>指定属性匹配：&lt;jsp:setProperty property=’属性名’name=’对象名’/&gt;  </li><li>指定参数匹配指定的属性：&lt;jsp:setProperty property=’属性名’param=‘参数名’name=’对象名’/&gt;  </li><li>指定属性匹配的值：&lt;jsp:setProperty property=’属性名’value=‘属性值’name=’对象名’/&gt;  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   /* 抛弃此种接收参数的方式 */</span><br><span class="line">   //String personName = request.getParameter(&quot;personName&quot;);</span><br><span class="line"></span><br><span class="line">&lt;jsp:useBean id=&quot;person&quot; class=&quot;com.wanbangee.entties.Person&quot; scope=&quot;page&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line">第一种：通过JavaBean风格的属性名和参数名自动匹配</span><br><span class="line">&lt;jsp:setProperty property=&quot;*&quot; name=&quot;person&quot;/&gt; </span><br><span class="line"></span><br><span class="line">   第二种：匹配指定的属性</span><br><span class="line">&lt;jsp:setProperty property=&quot;personName&quot; name=&quot;person&quot;/&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   第三种：指定的属性匹配指定的参数</span><br><span class="line">   &lt;jsp:setProperty property=&quot;personName&quot; param=&quot;personBirthday&quot; name=&quot;person&quot;/&gt;</span><br><span class="line"></span><br><span class="line">   第四种：指定的属性匹配指定的值</span><br><span class="line">   &lt;jsp:setProperty property=&quot;personName&quot; value=&apos;张益达&apos; name=&quot;person&quot;/&gt;</span><br><span class="line">   </span><br><span class="line">    显示</span><br><span class="line">&lt;h1&gt;&lt;%=person %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><p>通过程序发现，使用第一种自动匹配的方式肯定是最好用的。  </p><h1 id="JavaBean的范围"><a href="#JavaBean的范围" class="headerlink" title="JavaBean的范围"></a>JavaBean的范围</h1><p>JavaBean有四种范围：  </p><ul><li>page范围：只在当前页面有效</li><li>request范围：转发之后有效</li><li>session范围：只要浏览器不关闭，转发和重定向后都有效</li><li>application范围：只要服务器不关闭，JavaBean一直存在</li></ul><hr><pre><code>&lt;%    /* 抛弃此种接收参数的方式 */    //String personName = request.getParameter(&quot;personName&quot;);%&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;com.wanbangee.entties.Person&quot; scope=&quot;session&quot;&gt;&lt;/jsp:useBean&gt;第一种：通过JavaBean风格的属性名和参数名自动匹配    &lt;jsp:setProperty property=&quot;*&quot; name=&quot;person&quot;/&gt; 第二种：匹配指定的属性    &lt;jsp:setProperty property=&quot;personName&quot; name=&quot;person&quot;/&gt;第三种：指定的属性匹配指定的参数    &lt;jsp:setProperty property=&quot;personName&quot; param=&quot;personBirthday&quot; name=&quot;person&quot;/&gt;第四种：指定的属性匹配指定的值    &lt;jsp:setProperty property=&quot;personName&quot; value=&apos;张益达&apos; name=&quot;person&quot;/&gt; &lt;h1&gt;&lt;%=person %&gt;&lt;/h1&gt;&lt;a href=&apos;&lt;%=request.getContextPath()%&gt;/jsp/javabean/page05.jsp&apos;&gt;走你&lt;/a&gt;&lt;jsp:useBean id=&quot;person&quot; class=&quot;com.wanbangee.entties.Person&quot; scope=&quot;session&quot;&gt;&lt;/jsp:useBean&gt;&lt;h1&gt;&lt;%=person %&gt;&lt;/h1&gt;</code></pre><hr><p>以上是session范围，转发和重定向后都有效。  </p><h1 id="JavaBean的删除"><a href="#JavaBean的删除" class="headerlink" title="JavaBean的删除"></a>JavaBean的删除</h1><p>JavaBean在jsp中依靠jsp标签<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>来创建，但是删除的操作并不是使用标签，而是使用属性的删除方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   &lt;%</span><br><span class="line">session.removeAttribute(&quot;person&quot;);//根据名称异常JavaBean</span><br><span class="line">%&gt;</span><br><span class="line">&lt;jsp:useBean id=&quot;person&quot; class=&quot;com.wanbangee.entties.Person&quot; scope=&quot;session&quot;&gt;&lt;/jsp:useBean&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;&lt;%=person %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>javaBean的基本介绍，掌握JavaBean的作用；<br>目前来说javaBean作用就是用于参数的接收，在参数接收的时候有四种方式进行匹配，第一种方式最好用；<br>JavaBean的保存依然是有四种范围的，操作方式和属性也是雷同；<br>JavaBean的使用看似简单，在后期的开发中，我们会赋予JavaBean更多的操作，JavaBean实际上就是一个小小的组件模型。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaBean的介绍&quot;&gt;&lt;a href=&quot;#JavaBean的介绍&quot; class=&quot;headerlink&quot; title=&quot;JavaBean的介绍&quot;&gt;&lt;/a&gt;JavaBean的介绍&lt;/h1&gt;&lt;p&gt;实际上Javabean在开发中使用很多.  在比较早的时候，有一句话
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="javaee" scheme="https://Cool-Loong.github.io/tags/javaee/"/>
    
      <category term="jsp" scheme="https://Cool-Loong.github.io/tags/jsp/"/>
    
      <category term="javaBean" scheme="https://Cool-Loong.github.io/tags/javaBean/"/>
    
  </entry>
  
  <entry>
    <title>EL和JSTL表达式</title>
    <link href="https://Cool-Loong.github.io/2019/09/06/EL%E5%92%8CJSTL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://Cool-Loong.github.io/2019/09/06/EL和JSTL表达式/</id>
    <published>2019-09-06T12:59:39.000Z</published>
    <updated>2019-09-10T04:17:29.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><h2 id="EL表达式的介绍"><a href="#EL表达式的介绍" class="headerlink" title="EL表达式的介绍"></a>EL表达式的介绍</h2><p>EL（Express Lanuage）表达式  可以嵌入在jsp页面内部  减少jsp脚本的编写,EL出现的目的是要代替jsp页面的脚本编写<br>EL表达式是在jsp2.0之后加入的新的功能，使用表达式语言可以输出存储在标志位置上的对象，比如获取设置的域对象的信息，参数等等，可以大量的减少在jsp中存在Java代码，而且使用EL表达式也非常的简单${标志位置上的对象}。</p><h2 id="EL表达式的作用："><a href="#EL表达式的作用：" class="headerlink" title="EL表达式的作用："></a>EL表达式的作用：</h2><ul><li>减少jsp中的以scriptlet形式存在的Java代码</li><li>空值取代错误信息</li><li>可以精确的访问对象的属性</li><li>可以访问集合</li><li>可以使用运算符<br>空值取代错误消息表示：如果没有设置任何域对象范围的age信息的时候，使用传统的getAttribute()方法，获取的信息是null，并且能够显示null，那么使用EL表达式之后，这个问题就不存在了，没有设置过的信息，获取的就是空值。<h2 id="EL从域中取出数据"><a href="#EL从域中取出数据" class="headerlink" title="EL从域中取出数据"></a>EL从域中取出数据</h2><h3 id="EL最主要的作用式获得四大域中的数据-格式-EL表达式"><a href="#EL最主要的作用式获得四大域中的数据-格式-EL表达式" class="headerlink" title="EL最主要的作用式获得四大域中的数据  格式 ${EL表达式}"></a><code>EL最主要的作用式获得四大域中的数据  格式 ${EL表达式}</code></h3></li></ul><ol><li>EL获得pageContext域中的值：${pageContextScope.key};  </li><li>EL获得request域中的值：${requestScope.key};  </li><li>EL获得sessiont域中的值：${sessionScope.key};  </li><li>EL获得application域中的值：${applicationScope.key};  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">例如</span><br><span class="line">&lt;!-- 脚本法是取出域中的值 --&gt;</span><br><span class="line">&lt;%=request.getAttribute(&quot;company&quot;) %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">User sessionUser = (User)session.getAttribute(&quot;user&quot;);</span><br><span class="line">out.write(sessionUser.getName());</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!-- 使用EL表达式获得域中的值 --&gt;</span><br><span class="line">$&#123;requestScope.company &#125;</span><br><span class="line">$&#123;sessionScope.user.name &#125;</span><br><span class="line">$&#123;applicationScope.list[1].name&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用el表达式 全域查找 --&gt;</span><br><span class="line">$&#123;company &#125;</span><br><span class="line">$&#123;user.name &#125;</span><br><span class="line">$&#123;list[1].name&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="EL的内置对象"><a href="#EL的内置对象" class="headerlink" title="EL的内置对象"></a>EL的内置对象</h2><h3 id="四个内置对象"><a href="#四个内置对象" class="headerlink" title="四个内置对象"></a>四个内置对象</h3><ol><li>pageScope  </li><li>requestScope  </li><li>sessionScope  </li><li><p>applicationScope</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>获取JSP中域的数据</p></li><li><p>param  paramValues  接受参数<br> 相当于request.getParameter()<br> request.getParameterValues()</p></li><li>header  headerValue  接受参数<br> 相当于 request.getHeader(name)<br> request.getHeaderValues(name)  </li><li>initParam<br>获取全局初始化参数<br> 相当于  this.getServletContext().getInitParameter(name)</li><li>cookie<br>WEB开发中cookie<br> 相当于 request.getCookies()  cookie.getName()  cookie.getValue()</li><li>pageContext<br> WEB开发中pageContext<br> 可以获得其他八大内置对象</li></ol><blockquote><p>${pageContext.request.contextPath}<br>相当于<br>&lt;%=pageContext.getRequest().getContextPath%&gt;<br>获得WEB应用的名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例子</span><br><span class="line">&lt;!-- 使用el获得参数 --&gt;</span><br><span class="line">$&#123;param.username &#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">$&#123;header[&quot;Host&quot;] &#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">$&#123;cookie.name&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">$&#123;cookie.name.value &#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;!-- 通过el表达式获得request对象 --&gt;</span><br><span class="line">$&#123;pageContext.request &#125;</span><br><span class="line">$&#123;pageContext&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="EL可以执行表达式运算"><a href="#EL可以执行表达式运算" class="headerlink" title="EL可以执行表达式运算"></a>EL可以执行表达式运算</h3><pre><code>&lt;!-- el可以执行表达式运算 --&gt;${1+1 }${1==1?true:false }&lt;!-- empty 判定某个对象是否是null  是null返回true --&gt;${empty list}</code></pre><h2 id="其他内置对象"><a href="#其他内置对象" class="headerlink" title="其他内置对象"></a>其他内置对象</h2><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">内容</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">pageContext</td><td style="text-align:center">表示的javax.servlet.jsp.PageContext对象</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">pageScope</td><td style="text-align:center">Page范围</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">requestScope</td><td style="text-align:center">Request范围</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">sessionScope</td><td style="text-align:center">Session范围</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">applicationScope</td><td style="text-align:center">Application范围</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">param</td><td style="text-align:center">接收传递到本页面的参数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">paramValues</td><td style="text-align:center">接收传递到本页面的一组参数</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">header</td><td style="text-align:center">获取一个头信息的内容</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">headerValues</td><td style="text-align:center">获取一组头信息的内容</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">cookie</td><td style="text-align:center">获取cookie</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">initParam</td><td style="text-align:center">获取初始化参数</td></tr></tbody></table><p>使用EL表达式获取不同范围相同名称的域对象信息的时候，获取的是最小的范围。<br>通过表达式的内置对象就可以获取指定范围的域对象的信息</p><h2 id="操作运算符"><a href="#操作运算符" class="headerlink" title="操作运算符"></a>操作运算符</h2><p>表达式语言中，为了方便的进行操作，提供了数学运算符、关系运算符、逻辑运算符，三元运算符等操作，在编写过程中，之前使用java 代码进行的运算都可以使用EL表达式完成，结合JSTL一起使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;h3&gt;arg1:$&#123; arg1&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;arg2:$&#123; arg2&#125;&lt;/h3&gt;</span><br><span class="line">&lt;!-- 数学运算 --&gt;</span><br><span class="line">&lt;h3&gt;加法运算：$&#123;arg1+arg2 &#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;减法运算：$&#123;arg1-arg2 &#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;乘法运算：$&#123;arg1*arg2 &#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;除法运算：$&#123;arg1/arg2 &#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;取模运算：$&#123;arg1%arg2 &#125;&lt;/h3&gt;</span><br><span class="line">&lt;!-- 关系运算 --&gt;</span><br><span class="line">&lt;h1&gt;关系运算 :$&#123;arg1 == 10 &#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;关系运算 :$&#123;arg1 != 10 &#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;关系运算 :$&#123;arg1 &gt; 10 &#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;关系运算 :$&#123;arg1 &lt; 10 &#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;关系运算 :$&#123;arg1 &gt;= 10 &#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;关系运算 :$&#123;arg1 &lt;= 10 &#125;&lt;/h1&gt;</span><br><span class="line">&lt;!-- 逻辑运算符 &amp;&amp;(and)  ||(or)  !(not) --&gt;</span><br><span class="line">&lt;h1&gt;逻辑运算符：$&#123;arg1 &gt; arg2 &amp;&amp; arg1 &lt;30 &#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;逻辑运算符：$&#123;arg1 &gt; arg2 and arg1 &lt;30 &#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;逻辑运算符：$&#123;arg1 &lt; arg2 || arg1 &gt; 30 &#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;逻辑运算符：$&#123;arg1 &gt; arg2 or arg1 &lt;30 &#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;逻辑运算符：$&#123;!(arg1 &lt; arg2 or arg1 &gt;30) &#125;&lt;/h1&gt;</span><br><span class="line">&lt;h1&gt;逻辑运算符：$&#123;not(arg1 &lt; arg2 or arg1 &gt;30) &#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;三元运算：$&#123;arg1&lt;arg2?100:1000 &#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;判断是否为空：$&#123;empty list &#125;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在开发中，逻辑运算，关系运算，判断是否为空，都经常接口 jstl标签使用 --&gt;</span><br><span class="line">&lt;c:if test=&quot;$&#123;empty list &#125;&quot;&gt;</span><br><span class="line">&lt;h1&gt;集合是空的&lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure></p><h1 id="JSTL技术"><a href="#JSTL技术" class="headerlink" title="JSTL技术"></a>JSTL技术</h1><p>JSTL(JSP standard Standard Tag Library)<br>jsp标准标签库<br>可以嵌入到jsp页面中使用标签的形式完成业务逻辑等功能<br>JSTL标准标签库有五个子库  主要使用核心库:  </p><ol><li>core:   c</li><li>I18N:   fmt</li><li>SQL:    sql</li><li>XML:    x</li><li>Functions:fn</li></ol><h2 id="导入相对性的jar包"><a href="#导入相对性的jar包" class="headerlink" title="导入相对性的jar包"></a>导入相对性的jar包</h2><p>将两个jar包导入到我们的lib工程中<br>使用jsp的taglib指令<br>jstl.jar<br>standar.jar<br>&lt;%@taglib uri =”<a href="http://java.sun.com/jsp/jstl&quot;" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl&quot;</a> prefix=”c” %&gt;  </p><h3 id="JSTL核心库的常用标签"><a href="#JSTL核心库的常用标签" class="headerlink" title="JSTL核心库的常用标签"></a>JSTL核心库的常用标签</h3><ol><li>&lt;c:if test=” “ &gt;标签<br> 其中test是返回boolean的条件</li><li>&lt;c:forEach &gt;标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">例子：从内置对象获取值</span><br><span class="line">&lt;h1&gt;取出字符串List的数据&lt;/h1&gt;</span><br><span class="line">&lt;c:forEach begin=&quot;0&quot; end=&quot;5&quot; var =&quot;i&quot;&gt;</span><br><span class="line">$&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;&lt;br/&gt;</span><br><span class="line">&lt;c:forEach items=&quot;$&#123;strList&#125;&quot; var=&quot;str&quot;&gt;</span><br><span class="line">$&#123;str &#125;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;取出user对象List的数据&lt;/h1&gt;</span><br><span class="line">&lt;c:forEach items=&quot;$&#123;userList&#125;&quot; var=&quot;user&quot;&gt;</span><br><span class="line">user的name：$&#123;user.name &#125;------user的password：$&#123;user.password &#125;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;取出字符串Map的数据&lt;/h1&gt;</span><br><span class="line">&lt;c:forEach items=&quot;$&#123;strMap &#125;&quot; var=&quot;entry&quot;&gt;</span><br><span class="line">$&#123;entry.key &#125;====$&#123;entry.value &#125;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;取出user对象 Map的数据&lt;/h1&gt;</span><br><span class="line">&lt;c:forEach items=&quot;$&#123;userMap &#125;&quot; var=&quot;entry&quot;&gt;</span><br><span class="line">$&#123;entry.key &#125;:$&#123;entry.value.name &#125;--$&#123;entry.value.password &#125;&lt;br/&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="javaEE模式"><a href="#javaEE模式" class="headerlink" title="javaEE模式"></a>javaEE模式</h1><h2 id="model1模式："><a href="#model1模式：" class="headerlink" title="model1模式："></a>model1模式：</h2><pre><code>技术组成：jsp+javaBean</code></pre><h2 id="model2模式"><a href="#model2模式" class="headerlink" title="model2模式"></a>model2模式</h2><pre><code>技术组成: jsp+servlet+javaBeanjsp数据显示servlet 获取数据</code></pre><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><pre><code>MVC  属性web层的技术M:model      ---JavaBean       :封装数据V:View       --- 视图       jsp:单纯的页面展示C:Controller --- 控制器 servlet:获取数据 对数据进行处理  传递数据  指派显示的页面</code></pre><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><pre><code>web层: servlet封装javaBean  jsp显示  SpringMVC  service层: 业务代码        Springdao层：   数据库查询        Mybatis </code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>EL表达式能够进行的操作有很多，可以大量的减少jsp中Java的代码量，在开发中，经常使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;EL表达式&quot;&gt;&lt;a href=&quot;#EL表达式&quot; class=&quot;headerlink&quot; title=&quot;EL表达式&quot;&gt;&lt;/a&gt;EL表达式&lt;/h1&gt;&lt;h2 id=&quot;EL表达式的介绍&quot;&gt;&lt;a href=&quot;#EL表达式的介绍&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="javaee" scheme="https://Cool-Loong.github.io/tags/javaee/"/>
    
      <category term="jsp" scheme="https://Cool-Loong.github.io/tags/jsp/"/>
    
      <category term="servlet" scheme="https://Cool-Loong.github.io/tags/servlet/"/>
    
      <category term="EL" scheme="https://Cool-Loong.github.io/tags/EL/"/>
    
      <category term="JSTL" scheme="https://Cool-Loong.github.io/tags/JSTL/"/>
    
  </entry>
  
  <entry>
    <title>Cookie对象和Session对象</title>
    <link href="https://Cool-Loong.github.io/2019/09/06/Cookie%E5%AF%B9%E8%B1%A1%E5%92%8CSession%E5%AF%B9%E8%B1%A1/"/>
    <id>https://Cool-Loong.github.io/2019/09/06/Cookie对象和Session对象/</id>
    <published>2019-09-06T08:41:29.000Z</published>
    <updated>2019-09-07T01:15:28.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h1><p>从打开一个浏览器访问某个站点，到关闭这个浏览器的整个过程，成为一次会话。会    话技术就是记录这次会话中客户端的状态与数据的。<br>会话技术分为Cookie和Session：</p><ul><li>Cookie：数据存储在客户端本地，减少服务器端的存储的压力，安全性不好，客户端    可以清除cookie</li><li><p>Session：将数据存储到服务器端，安全性相对好，增加服务器的压力</p></li><li><p>作用<br>存储客户端状态</p></li></ul><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>将用户的数据存储到客户端的技术</p><h2 id="服务器端向客户端发送一个Cookie"><a href="#服务器端向客户端发送一个Cookie" class="headerlink" title="服务器端向客户端发送一个Cookie"></a>服务器端向客户端发送一个Cookie</h2><ol><li>创建Cookie:<br> Cookie cookie = new Cookie(String name,Stirng value);</li><li>设置Cookie在客户端过期时间<br>Cookie.setMaxAge(intseconds)<br>单位：s  </li><li>设置Cookie的携带路径<br>Cookie.setPath(String path)<br>如果不设置携带路径，那么该cookie信息会在访问产生该cookie的    web资源所在的路径都携带cookie信息</li><li>向客户端发送Cookie<br>response.addCookie(Cookie cookie);</li><li>删除客户端的Cookie:<br>如果想删除客户端的已经存储的cookie信息，那么就使用同名同路径的持久化时    间为0的cookie进行覆盖即可  </li></ol><h2 id="服务器端怎么接受客户端携带的Cookie"><a href="#服务器端怎么接受客户端携带的Cookie" class="headerlink" title="服务器端怎么接受客户端携带的Cookie"></a>服务器端怎么接受客户端携带的Cookie</h2><ol><li>通过request获得所有的Cookie<br>Cookie[] cookies = request.getCookies();</li><li><p>遍历Cookie数组，通过Cookie的名称获得我们想要的Cookie</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(Cookie cookie:cookies)&#123;</span><br><span class="line">    if(cookie.getName().equals(cookieName))&#123;</span><br><span class="line">        String cookieValue = cookie.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法</p></li></ol><ul><li>getName()<br>获得Cookie名称</li><li>getValue()<br>获得Cookie的值 </li></ul><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p>Session技术是将数据存储在服务器端的技术，会为每个客户端都创建一块内存空间    存储客户的数据，但客户端需要每次都携带一个标识ID去服务器中寻找属于自己的内    存空间。所以说Session的实现是基于Cookie，Session需要借助于Cookie存储客    户的唯一性标识JSESSIONID  </p><h2 id="获得Session对象"><a href="#获得Session对象" class="headerlink" title="获得Session对象"></a>获得Session对象</h2><p>HttpSession session = request.getSession()<br>根据JSESSIONID判断该客户端是否在服务器上已经存在session了  </p><h2 id="向Session中存取数据"><a href="#向Session中存取数据" class="headerlink" title="向Session中存取数据"></a>向Session中存取数据</h2><p>session也是一个域对象   </p><ul><li>session.setAttribute(String name,String value)</li><li>session.getAttribute(String name)</li><li>session.removeAttribute(String name)</li></ul><h2 id="Session对象的生命周期"><a href="#Session对象的生命周期" class="headerlink" title="Session对象的生命周期"></a>Session对象的生命周期</h2><ol><li>创建<br>第一次执行request.getSession()时创建</li><li>销毁  <ul><li>服务器非正常关闭</li><li>session过期/失效（默认为三十分钟）<br>可以在工程中配置：<br><session-config><br>  <session-timeout>30<session-timeout><br><session-config></session-config></session-timeout></session-timeout></session-config></li><li>手动销毁session<br>session.invalidate();</li></ul></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>isNew()<br>判断当前session是不是新创建的</li><li>invalidate()<br>强制使Sessio对象无效</li><li>getServletContext()<br>返回ServletContext对象</li><li>getLastAccessedTime()<br>返回客户端最后一次发送与Session相关请求的时间</li><li>getCreationTime()<br>返回Session创建时间</li><li>getID()<br>返回与当前HttpSession对象关联的会话标识号</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;会话技术&quot;&gt;&lt;a href=&quot;#会话技术&quot; class=&quot;headerlink&quot; title=&quot;会话技术&quot;&gt;&lt;/a&gt;会话技术&lt;/h1&gt;&lt;p&gt;从打开一个浏览器访问某个站点，到关闭这个浏览器的整个过程，成为一次会话。会    话技术就是记录这次会话中客户端的状态与数据
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="Cookie" scheme="https://Cool-Loong.github.io/tags/Cookie/"/>
    
      <category term="Session" scheme="https://Cool-Loong.github.io/tags/Session/"/>
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="javaee" scheme="https://Cool-Loong.github.io/tags/javaee/"/>
    
      <category term="jsp" scheme="https://Cool-Loong.github.io/tags/jsp/"/>
    
      <category term="servlet" scheme="https://Cool-Loong.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>Servlet基础</title>
    <link href="https://Cool-Loong.github.io/2019/09/06/Servlet/"/>
    <id>https://Cool-Loong.github.io/2019/09/06/Servlet/</id>
    <published>2019-09-06T04:33:58.000Z</published>
    <updated>2019-09-07T02:15:16.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h1><h2 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h2><p>Servlet 运行在服务端的Java小程序，是sun公司提供一套规范（接口），用来处理客户端请求、响应给浏览器的动态资源。但servlet的实质就是java代码，通过java的API    动态的向客户端输出内容  </p><ul><li>技术点</li></ul><ol><li>servlet技术</li><li>filter技术 过滤器</li><li>listener技术 监听器</li></ol><ul><li>作用<br>用来处理从客户端发送过来的请求，并对该请求做出响应  <ol><li>获取请求数据  </li><li>处理请求  </li><li>完成响应  </li></ol></li></ul><h1 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h1><h2 id="Servlet接口中方法"><a href="#Servlet接口中方法" class="headerlink" title="Servlet接口中方法"></a>Servlet接口中方法</h2><ol><li><p>init(ServletConfig config)<br>何时执行：servlet对象创建的时候执行<br>ServletConfig ： 代表的是该servlet对象的配置信息  </p></li><li><p>service（ServletRequest request,ServletResponse response）<br>何时执行：每次请求都会执行<br>ServletRequest ：代表请求 认为ServletRequest 内部封装的是http请求的信息<br>ServletResponse ：代表响应 认为要封装的是响应的信息  </p></li><li><p>destroy()<br>何时执行：servlet销毁的时候执行  </p><h2 id="HttpServlet类的方法"><a href="#HttpServlet类的方法" class="headerlink" title="HttpServlet类的方法"></a>HttpServlet类的方法</h2></li><li>init()</li><li>doGet(HttpServletRequest request,HttpServletResponse response)</li><li>doPost(HttpServletRequest request,HttpServletResponse response)</li><li><p>destroy()</p><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>1。 Servlet何时创建<br>默认第一次访问servlet时创建该对象</p></li><li><p>Servlet何时销毁<br>服务器关闭servlet就销毁了</p></li><li><p>每次访问必然执行的方法<br>service(ServletRequest req, ServletResponse res)方法</p></li></ol><h1 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h1><h2 id="什么是ServletContext对象"><a href="#什么是ServletContext对象" class="headerlink" title="什么是ServletContext对象"></a>什么是ServletContext对象</h2><p>ServletContext代表是一个web应用的环境（上下文）对象，ServletContext对象    内部封装是该web应用的信息，ServletContext对象一个web应用只有一个  </p><h2 id="ServletContext对象的生命周期？"><a href="#ServletContext对象的生命周期？" class="headerlink" title="ServletContext对象的生命周期？"></a>ServletContext对象的生命周期？</h2><ol><li>创建：该web应用被加载（服务器启动或发布web应用（前提，服务器启动状        态））</li><li>销毁：web应用被卸载（服务器关闭，移除该web应用）<h2 id="ServletContext对象的作用"><a href="#ServletContext对象的作用" class="headerlink" title="ServletContext对象的作用"></a>ServletContext对象的作用</h2></li><li>获得web应用全局的初始化参数  </li><li>获得web应用中任何资源的绝对路径<br> String path = ServletContext.getRealPath();  </li><li>ServletContext是一个域对象<br>作用范围: 整个web应用</li><li>获得Servlet配置信息<br>getInitParameter(String name)<br>获得 初始化参数<br>getInitParameterNames()<br>获得所有servlet的初始化参数的名称<br>getServleContext()<br>获得ServletContext对象<br>getServletName()<br>获得servlet在web.xml中配置的name的值  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Servlet简介&quot;&gt;&lt;a href=&quot;#Servlet简介&quot; class=&quot;headerlink&quot; title=&quot;Servlet简介&quot;&gt;&lt;/a&gt;Servlet简介&lt;/h1&gt;&lt;h2 id=&quot;什么是Servlet&quot;&gt;&lt;a href=&quot;#什么是Servlet&quot; cla
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="javaee" scheme="https://Cool-Loong.github.io/tags/javaee/"/>
    
      <category term="servlet" scheme="https://Cool-Loong.github.io/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>response对象基础</title>
    <link href="https://Cool-Loong.github.io/2019/09/05/response%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://Cool-Loong.github.io/2019/09/05/response对象基础/</id>
    <published>2019-09-05T10:56:14.000Z</published>
    <updated>2019-09-05T13:58:08.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HttpServletResponse概述"><a href="#HttpServletResponse概述" class="headerlink" title="HttpServletResponse概述"></a>HttpServletResponse概述</h1><p>我们在创建Servlet时会覆盖service()方法，或doGet()/doPost(),这些方法都有两个参数，一个为代表请求的request和代表响应response。<br>service方法中的response的类型是ServletResponse，而doGet/doPost方法的response的类型是HttpServletResponse，HttpServletResponse是ServletResponse的子接口，功能和方法更加强大</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="状态码相关（响应行）"><a href="#状态码相关（响应行）" class="headerlink" title="状态码相关（响应行）"></a>状态码相关（响应行）</h2><ul><li>setStatus(int status)<br>设置HTTP响应消息的状态码，并生成响应状态行</li></ul><h2 id="响应消息头方法"><a href="#响应消息头方法" class="headerlink" title="响应消息头方法"></a>响应消息头方法</h2><ul><li>void addHeader(String name,String value)<br>  void setHeader(String name,String value)<br>  设置HTTP响应头消息<br>  name 名称<br>  value  响应头字段  </li><li>void addIntHeader(String name,int value)<br>  void SetIntHeader(String name,int value)<br>  设置包含整数值得响应头</li><li>void setContentLength(int len)<br>  设置响应消息的实体内容的大小  </li><li>void setContentType(String type)<br>  输出MIME类型</li><li>void setLocale(Locale loc)<br>  设置响应消息的本地化消息</li><li>void setCharacterEncoding(String charset)<br>  设置输出内容使用的字符编码</li><li>void addCookie(cook)<br>设置Cookie<h2 id="响应消息体方法"><a href="#响应消息体方法" class="headerlink" title="响应消息体方法"></a>响应消息体方法</h2></li><li>getOutputStream()<br>  获取字节输出流对象ServletOutputStream</li><li>getWriter()<br>  获取字符输出流对象PrintWriter<h2 id="重定向操作"><a href="#重定向操作" class="headerlink" title="重定向操作"></a>重定向操作</h2></li><li>sendRedirect(跳转的路径)<br>可以自行跳转，跳转之后地址栏发生了变化，这种跳转是重定向跳转，也就是客户端跳转</li></ul><h2 id="文件下载原理"><a href="#文件下载原理" class="headerlink" title="文件下载原理"></a>文件下载原理</h2><p>通过设置文件的路径和HTTP协议中设置两个响应消息头  </p><ol><li>Content-Disposition:attachment;filename=w文件名</li><li>Content-type: application/x-msdownload<br>通过这两个响应消息头字段来指定接收程序处理数据内容的方式为下载方式</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HttpServletResponse概述&quot;&gt;&lt;a href=&quot;#HttpServletResponse概述&quot; class=&quot;headerlink&quot; title=&quot;HttpServletResponse概述&quot;&gt;&lt;/a&gt;HttpServletResponse概述&lt;/
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="javaee" scheme="https://Cool-Loong.github.io/tags/javaee/"/>
    
      <category term="jsp" scheme="https://Cool-Loong.github.io/tags/jsp/"/>
    
      <category term="servlet" scheme="https://Cool-Loong.github.io/tags/servlet/"/>
    
      <category term="response" scheme="https://Cool-Loong.github.io/tags/response/"/>
    
  </entry>
  
  <entry>
    <title>request对象基础</title>
    <link href="https://Cool-Loong.github.io/2019/09/05/request%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://Cool-Loong.github.io/2019/09/05/request对象基础/</id>
    <published>2019-09-05T08:22:40.000Z</published>
    <updated>2019-09-05T12:34:33.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>request对象是jsp中使用的频率最高的内置对象之一，表示的是客户端向服务端发送请求，主要作用就是接收客户端请求的信息，比如接收请求参数、请求头信息、Cookie，客户端IP等等</p><h1 id="request方法"><a href="#request方法" class="headerlink" title="request方法"></a>request方法</h1><ul><li>String getContextPath()<br>获取上下文资源的路径</li><li>Cookie[] getCookies()<br>获取Cookie</li><li>String getHeader(String name)<br>获取头信息</li><li>Enumeration getHeaderNames()<br>获取所有的头信息的名称</li><li>HttpSession getSession()<br>获取HttpSession对象</li><li>String getServletPath()<br>获取请求路径</li><li>String getParameter(String name)<br>根据参数名称获取参数的值</li><li>Enumeration getParameterNames()<br>获取所有的参数的名称</li><li>String[] getParameterValues(String name)<br>根据参数名称获取多个值</li><li>String getRemoteAddr()<br>获取客户端IP</li><li>void setCharacterEncoding(String env)<br>设置请求的统一编码<br>。。。</li></ul><h2 id="通过request获得请求行"><a href="#通过request获得请求行" class="headerlink" title="通过request获得请求行"></a>通过request获得请求行</h2><ol><li>获得客户端的请求方式：<br> String getMethod()<br> GET  POST</li><li>获得请求的资源：<ul><li>String getRequestURI()<br>获得请求的uri(不包括http协议和主机名，端口号)</li><li>StringBuffer getRequestURL()<br>获得请求的URL</li><li><code>String getContextPath()</code><br>获取web应用的名称  </li><li>String getQueryString()<br>  get提交url地址后的参数字符串<br>  eg：username=zhangsan&amp;password=123</li></ul></li></ol><h2 id="通过request获得请求头"><a href="#通过request获得请求头" class="headerlink" title="通过request获得请求头"></a>通过request获得请求头</h2><ol><li>long getDateHeader(String name)</li><li>String getHeader(String name)</li><li>Enumeration getHeaderNames()</li><li>Enumeration getHeaders(String name)</li><li>int getIntHeader(String name)</li></ol><h2 id="通过request获得请求体"><a href="#通过request获得请求体" class="headerlink" title="通过request获得请求体"></a>通过request获得请求体</h2><ol><li>String getParameter(String name) </li><li>String[] getParameterValues(String name)</li><li>Enumeration getParameterNames()</li><li>Map&lt;String,String[]&gt; getParameterMap()</li></ol><h2 id="解决提交乱码问题"><a href="#解决提交乱码问题" class="headerlink" title="解决提交乱码问题"></a>解决提交乱码问题</h2><ol><li>解决post提交方式的乱码：<br> request.setCharacterEncoding(“UTF-8”);</li><li><p>解决get提交的方式的乱码：<br> parameter = new String(parameter.getbytes(“iso8859-1”),”utf-8”);</p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><h3 id="request是一个域对象"><a href="#request是一个域对象" class="headerlink" title="request是一个域对象"></a>request是一个域对象</h3><blockquote><p>request对象也是一个存储数据的区域对象，所以也具有如下方法：</p></blockquote></li><li><p>setAttribute(String name, Object o)</p></li><li>getAttribute(String name)</li><li>removeAttribute(String name)</li></ol><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><ul><li>获得请求转发器—-path是转发的地址<br>RequestDispatcher getRequestDispatcher(String path)</li><li><p>通过转发器对象转发<br>requestDispathcer.forward(ServletRequest request, ServletResponse response)</p></li><li><p>转发与重定向的区别？</p><ol><li>重定向两次请求，转发一次请求  </li><li>重定向地址栏的地址变化，转发地址不变  </li><li>重新定向可以访问外部网站 转发只能访问内部资源  </li><li>转发的性能要优于重定向  </li></ol></li></ul><h2 id="通过request获取客户端信息"><a href="#通过request获取客户端信息" class="headerlink" title="通过request获取客户端信息"></a>通过request获取客户端信息</h2><ul><li>request.getRemoteAddr()<br>获得访问的客户端IP地址</li><li>request.getRemoteHost()<br>获取请求客户端的完整主机名</li><li>request.getRemotePort()<br>获取远程端口号</li></ul><h2 id="访问路径"><a href="#访问路径" class="headerlink" title="访问路径"></a>访问路径</h2><ul><li>相对路径<br>相对于前一级目录</li><li>绝对路径<br>转发，地址栏不变，跳转的时候不是按照跳转前后文件的目录级别来区别路径<br>而是根据当前页面的地址栏的路径和跳转后的路径来获取 ，所有转发使用绝对路径避免404错误</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;request对象是jsp中使用的频率最高的内置对象之一，表示的是客户端向服务端发送请求，主要作用就是接收客户端请求的信息，比如接收请求参数
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="javaee" scheme="https://Cool-Loong.github.io/tags/javaee/"/>
    
      <category term="jsp" scheme="https://Cool-Loong.github.io/tags/jsp/"/>
    
      <category term="reqeuest" scheme="https://Cool-Loong.github.io/tags/reqeuest/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="https://Cool-Loong.github.io/2019/09/04/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>https://Cool-Loong.github.io/2019/09/04/Linux基础/</id>
    <published>2019-09-04T02:18:05.000Z</published>
    <updated>2019-09-04T02:18:59.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><ul><li>cd  -  返回上一次目录</li><li>cd ..  返回上一级目录</li><li>cd /   返回根目录</li><li>cd user  进入指定目录</li><li>cd .   进入本路径</li></ul><h1 id="文件夹操作"><a href="#文件夹操作" class="headerlink" title="文件夹操作"></a>文件夹操作</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code>mkdir test mkdir yyy/new 参数  </code></pre><h2 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h2><pre><code>ls 展示可见文件ls -a  展示所有文件ls -l  --&gt; ll  展示每一个文件具体的信息 权限</code></pre><h2 id="查找目录"><a href="#查找目录" class="headerlink" title="查找目录"></a>查找目录</h2><pre><code>find  /root -name &apos;*test&apos;</code></pre><h2 id="修改目录名称"><a href="#修改目录名称" class="headerlink" title="修改目录名称"></a>修改目录名称</h2><pre><code>mv 旧名称  新名称将yyy移动到根目录mv  yyy   /  mv不仅可以对文件夹，也可以对文件进行剪切</code></pre><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><pre><code>将aaa拷贝到根目录cp aaa /-r 拷贝文件夹中的字文件</code></pre><h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><pre><code>rm  -rf  目录re test-r 递归 删除里面的内容-f 强制删除 里面的内容</code></pre><ul><li>mkdir  test  创建文件夹</li><li>rmdir  test  删除文件夹</li></ul><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h2><ul><li>touch xxx.txt<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2></li><li>cat/more/less/tail</li></ul><ol><li>cat  只能显示一屏幕</li><li>more  可以显示全部内容  回车加一行 空格翻页 q t退出</li><li>less</li><li>tail 看文件后面的内容<br>tail -f 动态监控  文件变化<br>ctrl + c 强制退出<h2 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h2> vim  文件<br> 进入命令模式<br> i 进入编辑模式<br> esc 退出编辑模式 进入命令行模式<br> q 退出  qw 保存退出  ！ 强制</li></ol><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><pre><code>rm -rf 文件名</code></pre><h1 id="压缩解压文件"><a href="#压缩解压文件" class="headerlink" title="压缩解压文件"></a>压缩解压文件</h1><h2 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h2><pre><code>打包文件一般是.tar结尾  压缩命令一般是以.gz结尾的一般打包压缩是一起使用的  后缀为.tar.gz</code></pre><ul><li>tar -zcvf 打包压缩后的文件名 要打包压缩的文件  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">z: 调用gzip压缩命令进行压缩</span><br><span class="line">c: 打包文件</span><br><span class="line">v: 显示运行过程</span><br><span class="line">f: 指定文件名</span><br><span class="line">eg: tar -zcvf xxx.tar.gz aa.txt bbb.txt ccc.conf</span><br></pre></td></tr></table></figure></li></ul><h2 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h2><pre><code>命令：tar -[xvf] 压缩文件其中 ： x 代表压缩文件示例： 将/test下的xxx.tar.gz解压到当前目录下tar -xvf xxx.tar.gz</code></pre><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><h2 id="显示当前位置"><a href="#显示当前位置" class="headerlink" title="显示当前位置"></a>显示当前位置</h2><pre><code>pwd </code></pre><h2 id="搜索命令"><a href="#搜索命令" class="headerlink" title="搜索命令"></a>搜索命令</h2><pre><code>grep 要搜索的字符串 要搜索的文件eg:  grep to sudo.conf</code></pre><h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><pre><code>|  将前一个命令的输出作为本次目录的输入示例： 查看当前系统中所有的进程中包括system字符串的进程  ps -ef | grep system  </code></pre><h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><pre><code>命令 ： ps -ef</code></pre><h2 id="杀死进程"><a href="#杀死进程" class="headerlink" title="杀死进程"></a>杀死进程</h2><pre><code>kill -9 进程的id</code></pre><h2 id="网络通信命令"><a href="#网络通信命令" class="headerlink" title="网络通信命令"></a>网络通信命令</h2><pre><code>ifconfig查看网络通信ping  ip地址查看连接情况netstat -an查看当前系统的端口使用</code></pre><h1 id="权限命令"><a href="#权限命令" class="headerlink" title="权限命令"></a>权限命令</h1><pre><code>每个文件目录都有权限ls -l 查看权限    1    2     3     4    _    ___   ___   ___ 文件类型  主权限  组权限  其他用户权限1: d 文件夹 - 文件 l (link)快捷方式 r 可读readw 可写 writex 可执行 - 代表没有该权限文件类型：</code></pre><h2 id="修改文件、目录的权限命令"><a href="#修改文件、目录的权限命令" class="headerlink" title="修改文件、目录的权限命令"></a>修改文件、目录的权限命令</h2><pre><code>chmod示例： 修改/test下的aaa.txt的权限为属有全部权限所属组有读写权限其他用户有读权限chmod u =rwx,g=rw,0=r aaa.txtuser group other数字表示r 4 w 2  x 1</code></pre><h1 id="mysql安装"><a href="#mysql安装" class="headerlink" title="mysql安装"></a>mysql安装</h1><h2 id="查看CentOS自带的mysql"><a href="#查看CentOS自带的mysql" class="headerlink" title="查看CentOS自带的mysql"></a>查看CentOS自带的mysql</h2><pre><code>输入 rpm -qa | grep mysql </code></pre><h2 id="将自带的mysql卸载"><a href="#将自带的mysql卸载" class="headerlink" title="将自带的mysql卸载"></a>将自带的mysql卸载</h2><pre><code>rpm -e --nodeps mysql</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;目录操作&quot;&gt;&lt;a href=&quot;#目录操作&quot; class=&quot;headerlink&quot; title=&quot;目录操作&quot;&gt;&lt;/a&gt;目录操作&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;cd  -  返回上一次目录&lt;/li&gt;
&lt;li&gt;cd ..  返回上一级目录&lt;/li&gt;
&lt;li&gt;cd /   返
      
    
    </summary>
    
      <category term="linux" scheme="https://Cool-Loong.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://Cool-Loong.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="https://Cool-Loong.github.io/2019/09/04/Redis%E5%9F%BA%E7%A1%80/"/>
    <id>https://Cool-Loong.github.io/2019/09/04/Redis基础/</id>
    <published>2019-09-04T02:16:36.000Z</published>
    <updated>2019-09-07T13:20:48.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h1><pre><code>Redis是用C语言开发的一个开源的高性能键值对数据库，它通过提供多种键值数据类型来适应不同场景下的存储需求</code></pre><h2 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型:"></a>支持的数据类型:</h2><ol><li>字符串类型(String)</li><li>散列类型(hashMap  )</li><li>列表类型（list）</li><li>集合类型(set)</li><li>有序集合类型(sortset)</li></ol><ul><li><p>开启Redis  </p><ol><li>前端方式<br>./redis-server</li><li>后端方式<br>./redis-server redis.conf</li></ol></li><li><p>关闭Redis  </p><ol><li>直接关闭进程<br> ps -ef | grep redis<br> 查找到和Redis相关的进程<br> kill -9 pid</li><li>正常关闭<br> ./redis-cli shutdown</li></ol></li></ul><h1 id="Redis对外网端口开放"><a href="#Redis对外网端口开放" class="headerlink" title="Redis对外网端口开放"></a>Redis对外网端口开放</h1><h2 id="查看对外开放的端口状态"><a href="#查看对外开放的端口状态" class="headerlink" title="查看对外开放的端口状态"></a>查看对外开放的端口状态</h2><pre><code>查看已经开放的端口状态  netstat -anp  查询指定端口是否开放firewall-cmd --query-port=6379/tcp  注意：yes 表示开启 no 表示未开启  </code></pre><h2 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h2><pre><code>systemctl status firewalld  开启防火墙：systemctl start firewalld关闭防火墙:systemctl stop firewalld开发服务service firewalld start  </code></pre><h2 id="对外开放端口"><a href="#对外开放端口" class="headerlink" title="对外开放端口"></a>对外开放端口</h2><pre><code>添加端口firewall-cmd --add-port=6379/tcp --permanent</code></pre><h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>redis是一种高级的key-value存储系统，其中value支持五种数据类型  <ol><li>字符串（String)</li><li>哈希（hash)</li><li>字符串列表（list）</li><li>字符串集合（set）</li><li>有序字符串集合（Sorted set）通过权重排序</li></ol></li><li>关于key的定义<ol><li>key 不要太长，不要超过1024个字节，会降低查找效率</li><li>key 不要太短，太短会降低key的可读性</li><li>key 有统一的命名规范<h2 id="存储String"><a href="#存储String" class="headerlink" title="存储String"></a>存储String</h2>字符串类型是redis中最为基础的数据存储类型，它在Redis 中是二进制安全的，这意味着该类型存入和获取的数据相同，在Redis中字符串类型的Value最多可以容纳的数据长度是512M</li></ol></li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><pre><code>set key valueset username  张三</code></pre><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><pre><code>1.get key  eg: get username2.getset key value 先获取该key的值，然后再设置该key的值    eg: getset name loong</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><pre><code>del key 删除指定key</code></pre><h3 id="数值增减（数字）"><a href="#数值增减（数字）" class="headerlink" title="数值增减（数字）"></a>数值增减（数字）</h3><pre><code>- incr       类似于i++ - decr      类似于i--- incrby key increment      将指定的key 的value原子性增加increment      eg： incrby num 5  - decrby key decrement      将指定的key 的value原子性减少decrement      eg: decrby num 3- append key value      拼凑字符串，追加value    eg: append username xxx</code></pre><h2 id="存储hash"><a href="#存储hash" class="headerlink" title="存储hash"></a>存储hash</h2><pre><code>具有String key 和 String value的map容器，适合存储值对象每一个Hash可以存储4294967295个键值对</code></pre><h3 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h3><ul><li>hset key field value<br>  为指定的key设定field/value对<br>  eg: hset myhash username jack<pre><code>hset myhash age 18</code></pre></li><li>hmset key field value (field2 value2 …)<br>  设置key中的多个field/value<br>  eg： hmset myhash2 username rose age 21</li></ul><h3 id="取值-1"><a href="#取值-1" class="headerlink" title="取值"></a>取值</h3><ul><li>hget key field<br>  返回指定的key中的field的值<br>  eg: hget myhash username</li><li>hmget key field (field2)<br>  返回指定的key中的多个field的值<br>  eg: hmget myhash name age addr<br>-hgetall key<br>  取出key所有的filed -value<br>  eg: hgetall myhash</li></ul><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul><li>hdel key field (field2)<br>  删除hash中的某一个属性<br>  eg: hdel myhash age</li><li>hdelall key<br>  删除所有内容</li><li>del key<br>  删除整个key</li></ul><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><pre><code>incrby key field increment </code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>hexists key field<br>  判断指定key中的field是否存在</li><li>hlen key<br>  获取key所包含的field的数量</li><li>hkeys key<br>  获取所有的key</li><li>hvals key<br>  获取所有的value</li></ul><h2 id="存储list"><a href="#存储list" class="headerlink" title="存储list"></a>存储list</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><ul><li>lpush key values [value1,value2…]<br>  在指定key所关联的list的头部插入所有的values<br>  头部插入数据，插入成功，返回元素的个数</li><li>rpush key values[value1,value2 ]<br>  在该list的尾部添加元素<br>  rpush mylist a b c d<h3 id="取值-2"><a href="#取值-2" class="headerlink" title="取值"></a>取值</h3></li><li>lrange key start end<br>  获取链表中从start 到end的元素的值<br>  start ,end从0 开始计数，也可以为负数<br>  若为-1则表示链表尾部的元素<br>  eg: lrange mylist 0 5</li></ul><h3 id="两端弹出"><a href="#两端弹出" class="headerlink" title="两端弹出"></a>两端弹出</h3><ul><li>lpop key<br>  返回并弹出指定的key关联的链表中的第一个元素（头部元素）<br>  如果不存在 ，返回nil ,如果key存在,则返回链表的头部元素<br>  lpop mylist</li><li>rpop key<br>  从尾部弹出元素<br>  eg: rpop mylist<h3 id="获取列表的元素的个数"><a href="#获取列表的元素的个数" class="headerlink" title="获取列表的元素的个数"></a>获取列表的元素的个数</h3></li><li>llen key<br>  返回指定的key关联的链表中的元素的数量<br>  eg: llen mylist</li></ul><h3 id="扩展命令"><a href="#扩展命令" class="headerlink" title="扩展命令"></a>扩展命令</h3><ul><li>lpushx key value<br>  仅当参数中指定的key存在时，向关联的list的头部插入value<br>  如果不存在，将不进行插入</li><li>rpushx key value<br>  在该list的尾部添加元素</li><li>lrem key count value<br>  删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素<br>  如果count 小于0 则从尾向头遍历并删除，如果count等于0，则删除链表中所有等于value的元素<br>  eg : lrem mylist 2 3   从头删除，2个数字3</li><li>lset key index value<br>  设置链表中的index的角标的元素值，0代表链表的头元素，-1代表链表的为元素操作链表的角标不存在则会抛出异常，相当于替换<br>  eg: lset mylist 3 444</li><li>linsert key before|after pivot value<br>  在pivot元素前或者元素后面插入value这个元素<br>  eg ： linsert mylist after a yyy</li><li>rpoplpush resource destination<br>  将链表中的为尾部元素弹出并添加到头部元素（循环操作）<br>  eg: rpoplpush mylist1 mylist2<br>  将mylist1右端弹出 ，压入到mylist2的左边</li></ul><h2 id="存储Set"><a href="#存储Set" class="headerlink" title="存储Set"></a>存储Set</h2><pre><code>没有排序的字符集合，和list一样，可以执行添加，删除，修改等操作和list不同的是，`set集合中不允许出现重复的元素`</code></pre><h3 id="添加-1"><a href="#添加-1" class="headerlink" title="添加"></a>添加</h3><ul><li>sadd key values[value1,value2…]<br>  向set中添加数据<br>  如果该key值已有则不会重复添加<br>  eg: sadd myset a b c<h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3></li><li>srem key membbers[member1,member2…]<br>  删除set中指定成员<br>  eg： srem myset 1 2<h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3></li><li>smembers key<br>  获取set中所有的成员</li><li>sismember key member<br>  判断参数中指定成员是否在该set中，1表示在，0 表示不在<h3 id="差集运算"><a href="#差集运算" class="headerlink" title="差集运算"></a>差集运算</h3></li><li>sdiff key1 key2 key3 …<br>  返回key1和key2中相差的成员，而且与key的顺序有关，即返回差集<br>  属于key1 并且不属于key2的元素构成的集合<h3 id="交集运算"><a href="#交集运算" class="headerlink" title="交集运算"></a>交集运算</h3>  sinter key1 key 2 key3 …<br>  返回交集<br>  属于key1并且属于key2的元素构成的集合<br>  eg: sinter myset1 myset2<h3 id="并集运算"><a href="#并集运算" class="headerlink" title="并集运算"></a>并集运算</h3>  sunion key1 key2 key3 …<br>  返回并集<br>  属于key1或者属于key2的元素构成的集合</li></ul><h3 id="扩展命令-1"><a href="#扩展命令-1" class="headerlink" title="扩展命令"></a>扩展命令</h3><ul><li>scard key<br>  获取set中成员的数量<br>  eg: scard myset</li><li>srandmember key<br>  随机返回一个set中的成员<br>  eg:srandmember myset</li><li>sdiffstore destination key1 key2 key3…<br>  将key1 ,key2相差的成员存储在destination上<br>  eg: sdiffstore myset myset1 myset2</li><li>sinterstore destination key[key…]<br>  将返回的交集存储在destination上</li><li>sunionstore destination key[key…]<br>  将返回的并集存储在destination上</li></ul><h2 id="存储sorted-set"><a href="#存储sorted-set" class="headerlink" title="存储sorted set"></a>存储sorted set</h2><pre><code>sorted set 和set 类型极为相似，都是字符串集合，都不允许重复的成员出现在一个setzhogn 他们之间的主要差别是sorted set中的每一个成员都会有一个分数与之关联，redis正是通过分数来为集合中的成员进行从小到大的顺序，同时分数是可以重复的</code></pre><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>新增元素<br>  zadd key score number </li><li>获得元素<br>  zscore key mumber<br>  返回指定成员的分数</li><li>删除元素  <ol><li>zrem key member[member…]<br>移除集合中指定成员 可以指定多个成员 </li><li>zremrangebyrank key start stop<br>按照排名范围删除元素</li></ol></li><li><p>范围查询 </p><ol><li>zrange key start end [withscores];<br>获得集合中角标为start - end 的成员<br>[widthscores]：代表返回成员包含的分数</li><li>zrevrange key start end [withscores];<br>按照scores从大到小的顺序返回索引从start到stop之间的所有元素</li></ol></li><li><p>获得成员数量<br>  zcard -key</p></li><li>设置指定成员增加的分数，返回值为跟更新后的分数<br>  zincrby key increment member</li><li>获取分数在[min,max]之间的成员个数<br>  zcount key min max</li><li>返回成员在集合中的排名（从小到大）<br>  zrank key member</li><li>返回成员在集合中的排名（从大到小）<br>  zrevrank key member</li></ul><h1 id="Keys通用操作"><a href="#Keys通用操作" class="headerlink" title="Keys通用操作"></a>Keys通用操作</h1><h2 id="keys-pattern"><a href="#keys-pattern" class="headerlink" title="keys pattern"></a>keys pattern</h2><p>获取所有与pattern匹配的key,返回所有与该key匹配的keys。<br>*代表任意一个或多个字符<br>? 代表任意一个字符  </p><h2 id="del-key1-key2-…"><a href="#del-key1-key2-…" class="headerlink" title="del key1 key2 …"></a>del key1 key2 …</h2><p>删除指定的key<br>可以一次删除多个</p><h2 id="exists-key"><a href="#exists-key" class="headerlink" title="exists key"></a>exists key</h2><p>判断该key 是否存在<br>1 代表存在<br>0 代表不存在</p><h2 id="rename-key-newkey"><a href="#rename-key-newkey" class="headerlink" title="rename key newkey"></a>rename key newkey</h2><p>为当前的key重命名</p><h2 id="expire-key-过期时间"><a href="#expire-key-过期时间" class="headerlink" title="expire key 过期时间"></a>expire key 过期时间</h2><p>设置过期时间<br>单位：秒s</p><h2 id="ttl-key"><a href="#ttl-key" class="headerlink" title="ttl key"></a>ttl key</h2><p>获取该key所剩的超时时间<br>如果没有设置超时 返回-1<br>如果返回-2 表示超时不存在  </p><h2 id="type-key"><a href="#type-key" class="headerlink" title="type key"></a>type key</h2><p>获取指定key的类型<br>该命令将以字符串的格式返回<br>返回的字符串为String,list,set,hash和zset<br>如果key不存在返回none</p><h1 id="Redis-特性"><a href="#Redis-特性" class="headerlink" title="Redis 特性"></a>Redis 特性</h1><h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><p>一个redis可以提供16个数据库<br>下标从0 到15<br>客户端可以指定连接某个redis实例的哪个数据库<br>客户端默认连接0号数据库<br>也可以通过select选择连接哪个数据库<br>eg: select 1 选择1号数据库  </p><ul><li>将newkey移植到1号库<br>move newkey 1;<br>将当前库的key移植到1号库中  </li></ul><h2 id="服务器命令"><a href="#服务器命令" class="headerlink" title="服务器命令"></a>服务器命令</h2><ul><li>ping<br>测试连接是否存活  </li><li>echo<br>在命令行打印一些内容<br>echo loong</li><li>select<br>选择数据库<br>redis数据库编号从0~15<br>可以选择任意一个数据库来进行数据的存取  </li><li>quit<br>退出连接</li><li>dbsize<br>返回当前数据库中key的数目</li><li>info<br>获取服务器的信息和统计</li><li>flushdb<br>删除当前选择数据库中的所有key</li><li>flushall<br>删除所有数据库中的所有key</li></ul><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><ul><li>订阅频道<br>  subscribe channel</li><li>批量订阅频道<br>  psubscribe channel<em>;<br>  例: psubscribe s</em><br>  订阅以‘s’开头的频道  </li><li>发布消息<br>  publish channel content<br>  在指定的频道中发布消息<br>  例: publish mychat  ‘today is good day’<h2 id="reis事务"><a href="#reis事务" class="headerlink" title="reis事务"></a>reis事务</h2></li><li>mutil<br>  开启事务用于标记事务的开始,其后执行的命令都将被存入命令队列，直到执行exec时，这些命令才会被原子执行</li><li>exec<br>  提交事务 ,类似于关系型数据库中的：commit</li><li>discard<br>  事务回滚，类似于关系数据库中的rollback</li></ul><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>redis的高性能是由于其将所有数据都存储在了内存中，为了使redis在重启之后任能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化</p><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><h4 id="RDB方式-redis-databases"><a href="#RDB方式-redis-databases" class="headerlink" title="RDB方式(redis databases)"></a>RDB方式(redis databases)</h4><pre><code>默认支持，无需配置  在指定时间间隔内将内存中的数据集快照写入到磁盘  Snapshot快照 ，它恢复时是将快照文件直接读到内存中  如果需要进行大规模数据的恢复，并且对于数据恢复的完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效</code></pre><h5 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h5><p>最后一次持久化后的数据可能丢失<br>fork的时候内存中需要保存两份数据</p><ul><li>Rdb保存的是dump.rdb</li></ul><h4 id="AOF方式（append-only-file）"><a href="#AOF方式（append-only-file）" class="headerlink" title="AOF方式（append only file）"></a>AOF方式（append only file）</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是Redis&quot;&gt;&lt;a href=&quot;#什么是Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是Redis&quot;&gt;&lt;/a&gt;什么是Redis&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Redis是用C语言开发的一个开源的高性能键值对数据库，它通过提供多种键值数
      
    
    </summary>
    
      <category term="数据库" scheme="https://Cool-Loong.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="redis" scheme="https://Cool-Loong.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"/>
    
    
      <category term="redis" scheme="https://Cool-Loong.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>jsp基础</title>
    <link href="https://Cool-Loong.github.io/2019/09/04/jsp%E5%9F%BA%E7%A1%80/"/>
    <id>https://Cool-Loong.github.io/2019/09/04/jsp基础/</id>
    <published>2019-09-04T02:14:08.000Z</published>
    <updated>2019-09-10T04:18:51.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h1><pre><code>java Server Pagejsp本质就是servlet   </code></pre><h1 id="jsp脚本"><a href="#jsp脚本" class="headerlink" title="jsp脚本"></a>jsp脚本</h1><ol><li>&lt;%java代码%&gt;<br> 定义局部变量，定义语句<br> 被翻译到service方法内部   </li><li>&lt;%=java变量 或表达式%&gt;<br> 表达式输出，向页面输出内容<br> 相当于 out.print(“内容”)  会被翻译成service方法内部</li><li>&lt;%！java代码%&gt;<br>定义常量<br>会被翻译成service的out.print(“内容”）</li></ol><h1 id="jsp注释"><a href="#jsp注释" class="headerlink" title="jsp注释"></a>jsp注释</h1><table><thead><tr><th style="text-align:center">jsp</th><th style="text-align:center">可见范围</th></tr></thead><tbody><tr><td style="text-align:center">&lt;!–html注释–&gt;</td><td style="text-align:center">jsp源码   servlet   html页面</td></tr><tr><td style="text-align:center">//单行注释</td><td style="text-align:center">jsp源码  servlet</td></tr><tr><td style="text-align:center">/*多行注释*/</td><td style="text-align:center">jsp源码  servlet</td></tr><tr><td style="text-align:center">&lt;%jsp注释%&gt;</td><td style="text-align:center">jsp源码</td></tr></tbody></table><h1 id="jsp指令"><a href="#jsp指令" class="headerlink" title="jsp指令"></a>jsp指令</h1><pre><code>指导jsp翻译和运行的命令 </code></pre><h1 id="jsp包括三大指令："><a href="#jsp包括三大指令：" class="headerlink" title="jsp包括三大指令："></a>jsp包括三大指令：</h1><h2 id="page-—属性"><a href="#page-—属性" class="headerlink" title="page  —属性"></a>page  —属性</h2><pre><code>属性最多的指令 根据不同的属性指导整个页面的特性</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@page 属性一：&quot;属性值一&quot; 属性二：&quot;属性值二&quot; 属性三：&quot;属性值三&quot;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%</span><br></pre></td></tr></table></figure><ol><li>language<br>jsp脚本可以嵌入的语言种类</li><li>contentType（MIME类型）<br>response.setContentType(“text/html”;charset=UTF-8)</li><li>charset<br> 编码格式</li><li>pageEncoding<br>jsp文件的编码</li><li>import<br>导入java包 </li><li>session<br> 是否jsp在翻译时自动创建session</li><li>errorPage<br> 当前页面错误跳转</li><li>iserrorPage<br> true/false  处理错误的页面</li></ol><h2 id="include指令-静态包含"><a href="#include指令-静态包含" class="headerlink" title="include指令  (静态包含)"></a>include指令  (静态包含)</h2><pre><code>页面包含指令可以将一个jsp页面包含到另一个jsp页面中格式: &lt;%@include file=&quot;被包含的文件地址&quot;%&gt;</code></pre><h2 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h2><pre><code>在jsp页面引入标签库(jstl标签库,struts2标签库)</code></pre><blockquote><p>&lt;%@ taglib uri=” “  prefix = “c”  %&gt;<br>prefix表示前缀</p></blockquote><h2 id="jsp内置对象-（9个）"><a href="#jsp内置对象-（9个）" class="headerlink" title="jsp内置对象  （9个）"></a>jsp内置对象  （9个）</h2><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">对象</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">pageContext</td><td style="text-align:center">Javax.servlet.jsp.PageContext</td><td style="text-align:center">Jsp的页面容器</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">request</td><td style="text-align:center">Javax.servlet.http.HttpServletRequest</td><td style="text-align:center">表示请求信息，可以通过此对象获取请求信息</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">response</td><td style="text-align:center">Javax.servlet.http.HttpServletResponse</td><td style="text-align:center">表示服务器端对客户端请求的响应</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">session</td><td style="text-align:center">Javax.servlet.http.HttpSession</td><td style="text-align:center">用来保存每一个用户的信息，相当于每一次浏览器访问服务器会话的信息</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">application</td><td style="text-align:center">Javax.servlet.ServletContext</td><td style="text-align:center">表示的是服务器的上下文 整个web应用，所有用户的共享信息</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">config</td><td style="text-align:center">Javax.servlet.ServletConfig</td><td style="text-align:center">项目配置，可以通过此对象获取配置的初始化参数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">out</td><td style="text-align:center">Javax.servlet.jsp.JspWriter</td><td style="text-align:center">表示的是向页面的输出,out缓冲区默认为 8kb 可以设置成 0，代表关闭out缓冲区  内容直接输出</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">exception</td><td style="text-align:center">Java.lang.Throwable</td><td style="text-align:center">表示jsp发生异常的时候，所有的异常的信息，一般之后再将异常输出到页面的时候才用的上</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">page</td><td style="text-align:center">Java.lang.Object</td><td style="text-align:center">表示的是该页面的Servlet实例 当前jsp页面范围</td></tr></tbody></table><h2 id="属性范围"><a href="#属性范围" class="headerlink" title="属性范围"></a>属性范围</h2><p>属性范围，又称为会话跟踪技术，又称为域对象，在一个页面设置了属性，跳转到另外页面是否还能够取得之前页面设置的属性的问题。属性范围总共有四种： </p><table><thead><tr><th style="text-align:center">域</th><th style="text-align:center">名称</th><th style="text-align:center">作用域范围</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">page</td><td style="text-align:center">page域</td><td style="text-align:center">当前页面</td><td style="text-align:center">当前页面可用跳转到其他页面，获取不到之前页面设置的page域对象，使用pageContext对象进行设置和获取域对象</td></tr><tr><td style="text-align:center">request</td><td style="text-align:center">请求域</td><td style="text-align:center">一次请求当前页面，转发到其他的页面</td><td style="text-align:center">表示在一个页面设置了属性之后，当前页面可以获取到设置的属性，转发到其他的页面，也可以获取到之前页面设置的请求域中的内容，但是重定向之后获取不到，使用的是request对象进行设置或获取域对象的。</td></tr><tr><td style="text-align:center">session</td><td style="text-align:center">会话域</td><td style="text-align:center">当前页面，转发，重定向，一次会话</td><td style="text-align:center">表示在一个页面设置了属性之后，当前页面可以获取，转发或者重定向到其他页面，也可以获取到之前页面设置的session域中的内容，但是如果浏览器重启或者不是同一个浏览器，那么session域内容获取无效。</td></tr><tr><td style="text-align:center">application</td><td style="text-align:center">application域</td><td style="text-align:center">全局，整个web应用</td><td style="text-align:center">使用application设置的域对象内容，只要服务器不重启，在任何页面都可以后去的到，这种的域对象设置在服务器上面，使用application对象设置和获取域对象内容。</td></tr></tbody></table><h3 id="pageContext域对象"><a href="#pageContext域对象" class="headerlink" title="pageContext域对象"></a>pageContext域对象</h3><p>pageContext对象是用来设置、获取和移除page域对象信息的，但是在pageContext中还有另外的三个方法可以操作域对象信息：  </p><blockquote><p>public abstract void removeAttribute(String name, int scope)<br>表示根据域对象名称和范围移除指定的域对象的信息，可以删除四种域对象的任意一种域对象信息<br>public abstract Object getAttribute(String name, int scope)<br>表示根据域对象名称和范围获取指定的域对象的信息，可以获取四种域对象的任意一种域对象信息<br>public abstract void setAttribute(String name,  Object value,  int scope)<br>表示设置域对象信息，可以设置四种范围域对象信息的任意的一种。  </p><ul><li>注意<br>以上的三个方法可以传递的参数都是整形的，在PageContex类中已有定义：  </li></ul><ol><li>public static final int APPLICATION_SCOPE ： application范围</li><li>public static final int PAGE_SCOPE：page范围</li><li>public static final int REQUEST_SCOPE：request范围</li><li>public static final int SESSION_SCOPE：session范围</li></ol></blockquote><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><blockquote><p>public abstract Object getAttribute(String name) 通过属性名称获取属性值<br>public abstract void setAttribute(String name, Object value)  设置属性名称和对应的属性值<br>public abstract void removeAttribute(String name)  通过属性名称移除属性  </p></blockquote><h1 id="jsp标签-动作"><a href="#jsp标签-动作" class="headerlink" title="jsp标签  动作"></a>jsp标签  动作</h1><h2 id="页面包含"><a href="#页面包含" class="headerlink" title="页面包含"></a>页面包含</h2><pre><code>动态包含  &lt;jsp:include page=&quot;被包含的页面&quot;/&gt;  形成两个class文件</code></pre><h2 id="请求转发："><a href="#请求转发：" class="headerlink" title="请求转发："></a>请求转发：</h2><pre><code>&lt;jsp:forword page =&quot;要转发的资源&quot;/&gt;</code></pre><p>静态包含和动态包含的区别</p><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">指令</th><th style="text-align:center">编译</th></tr></thead><tbody><tr><td style="text-align:center">静态包含：</td><td style="text-align:center">&lt;%@ include file =” “ %&gt;</td><td style="text-align:center">编译成一个class文件</td></tr><tr><td style="text-align:center">动态包含：</td><td style="text-align:center">&lt;jsp:include page=” “&gt;</td><td style="text-align:center">编译成两个class文件</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jsp&quot;&gt;&lt;a href=&quot;#jsp&quot; class=&quot;headerlink&quot; title=&quot;jsp&quot;&gt;&lt;/a&gt;jsp&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;java Server Page
jsp本质就是servlet   
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;js
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
      <category term="jsp" scheme="https://Cool-Loong.github.io/categories/java/jsp/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="jsp" scheme="https://Cool-Loong.github.io/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>初识mysql</title>
    <link href="https://Cool-Loong.github.io/2019/08/27/%E5%88%9D%E5%A7%8Bmysql/"/>
    <id>https://Cool-Loong.github.io/2019/08/27/初始mysql/</id>
    <published>2019-08-27T06:29:30.000Z</published>
    <updated>2019-09-04T03:03:39.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据库概述"><a href="#MySQL数据库概述" class="headerlink" title="MySQL数据库概述"></a>MySQL数据库概述</h1><h2 id="数据库存储方式"><a href="#数据库存储方式" class="headerlink" title="数据库存储方式"></a>数据库存储方式</h2><ol><li>人工存储</li><li>文件系统阶段</li><li>数据库系统阶段  </li></ol><h2 id="数据库SQL语言"><a href="#数据库SQL语言" class="headerlink" title="数据库SQL语言"></a>数据库SQL语言</h2><ul><li>SQL(Structured Query Language) 结构化查询语言，数据库管理系统通过SQL语言来管理数据库中的数据  </li><li>SQL语言分为三个部分:  <ul><li>DDL 数据定义语言(definition)<br>  create table</li><li>DMl 数据操作语言(manipulation)<br>  select insert update delect table</li><li>DCL 数据控制语言(control)<br>  grant revoke</li></ul></li></ul><h2 id="为什么使用MySQL"><a href="#为什么使用MySQL" class="headerlink" title="为什么使用MySQL"></a>为什么使用MySQL</h2><pre><code>开放源代码的数据mysql的跨平台性价格优势功能强大使用方便</code></pre><h1 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><pre><code>tinyint(4)  smallint(6)  mediumint(9)  int(11)  bingint(20)  </code></pre><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><pre><code>float  double  decimal(m,d)  m代表总长度 d代表小数点后精确到d位</code></pre><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><pre><code>year 年   date 日期   time 时间   格式为：hh:mm:ssdatetime 日期时间  timestamp 时间（时区）,范围小，支持时区  datetime 最通用，year，date,time可以省略一些空间  </code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><pre><code>char(m)  指定长度的字符串varchar(m) 不定长度的字符串tinytext  text    文本mediumtextlongtext</code></pre><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><pre><code>binary（m）varbinary(m)bit(m)tinyblobblob    字节类型 适合存图片mediumbloblongblob</code></pre><h1 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h1><pre><code>登录 mysql -h localhost -uroot -proot</code></pre><ul><li>显示 创建  删除数据库<br>  show databases;<br>  create database xxx;<br>  drop database xxx;<br>  use db_name  使用某个数据库<br>  drop 删除数据库</li><li>新建用户<br>  create user name identified by “ssapdrow”</li><li>数据库存储引擎<br>  show variables like “%engine%”  </li></ul><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><ul><li><p>create database 数据库名;<br>  create database day14;</p></li><li><p>创建数据库时指定字符集<br>  create database day14  character set gbk;  </p></li><li>show databases<br>  查看当前所有数据库  </li><li>use employees<br>  使用一个数据库</li></ul><h2 id="查看服务器上所有的数据库"><a href="#查看服务器上所有的数据库" class="headerlink" title="查看服务器上所有的数据库"></a>查看服务器上所有的数据库</h2><pre><code>show databases;</code></pre><h2 id="查看创建数据库的代码"><a href="#查看创建数据库的代码" class="headerlink" title="查看创建数据库的代码"></a>查看创建数据库的代码</h2><pre><code>show create database 数据库名;show create database day13; </code></pre><h2 id="修改某个数据库的编码"><a href="#修改某个数据库的编码" class="headerlink" title="修改某个数据库的编码"></a>修改某个数据库的编码</h2><pre><code>alter database 数据库名  character set 字符编码  COLLATE 字符集的校验规则;alter database day13  character set utf8 collate utf8_general_ci;</code></pre><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><pre><code>drop database 数据库名;drop database day13;</code></pre><h2 id="使用某个数据库-将来建表都放在这个库中"><a href="#使用某个数据库-将来建表都放在这个库中" class="headerlink" title="使用某个数据库  (将来建表都放在这个库中)"></a>使用某个数据库  (将来建表都放在这个库中)</h2><pre><code>use 数据库名;use day13;</code></pre><h1 id="操作数据表"><a href="#操作数据表" class="headerlink" title="操作数据表"></a>操作数据表</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">    属性名 数据类型[完整性约束]，</span><br><span class="line">    属性名 数据类型[完整性约束]，</span><br><span class="line">    。。。</span><br><span class="line">    属性名 数据类型</span><br><span class="line">);</span><br><span class="line">可以增加主键 和自增长</span><br><span class="line">primary key  auto_increment(int类型，主键)</span><br></pre></td></tr></table></figure></code></pre><ul><li>显示当前数据库下所有数据表<br>  show tables</li><li>查看创建表的代码<br>  show create table 表名;</li><li>查看表的字段<br>  desc 表名  (以列表的形式显示出结果)    </li><li>完整性约束<br>  primary key 主键<br>  foreign key 外键<br>  not null 不能为空<br>  unique  唯一索引<br>  auto_increment 自动增加<br>  default 默认值 <h3 id="设置表的主键"><a href="#设置表的主键" class="headerlink" title="设置表的主键"></a>设置表的主键</h3></li><li>单字段主键<br>  属性名 数据类型 primary key<br>  stu_id int primary key,</li><li><p>多字段主键<br>  primary key(属性1，属性2…属性n)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student(</span><br><span class="line">    stu_id INT,     </span><br><span class="line">    course_id INT,     </span><br><span class="line">    grade FLOAT,     </span><br><span class="line">    PRIMARY KEY(stu_id, course_id)     </span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>创建表之后添加主键<br>  alter table 表名 add primary key (列名)  </p><h3 id="设置表的外键"><a href="#设置表的外键" class="headerlink" title="设置表的外键"></a>设置表的外键</h3></li><li><p>在创建表的时候添加  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONSTRAINT 外键别名 FOREIGN KEY (属性1.1, 属性1.2,…, 属性1.n)  REFERENCES 表名(属性 2.1, 属性2.2,…, 属性2.n)</span><br></pre></td></tr></table></figure></li><li><p>在创建表之后添加  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add constarint FK_employee_dept_id foreign key(dept_id) references departement(id)</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用子查询创建表"><a href="#使用子查询创建表" class="headerlink" title="使用子查询创建表"></a>使用子查询创建表</h3><pre><code>create table emp1 as select * from employees;</code></pre><h3 id="设置表的非空约束"><a href="#设置表的非空约束" class="headerlink" title="设置表的非空约束"></a>设置表的非空约束</h3><pre><code>属性名 数据类型 not null</code></pre><h3 id="设置表的唯一性约束"><a href="#设置表的唯一性约束" class="headerlink" title="设置表的唯一性约束"></a>设置表的唯一性约束</h3><pre><code>属性名 数据类型 unique  </code></pre><h3 id="设置表的属性值自动增加"><a href="#设置表的属性值自动增加" class="headerlink" title="设置表的属性值自动增加"></a>设置表的属性值自动增加</h3><pre><code>属性名 数据类型 AUTO_INCREMENT</code></pre><h3 id="设置表的属性的默认值"><a href="#设置表的属性的默认值" class="headerlink" title="设置表的属性的默认值"></a>设置表的属性的默认值</h3><pre><code>属性名 数据类型 default 默认值</code></pre><h2 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h2><h3 id="查看表基本结构"><a href="#查看表基本结构" class="headerlink" title="查看表基本结构"></a>查看表基本结构</h3><pre><code>DESC 表名  </code></pre><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><pre><code>ALTER TABLE 旧表名 RENAME [TO] 新表名; </code></pre><h3 id="字段的数据类型"><a href="#字段的数据类型" class="headerlink" title="字段的数据类型"></a>字段的数据类型</h3><ol><li>修改字段的数据类型 (列)<br> alter table 表名 modify 属性名 数据类型;<br> alter table user modify name varchar(30);  </li><li>增加字段及数据类型 (列)<br>alter table 表名 add 属性名1 数据类型 [完整性约束] [first|after 属性2]  </li><li>删除字段  (列)<br> alter table 表名 drop 属性名；</li><li>改变字段数据类型  (列)<br> alter table 表名 change 旧属性名 新属性名 新数据类型  </li><li>修改表的字符集<br> alter table 表名 character set 字符集编码  </li><li>添加一列<br> alter table 表名 add 列名  类型</li><li>删除表的外键约束<br> alter table 表名 drop foreign key 外键别名;</li><li>删除表<br> drop table 表名;<br> 当需要删除被其他表关联的表时，需要先删除外键然后在删除该表</li></ol><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><ul><li>所有字段插入数据<br>  1、INSERT语句中不指定具体的字段名<br>  insert into 表名 values (值1,值2…值 n)<br>  2、INSERT语句中列出所有字段<br>  insert into 表名 (属性1,属性 2…属性n) values (值1,值2…值n) </li><li>插入指定字段<br>  insert into 表名 (属性1，属性2，属性3) value (值1，值2，值3)  </li><li>同时插入多条数据   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名  </span><br><span class="line">(属性1，属性2，属性3) values (值1，值2，值3)，  </span><br><span class="line">(属性1，属性2，属性3) values (值1，值2，值3)，  </span><br><span class="line">(属性1，属性2，属性3) values (值1，值2，值3);</span><br></pre></td></tr></table></figure></li></ul><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><pre><code>update 表名set 属性1 = 值1，属性2 = 值2，...where 条件表达式;</code></pre><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><pre><code>delete from 表名 [条件表达式];truncate table 表名 [条件表达式];</code></pre><ul><li>区别：  </li></ul><ol><li>truncate table 删除数据效率更高(先摧毁整个表结构，再重建表)</li><li>delete 删除所有记录时，一条一条往后删除</li><li>truncate table只能删除所有</li><li>delete可以选择性的删除部分记录</li></ol><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><h3 id="基本查询语句"><a href="#基本查询语句" class="headerlink" title="基本查询语句"></a>基本查询语句</h3><pre><code>select 属性列表         from 表名和视图列表[where 条件表达式1]     [group by 属性名 1 [having 条件表达式2]][order dy 属性名2[asc|desc]]limit 限制查询的个数(分页)</code></pre><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><ul><li>查询所有列  <pre><code>select * from 表名</code></pre></li><li>查询指定字段<br>  select 列名1，列名2  from 表名</li><li>查询指定记录<br>  where 条件表达式<br>  =,&gt;,&lt;,!组合查询<br>  [not] between and （不）在…之间<br>  [not] in 在… 里面<br>  [not] like  %(匹配零个或多个) _(匹配一个)<br>  is [not] null<br>  and ,or    条件查询<br>  select distinct 属性名    去除重复<br>  order by 属性名 [asc|desc]    排序<br>  GROUP BY, GROUP_CONTACT()凼数非常好用<br>  SELECT sex, GROUP_CONTACT(name) FROM employee GROUP BY sex;<br>  GROUP BY不WITH ROLLUP一起使用，多一行，加统计<br>  SELECT sex COUNT(sex) FROM employee GROUP BY sex WITH ROLLUP;<br>  LIMIT [刜始位置,] 记录数 </li><li>mysql 中+的作用<br>  运算符<br>  如果两个操作数都为数值型，则做加法运算<br>  如果一方为字符串，将字符串转化为数值型  <ul><li>如果转换成功，则继续做加法运算  </li><li>如果转换失败，则将字符型数值转化为0<h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3>count(),avg(),max(),min(),sum()<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3></li></ul></li><li>内连接<br>  select a.*,b.* from a,b where a.xid = b.id<br>  或者 select a.*,b.* from a inner  join b on a.xid = b.xid</li><li>外连接<br>  select 属性名列表 from 表名1 left|right join 表名2 on 表名1.属性1 = 表名2.属性2;  <blockquote><p>左外连接 left join  左表全记录，右表符合条件<br>  右外连接 right join 由表全记录 左表符合条件 </p></blockquote><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3>  把一个查询的结果在另一个查询中使用就叫子查询</li><li>in  or not in</li><li>exists or not exists  (不)存在  子查询返回真假值（true|false）</li><li>any 任意一个值</li><li><p>all 满足所有条件</p><h3 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h3><p>  select 语句1</p><pre><code>union | union ALL</code></pre><p>  select 语句2<br>  …<br>  union 所有查询结果合并到一起，去掉重复项<br>  union ALL 简单合并</p><h3 id="为表和字段取别名"><a href="#为表和字段取别名" class="headerlink" title="为表和字段取别名"></a>为表和字段取别名</h3><p>  表名 表的别名<br>  属性名  [as]  属性的别名  </p><h3 id="使用正则表达式查询"><a href="#使用正则表达式查询" class="headerlink" title="使用正则表达式查询"></a>使用正则表达式查询</h3><p>  属性名 regexp “匹配方式”  </p><p>  ^  字符串开始<br>  $   字符串结束<br>  .   任意一个字符 包括回车和换行<br>  [字符集合]  任意一个字符<br>  s1|s2|s3   集合中的任意一个</p><ul><li>匹配多个</li></ul><ul><li><p>匹配一个或者多个<br>字符串{n}    字符串出现的次数为n<br>字符串{m,n}  字符串出现至少m次，至多n次</p><p>select * from student where sname regexp ‘ab{1,3}’</p></li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>算术函数<br>  abs()  取绝对值<br>  mod()   取余<br>  sum()<br>  avg()<br>  max()<br>  min()<br>  ceil()  向上取整<br>  floor() 向下取整<br>  truncate() 截取多少位数字<br>  round() 四舍五入为指定小数位数  <pre><code>需要有两个参数      * 字段名称      * 小数位数</code></pre></li><li>字符串函数<br>  concat()   字符串拼接<br>  length()    字段长度   汉字三个字符<br>  char_length() 字段长度 汉字一个字符<br>  lower() 将字符串中的字符转化为小写<br>  upper() 将字符串中的字符转化位大写<br>  replace(字段名，需要替换的字符串，替换字符串对象)   替换函数<br>  substr(字段名，开始位置，长度) 截取字符串<br>  instr() 获取指定字符串的下标<br>  注意：mysql中下标从1开始  </li><li>日期函数<br>  now()系统现在的时间<br>  current_date()  系统当前时间 YYYY：MM:DD<br>  current_time() 系统当前时间 hh:mm:ss<br>  current_timestamp() 系统当前时间<br>  extract() 年月日<br>  date() 日期<br>  year() 年份<br>  month() 月份<br>  day()  天数<br>  hour()  小时<br>  minute() 分钟<br>  second() 秒  </li><li>条件判断函数<br>  if(expr ,v1,v2)<br>  ifnull(v1,v2)<br>  如果不是NULL，则返回第一个参数。 否则，IFNULL函数返回第二个参数。</li><li>统计函数<br>  count()计数<br>  sum()总和<br>  max()最大值<br>  min()最小值<br>  avg()平均值  </li></ul><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><blockquote><p>Transaction Control Language 事务控制语言<br>事务：<br>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p><ul><li>事务的特性：<br>  <em>ACID</em></li></ul><ol><li>原子性：<br> 一个事务不可再分割，要么都执行要么都不执行</li><li>一致性：<br> 一个事务执行会使数据从一个一致状态切换到另外一个一致状态</li><li>隔离性：<br> 一个事务的执行不受其他事务的干扰</li><li>持久性：<br> 一个事务一旦提交，则会永久的改变数据库的数据.</li></ol></blockquote><h3 id="事务的创建"><a href="#事务的创建" class="headerlink" title="事务的创建"></a>事务的创建</h3><h4 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h4><p>事务没有明显的开启和结束的标记<br>比如insert、update、delete语句<br>delete from 表 where id =1;  </p><h4 id="显式事务："><a href="#显式事务：" class="headerlink" title="显式事务："></a>显式事务：</h4><p>事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用<br>set autocommit=0;  </p><ol><li>开启事务<br>set autocommit=0;<br>start transaction;可选的  </li><li><p>编写事务中的sql语句(select insert update delete)<br>语句1;<br>语句2;<br>…  </p></li><li><p>结束事务<br> commit;提交事务<br> rollback;回滚事务<br> savepoint 节点名;设置保存点</p></li><li><p>事务的隔离级别：</p></li></ol><table><thead><tr><th style="text-align:center">事物</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">read uncommitted</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">read committed</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">repeatable read</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">serializable</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><blockquote><p>mysql中默认 第三个隔离级别 repeatable read<br>oracle中默认第二个隔离级别 read committed</p><ul><li>查看隔离级别<br>select @@tx_isolation;  </li><li>设置隔离级别<br>set session|global transaction isolation level 隔离级别;  </li></ul></blockquote><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li><p>演示事务的使用步骤  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#开启事务</span><br><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">#编写一组事务的语句</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&apos;张无忌&apos;;</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&apos;赵敏&apos;;</span><br><span class="line"></span><br><span class="line">#结束事务</span><br><span class="line">ROLLBACK;</span><br><span class="line">#commit;</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure></li><li><p>演示事务对于delete和truncate的处理的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit=0;  </span><br><span class="line">START TRANSACTION;  </span><br><span class="line"></span><br><span class="line">DELETE FROM account;  </span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure></li><li><p>演示savepoint 的使用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account WHERE id=25;</span><br><span class="line">SAVEPOINT a;#设置保存点</span><br><span class="line">DELETE FROM account WHERE id=28;</span><br><span class="line">ROLLBACK TO a;#回滚到保存点</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure></li></ol><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>含义：虚拟表，和普通表一样使用<br>mysql5.1版本出现的新特性，是通过表动态生成的数据  </p><p>比如：舞蹈班和普通班级的对比</p><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">创建语法的关键字</th><th style="text-align:center">是否实际占用物理空间</th><th style="text-align:center">使用</th></tr></thead><tbody><tr><td style="text-align:center">视图</td><td style="text-align:center">create view</td><td style="text-align:center">只是保存了sql逻辑</td><td style="text-align:center">增删改查，只是一般不能增删改</td></tr><tr><td style="text-align:center">表</td><td style="text-align:center">create table</td><td style="text-align:center">保存了数据</td><td style="text-align:center">增删改查</td></tr></tbody></table><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><pre><code>语法：create view 视图名as查询语句;</code></pre><ul><li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建</span><br><span class="line">CREATE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM myv2 ORDER BY ag LIMIT 1;</span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">SELECT d.*,m.ag</span><br><span class="line">FROM myv3 m</span><br><span class="line">JOIN departments d</span><br><span class="line">ON m.`department_id`=d.`department_id`;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图的修改"><a href="#视图的修改" class="headerlink" title="视图的修改"></a>视图的修改</h3><ol><li>方式一:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create or replace view  视图名</span><br><span class="line">as</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li></ol><ul><li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM myv3 </span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT AVG(salary),job_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY job_id;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>方式二  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">alter view 视图名</span><br><span class="line">as </span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure></li></ol><ul><li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ALTER VIEW myv3</span><br><span class="line">AS</span><br><span class="line">SELECT * FROM employees;</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><blockquote><p>语法：drop view 视图名,视图名,…;<br>DROP VIEW emp_v1,emp_v2,myv3;</p></blockquote><h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><blockquote><p>DESC myv3;<br>SHOW CREATE VIEW myv3;</p></blockquote><h3 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email,salary*12*(1+IFNULL(commission_pct,0)) &quot;annual salary&quot;</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line">CREATE OR REPLACE VIEW myv1</span><br><span class="line">AS</span><br><span class="line">SELECT last_name,email</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure><ul><li>注意<br>具备以下特点的视图不允许更新  </li></ul><ol><li>包含以下关键字的sql语句：<br>分组函数、distinct、group  by、having、union或者union all</li><li>常量视图</li><li>select中包含子查询</li><li>join</li><li>from一个不能更新的视图</li><li>where子句的子查询引用了from子句中的表</li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><pre><code>变量由系统定义，不是用户定义，属于服务器层面</code></pre><ol><li>查看所有系统变量<br> show global | session variables;</li><li>查看满足条件的部分系统变量<br> show global | session variables like ‘%char%’;</li><li>查看指定的系统变量的值<br> select @@global | session 系统变量名；</li><li>为某个系统变量赋值<ul><li>方式一<br>set gobal | session 系统变量名 = 值</li><li>方式二<br>set @@global | session 系统变量名=值;</li></ul></li></ol><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><pre><code>全局变量需要添加global关键字，会话变量需要添加session关键字，如果不写，默认会话级别作用域：针对于所有会话（连接）有效，但不能跨重启</code></pre><ul><li>查看所有全局变量<br>  SHOW GLOBAL VARIABLES;</li><li>查看满足条件的部分系统变量<br>SHOW GLOBAL VARIABLES LIKE ‘%char%’;</li><li>查看指定的系统变量的值<br>SELECT @@global.autocommit;</li><li>为某个系统变量赋值  <ol><li>SET @@global.autocommit=0;  </li><li>SET GLOBAL autocommit=0;  </li></ol></li></ul><h4 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h4><pre><code>作用域：针对于当前会话（连接）有效</code></pre><ul><li>查看所有会话变量<br>  SHOW SESSION VARIABLES;</li><li>查看满足条件的部分会话变量<br>SHOW SESSION VARIABLES LIKE ‘%char%’;</li><li>查看指定的会话变量的值  <ol><li>SELECT @@autocommit;</li><li>SELECT @@session.tx_isolation;</li></ol></li><li>为某个会话变量赋值  <ol><li>SET @@session.tx_isolation=’read-uncommitted’;</li><li>SET SESSION tx_isolation=’read-committed’;</li></ol></li></ul><h3 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h3><pre><code>变量由用户自定义，而不是系统提供的使用步骤：1、声明2、赋值3、使用（查看、比较、运算等）</code></pre><h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><pre><code>作用域：针对于当前会话（连接）有效，作用域同于会话变量</code></pre><blockquote><p>赋值操作符：=或:=</p><ul><li>声明并初始化<br>SET @变量名=值;<br>SET @变量名:=值;<br>SELECT @变量名:=值;  </li></ul></blockquote><ul><li>赋值（更新变量的值）</li></ul><ol><li>方式一：<br> SET @变量名=值;<br> SET @变量名:=值;<br> SELECT @变量名:=值;  </li><li>方式二:<br> SELECT 字段 INTO @变量名<br> FROM 表;  </li><li>使用（查看变量的值）<br> SELECT @变量名;  <h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4> 作用域：仅仅在定义它的begin end块中有效<br> 应用在 begin end中的第一句话</li></ol><ul><li>声明<br>  DECLARE 变量名 类型;<br>  DECLARE 变量名 类型 【DEFAULT 值】;</li></ul><ul><li>赋值（更新变量的值）</li></ul><ol><li>方式一：<br> SET 局部变量名=值;<br> SET 局部变量名:=值;<br> SELECT 局部变量名:=值;  </li><li>方式二：<br> SELECT 字段 INTO 具备变量名<br> FROM 表;  </li><li>使用（查看变量的值）<br> SELECT 局部变量名;</li></ol><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><ul><li><p>案例1：声明两个变量，求和并打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#用户变量</span><br><span class="line">SET @m=1;</span><br><span class="line">SET @n=1;</span><br><span class="line">SET @sum=@m+@n;</span><br><span class="line">SELECT @sum;</span><br><span class="line"></span><br><span class="line">#局部变量</span><br><span class="line">DECLARE m INT DEFAULT 1;</span><br><span class="line">DECLARE n INT DEFAULT 1;</span><br><span class="line">DECLARE SUM INT;</span><br><span class="line">SET SUM=m+n;</span><br><span class="line">SELECT SUM;</span><br></pre></td></tr></table></figure></li><li><p>用户变量和局部变量的对比    </p></li></ul><table><thead><tr><th style="text-align:center">名字</th><th style="text-align:center">作用域</th><th style="text-align:center">定义位置</th><th style="text-align:center">语法</th></tr></thead><tbody><tr><td style="text-align:center">用户变量</td><td style="text-align:center">当前会话</td><td style="text-align:center">会话的任何地方</td><td style="text-align:center">加@符号，不用指定类型</td></tr><tr><td style="text-align:center">局部变量</td><td style="text-align:center">定义它的BEGIN END中</td><td style="text-align:center">BEGIN END的第一句话</td><td style="text-align:center">一般不用加@,需要指定类型</td></tr></tbody></table><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><pre><code>存储过程和函数：类似于java中的方法好处：1、提高代码的重用性2、简化操作</code></pre><blockquote><p>存储过程<br>含义：一组预先编译好的SQL语句的集合，理解成批处理语句<br>1、提高代码的重用性<br>2、简化操作<br>3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率  </p></blockquote><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><pre><code>CREATE PROCEDURE 存储过程名(参数列表)BEGIN    存储过程体（一组合法的SQL语句）END  </code></pre><ul><li>注意  </li></ul><ol><li>参数列表包含三部分<br>参数模式 参数名 参数类型<br>eg: in stuname varchar(20)<br>参数模式:<br>in:  该参数可以作为输入，也可以作为该参数需要调用方传入值<br>out：作为输出，返回值<br>inout: 既可以作为输入也可以作为输出 ，也就是该参数既需要传入值，又可以返回值  </li><li>如果存储过程体仅仅只有一句话，begin end可以省略</li><li>存储过程体中的每条sql语句的结尾要求必须加分号。</li><li>存储过程的结尾可以使用 delimiter 重新设置<br>语法：<br>delimiter 结束标记</li></ol><h3 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h3><pre><code>CALL 存储过程名(实参列表);</code></pre><ol><li><p>空参列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM admin;</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp1()</span><br><span class="line">BEGIN</span><br><span class="line">INSERT INTO admin(username,`password`) </span><br><span class="line">VALUES(&apos;john1&apos;,&apos;0000&apos;),(&apos;lily&apos;,&apos;0000&apos;),  </span><br><span class="line">    (&apos;rose&apos;,&apos;0000&apos;),(&apos;jack&apos;,&apos;0000&apos;),  </span><br><span class="line">    (&apos;tom&apos;,&apos;0000&apos;);</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp1();</span><br></pre></td></tr></table></figure></li><li><p>创建带in模式参数的存储过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">创建存储过程实现，用户是否登录成功</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE result INT DEFAULT 0;#声明并初始化</span><br><span class="line">SELECT COUNT(*) INTO result#赋值</span><br><span class="line">FROM admin</span><br><span class="line">WHERE admin.username = username</span><br><span class="line">AND admin.password = PASSWORD;</span><br><span class="line">SELECT IF(result&gt;0,&apos;成功&apos;,&apos;失败&apos;);#使用</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp3(&apos;张飞&apos;,&apos;8888&apos;)</span><br></pre></td></tr></table></figure></li><li><p>创建out 模式参数的存储过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">根据输入的女神名，返回对应的男神名和魅力值</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) </span><br><span class="line">BEGIN</span><br><span class="line">SELECT boys.boyname ,boys.usercp INTO boyname,usercp</span><br><span class="line">FROM boys </span><br><span class="line">RIGHT JOIN</span><br><span class="line">beauty b ON b.boyfriend_id = boys.id</span><br><span class="line">WHERE b.name=beautyName ;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">CALL myp7(&apos;小昭&apos;,@name,@cp);</span><br><span class="line">SELECT @name,@cp;</span><br></pre></td></tr></table></figure></li><li><p>创建带inout模式参数的存储过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">传入a和b两个值，最终a和b都翻倍并返回</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)</span><br><span class="line">BEGIN</span><br><span class="line">SET a=a*2;</span><br><span class="line">SET b=b*2;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">SET @m=10;</span><br><span class="line">SET @n=20;</span><br><span class="line">CALL myp8(@m,@n);</span><br><span class="line">SELECT @m,@n;</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><pre><code>语法：drop procedure 存储过程名DROP PROCEDURE p1;DROP PROCEDURE p2,p3; </code></pre><h3 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h3><pre><code>DESC myp2;×SHOW CREATE PROCEDURE  myp2;</code></pre><h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><pre><code>含义：一组预先编译好的SQL语句的集合，理解成批处理语句 1、提高代码的重用性2、简化操作3、减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率区别：存储过程：可以有0个返回，也可以有多个返回，适合做批量插入、批量更新函数：有且仅有1 个返回，适合做处理数据后返回一个结果</code></pre><h3 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h3><pre><code>CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型BEGIN    函数体END</code></pre><ul><li>注意<blockquote><ol><li>参数列表包含两部分 参数名 参数类型</li><li>函数体:肯定会有return语句，如果没有会报错</li><li>函数体中仅有一句话，则可以省略begin end</li><li>使用 delimiter语句设置结束标记</li></ol></blockquote></li></ul><h3 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h3><pre><code>select 函数名（参数列表）</code></pre><ol><li><p>无参有返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#案例：返回公司的员工个数</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION myf1() RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">DECLARE c INT DEFAULT 0;#定义局部变量</span><br><span class="line">SELECT COUNT(*) INTO c#赋值</span><br><span class="line">FROM employees;</span><br><span class="line">RETURN c;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf1()</span><br></pre></td></tr></table></figure></li><li><p>有参有返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#案例1：根据员工名，返回它的工资</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION myf2(empName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">SET @sal=0;#定义用户变量 </span><br><span class="line">SELECT salary INTO @sal   #赋值</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = empName;</span><br><span class="line"></span><br><span class="line">RETURN @sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf2(&apos;k_ing&apos;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="查看函数"><a href="#查看函数" class="headerlink" title="查看函数"></a>查看函数</h3><pre><code>show create function 函数名;eg: show create function find_boys;</code></pre><h3 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h3><pre><code>drop function 函数名;drop function find_boys;</code></pre><ul><li>例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建函数，实现传入两个float，返回二者之和</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION test_fun1(num1 FLOAT,num2 FLOAT) RETURNS FLOAT</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE SUM FLOAT DEFAULT 0;</span><br><span class="line">SET SUM=num1+num2;</span><br><span class="line">RETURN SUM;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT test_fun1(1,2)</span><br></pre></td></tr></table></figure></li></ul><h2 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h2><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：if(条件,值1，值2)</span><br><span class="line">功能：实现双分支</span><br></pre></td></tr></table></figure><blockquote><p>应用在begin end中或外面</p></blockquote><h4 id="case结构"><a href="#case结构" class="headerlink" title="case结构"></a>case结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法1：类似于switch</span><br><span class="line">case 变量或表达式</span><br><span class="line">when 值1 then 语句1;</span><br><span class="line">when 值2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法2：</span><br><span class="line">case </span><br><span class="line">when 条件1 then 语句1;</span><br><span class="line">when 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">else 语句n;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>可以应用在begin end中或者外面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#案例：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION test_case(score FLOAT) RETURNS CHAR</span><br><span class="line">BEGIN </span><br><span class="line">DECLARE ch CHAR DEFAULT &apos;A&apos;;</span><br><span class="line"></span><br><span class="line">CASE </span><br><span class="line">WHEN score&gt;90 THEN SET ch=&apos;A&apos;;</span><br><span class="line">WHEN score&gt;80 THEN SET ch=&apos;B&apos;;</span><br><span class="line">WHEN score&gt;60 THEN SET ch=&apos;C&apos;;</span><br><span class="line">ELSE SET ch=&apos;D&apos;;</span><br><span class="line">END CASE;</span><br><span class="line">RETURN ch;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT test_case(56)</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="if结构"><a href="#if结构" class="headerlink" title="if结构"></a>if结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">elseif 条件2 then 语句2;</span><br><span class="line">....</span><br><span class="line">else 语句n;</span><br><span class="line">end if;</span><br><span class="line">功能：类似于多重if</span><br></pre></td></tr></table></figure><blockquote><p>只能应用在begin end中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">样例：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D  </span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE FUNCTION test_if(score FLOAT) RETURNS CHAR</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE ch CHAR DEFAULT &apos;A&apos;;</span><br><span class="line">IF score&gt;90 THEN SET ch=&apos;A&apos;;</span><br><span class="line">ELSEIF score&gt;80 THEN SET ch=&apos;B&apos;;</span><br><span class="line">ELSEIF score&gt;60 THEN SET ch=&apos;C&apos;;</span><br><span class="line">ELSE SET ch=&apos;D&apos;;</span><br><span class="line">END IF;</span><br><span class="line">RETURN ch;</span><br><span class="line">END $</span><br><span class="line">测试</span><br><span class="line">SELECT test_if(87);</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><pre><code>分类：     while  loop repeat循环控制：    iterate 类似于 continue 继续,结束本次循环，继续下一次    leave 类似于 break  跳出,结束当前所在的循环</code></pre><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><pre><code>语法：【标签:】while 循环条件 do    循环体;end while【 标签】;相当于while(循环条件){    循环体；}</code></pre><ol><li><p>没有添加循环控制语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录</span><br><span class="line">DROP PROCEDURE pro_while1;</span><br><span class="line">CREATE PROCEDURE pro_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">WHILE i&lt;=insertCount DO</span><br><span class="line">INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;Rose&apos;,i),&apos;666&apos;);</span><br><span class="line">SET i=i+1;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">CALL pro_while1(100)</span><br></pre></td></tr></table></figure></li><li><p>添加leave语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，如果次数&gt;20则停止</span><br><span class="line">TRUNCATE TABLE admin;</span><br><span class="line">DROP PROCEDURE test_while1</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">a:WHILE i&lt;=insertCount DO</span><br><span class="line">INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;xiaohua&apos;,i),&apos;0000&apos;);</span><br><span class="line">IF i&gt;=20 THEN LEAVE a;</span><br><span class="line">END IF;</span><br><span class="line">SET i=i+1;</span><br><span class="line">END WHILE a;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">CALL test_while1(100)</span><br></pre></td></tr></table></figure></li><li><p>添加iterate语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#案例：批量插入，根据次数插入到admin表中多条记录，只插入偶数次</span><br><span class="line">TRUNCATE TABLE admin$</span><br><span class="line">DROP PROCEDURE test_while1$</span><br><span class="line">CREATE PROCEDURE test_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">a:WHILE i&lt;=insertCount DO</span><br><span class="line">SET i=i+1;</span><br><span class="line">IF MOD(i,2)!=0 THEN ITERATE a;</span><br><span class="line">END IF;</span><br><span class="line"></span><br><span class="line">INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;xiaohua&apos;,i),&apos;0000&apos;);</span><br><span class="line"></span><br><span class="line">END WHILE a;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">CALL test_while1(100)</span><br></pre></td></tr></table></figure></li></ol><h4 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h4><pre><code>语法：【标签:】loop    循环体;end loop 【标签】;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">DROP PROCEDURE pro_loop$</span><br><span class="line">CREATE PROCEDURE pro_loop(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">a:LOOP </span><br><span class="line">SET i=i+1;</span><br><span class="line">IF i&gt;insertCount</span><br><span class="line">        THEN LEAVE a;</span><br><span class="line">END IF;</span><br><span class="line">INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;Rose&apos;,i),&apos;666&apos;);</span><br><span class="line">END LOOP a;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">CALL pro_loop(100);</span><br></pre></td></tr></table></figure><h4 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h4><pre><code>语法：【标签：】repeat    循环体;until 结束循环的条件end repeat 【标签】;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line">DROP PROCEDURE  IF EXISTS pro_repeat$</span><br><span class="line">CREATE PROCEDURE pro_repeat(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">a:REPEAT</span><br><span class="line">INSERT INTO admin(username,`password`) VALUES(CONCAT(&apos;loong&apos;,i),&apos;888&apos;);</span><br><span class="line">SET i = i+1;</span><br><span class="line">UNTIL i&gt;insertCount</span><br><span class="line">END REPEAT a;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">CALL pro_repeat(100);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL数据库概述&quot;&gt;&lt;a href=&quot;#MySQL数据库概述&quot; class=&quot;headerlink&quot; title=&quot;MySQL数据库概述&quot;&gt;&lt;/a&gt;MySQL数据库概述&lt;/h1&gt;&lt;h2 id=&quot;数据库存储方式&quot;&gt;&lt;a href=&quot;#数据库存储方式&quot; class
      
    
    </summary>
    
      <category term="MySQL" scheme="https://Cool-Loong.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://Cool-Loong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>java反射介绍</title>
    <link href="https://Cool-Loong.github.io/2019/07/16/java%E5%8F%8D%E5%B0%84%E4%BB%8B%E7%BB%8D/"/>
    <id>https://Cool-Loong.github.io/2019/07/16/java反射介绍/</id>
    <published>2019-07-16T07:07:41.000Z</published>
    <updated>2019-08-21T13:21:09.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反射概述"><a href="#反射概述" class="headerlink" title="反射概述"></a>反射概述</h3><h4 id="反射概述-1"><a href="#反射概述-1" class="headerlink" title="反射概述"></a>反射概述</h4><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意一个方法和属性；</li><li>这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li><li>要想解剖一个类,必须先要获取到该类的字节码文件对象。</li><li>而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象  </li></ul><h4 id="获取class文件对象的三种方式"><a href="#获取class文件对象的三种方式" class="headerlink" title="获取class文件对象的三种方式"></a>获取class文件对象的三种方式</h4><ul><li><strong>这三种方式为：</strong></li><li>a:Object类的getClass()方法</li><li>b:静态属性class</li><li><p>c:Class类中静态方法forName()</p></li><li><p><strong>第一种方法【Object类的getClass()方法】</strong></p><ul><li>1.在内存中新建一个Person的实例,对象p对这个内存地址进行引用</li><li>2.对象p调用getClass()返回对象p所对应的Class对</li><li>3.调用newInstance()方法让Class对象在内存中创建对应的实例,并且让p2引用实例的内存地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = new Person();</span><br><span class="line">Class&lt;?&gt; cls=p.getClass();</span><br><span class="line">Person p2=(Person)cls.newInstance();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>第二种方法【静态属性class】</strong></p><ul><li>1.获取指定类型的Class对象,这里是Person</li><li>2.调用newInstance()方法在让Class对象在内存中创建对应的实例,并且让p引用实例的内存地址<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls=Person.Class();</span><br><span class="line">Person p=(Person)cls.newInstance();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>第三种方法【Class类中静态方法forName()】</strong></p><ul><li>1.通过JVM查找并加载指定的类(上面的代码指定加载了com.fanshe包中的Person类)</li><li>2.调用newInstance()方法让加载完的类在内存中创建对应的实例,并把实例赋值给p</li><li>注意：如果找不到时，它会抛出 ClassNotFoundException 这个异常，这个很好理解，因为如果查找的类没有在 JVM 中加载的话，自然要告诉开发者。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls=Class.forName(&quot;com.yc.Person&quot;); //forName(包名.类名)</span><br><span class="line">Person p= (Person) cls.newInstance();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="通过反射获取无参构造方法并使用"><a href="#通过反射获取无参构造方法并使用" class="headerlink" title="通过反射获取无参构造方法并使用"></a>通过反射获取无参构造方法并使用</h4><ul><li>A:获取所有构造方法</li><li>public Constructor&lt;?&gt;[] getConstructors()</li><li>public Constructor&lt;?&gt;[] getDeclaredConstructors()</li><li>B:获取单个构造方法</li><li>public Constructor<t> getConstructor(Class&lt;?&gt;… parameterTypes)</t></li><li>public Constructor<t> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</t></li></ul><ul><li>方法关键字 </li><li>getDeclareMethods()     获取所有的方法</li><li>getReturnType()     获取方法的返回值类型</li><li>getParameterTypes()     获取方法的传入参数类型</li><li>getDeclareMethod(“方法名,参数类型.class,….”)     获得特定的方法</li><li>构造方法关键字 </li><li>getDeclaredConstructors()     获取所有的构造方法</li><li>getDeclaredConstructors(参数类型.class,….)     获取特定的构造方法</li><li>成员变量 </li><li>getDeclaredFields     获取所有成员变量</li><li>getDeclaredField(参数类型.class,….)     获取特定的成员变量</li><li>父类和父接口 </li><li>getSuperclass()     获取某类的父类</li><li>getInterfaces()     获取某类实现的接口</li></ul><h4 id="反射的定义"><a href="#反射的定义" class="headerlink" title="反射的定义"></a>反射的定义</h4><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制</li></ul><h4 id="反射的组成"><a href="#反射的组成" class="headerlink" title="反射的组成"></a>反射的组成</h4><ul><li>由于反射最终也必须有类参与，因此反射的组成一般有下面几个方面组成:<ul><li>1.java.lang.Class.java：类对象；</li><li>2.java.lang.reflect.Constructor.java：类的构造器对象；</li><li>3.java.lang.reflect.Method.java：类的方法对象；</li><li>4.java.lang.reflect.Field.java：类的属性对象；</li></ul></li><li>反射中类的加载过程<ul><li>根据虚拟机的工作原理,一般情况下，类需要经过:加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载这个过程，如果需要反射的类没有在内存中，那么首先会经过加载这个过程，并在在内存中生成一个class对象，有了这个class对象的引用，就可以发挥开发者的想象力，做自己想做的事情了。</li></ul></li></ul><h4 id="反射的作用有哪些"><a href="#反射的作用有哪些" class="headerlink" title="反射的作用有哪些"></a>反射的作用有哪些</h4><ul><li>前面只是说了反射是一种具有与Java类进行动态交互能力的一种机制，在Java和Android开发中，一般情况下下面几种场景会用到反射机制.<ul><li>需要访问隐藏属性或者调用方法改变程序原来的逻辑，这个在开发中很常见的，由于一些原因，系统并没有开放一些接口出来，这个时候利用反射是一个有效的解决方法</li><li>自定义注解，注解就是在运行时利用反射机制来获取的。</li><li>在开发中动态加载类，比如在Android中的动态加载解决65k问题等等，模块化和插件化都离不开反射，离开了反射寸步难行。</li></ul></li></ul><h3 id="反射的相关使用"><a href="#反射的相关使用" class="headerlink" title="反射的相关使用"></a>反射的相关使用</h3><h4 id="通过反射获取成员变量-包含私有-并使用"><a href="#通过反射获取成员变量-包含私有-并使用" class="headerlink" title="通过反射获取成员变量[包含私有]并使用"></a>通过反射获取成员变量[包含私有]并使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">clazz = Class.forName(&quot;com.ycbjie.ycpaidian.four.ReflexUtils&quot;);</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(Context.class);</span><br><span class="line">//设置安全检查，访问私有构造函数必须</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">Object[] obj = new Object[]&#123;mContext&#125;;</span><br><span class="line">//创建实例</span><br><span class="line">ReflexUtils clazzObj = (ReflexUtils) constructor.newInstance(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//反射修改私有变量</span><br><span class="line">// 获取声明的 code 字段，这里要注意 getField 和 getDeclaredField 的区别</span><br><span class="line">Field gradeField = clazz.getDeclaredField(&quot;code&quot;);</span><br><span class="line">// 如果是 private 或者 package 权限的，一定要赋予其访问权限</span><br><span class="line">gradeField.setAccessible(true);</span><br><span class="line">// 修改 student 对象中的 Grade 字段值</span><br><span class="line">gradeField.set(clazzObj, 2);</span><br><span class="line">LogUtils.e(&quot;点击3----&quot;+clazzObj.getCode());</span><br></pre></td></tr></table></figure><h4 id="通过反射获取无参无返回值成员方法-包含私有-并使用"><a href="#通过反射获取无参无返回值成员方法-包含私有-并使用" class="headerlink" title="通过反射获取无参无返回值成员方法[包含私有]并使用"></a>通过反射获取无参无返回值成员方法[包含私有]并使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">clazz = Class.forName(&quot;com.ycbjie.ycpaidian.four.ReflexUtils&quot;);</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(Context.class);</span><br><span class="line">//设置安全检查，访问私有构造函数必须</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">Object[] obj = new Object[]&#123;mContext&#125;;</span><br><span class="line">//创建实例</span><br><span class="line">ReflexUtils clazzObj = (ReflexUtils) constructor.newInstance(obj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取私有方法，同样注意 getMethod 和 getDeclaredMethod 的区别</span><br><span class="line">Method goMethod = clazz.getDeclaredMethod(&quot;getMethod&quot;);</span><br><span class="line">// 赋予访问权限</span><br><span class="line">goMethod.setAccessible(true);</span><br><span class="line">// 调用 goToSchool 方法。</span><br><span class="line">goMethod.invoke(clazzObj);</span><br></pre></td></tr></table></figure><h4 id="通过反射获取带参无返回值成员方法并使用"><a href="#通过反射获取带参无返回值成员方法并使用" class="headerlink" title="通过反射获取带参无返回值成员方法并使用"></a>通过反射获取带参无返回值成员方法并使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">clazz = Class.forName(&quot;com.ycbjie.ycpaidian.four.ReflexUtils&quot;);</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(Context.class);</span><br><span class="line">//设置安全检查，访问私有构造函数必须</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">Object[] obj = new Object[]&#123;mContext&#125;;</span><br><span class="line">//创建实例</span><br><span class="line">ReflexUtils clazzObj = (ReflexUtils) constructor.newInstance(obj);</span><br><span class="line"></span><br><span class="line">//这种不行，注意getDeclaredMethod和invoke方法需要传递参数</span><br><span class="line">/*Method copyText = clazz.getDeclaredMethod(&quot;copyText&quot;);</span><br><span class="line">copyText.setAccessible(true);</span><br><span class="line">copyText.invoke(clazzObj,&quot;测试复制这个功能&quot;);*/</span><br><span class="line"></span><br><span class="line">// 获取私有方法，同样注意 getMethod 和 getDeclaredMethod 的区别</span><br><span class="line">Method copyText = clazz.getDeclaredMethod(&quot;copyText&quot;,String.class);</span><br><span class="line">// 赋予访问权限</span><br><span class="line">copyText.setAccessible(true);</span><br><span class="line">// 调用 copyText 方法。</span><br><span class="line">copyText.invoke(clazzObj,&quot;测试复制这个功能&quot;);</span><br></pre></td></tr></table></figure><h4 id="通过反射获取带参带返回值成员方法并使用"><a href="#通过反射获取带参带返回值成员方法并使用" class="headerlink" title="通过反射获取带参带返回值成员方法并使用"></a>通过反射获取带参带返回值成员方法并使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">clazz = Class.forName(&quot;com.ycbjie.ycpaidian.four.ReflexUtils&quot;);</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(Context.class);</span><br><span class="line">//设置安全检查，访问私有构造函数必须</span><br><span class="line">constructor.setAccessible(true);</span><br><span class="line">Object[] obj = new Object[]&#123;mContext&#125;;</span><br><span class="line">//创建实例</span><br><span class="line">ReflexUtils clazzObj = (ReflexUtils) constructor.newInstance(obj);</span><br><span class="line"></span><br><span class="line">//这种不行，注意getDeclaredMethod和invoke方法需要传递参数</span><br><span class="line">/*Method copyText = clazz.getDeclaredMethod(&quot;copyText&quot;);</span><br><span class="line">copyText.setAccessible(true);</span><br><span class="line">copyText.invoke(clazzObj,&quot;测试复制这个功能&quot;);*/</span><br><span class="line"></span><br><span class="line">// 获取私有方法，同样注意 getMethod 和 getDeclaredMethod 的区别</span><br><span class="line">Method copyText1 = clazz.getDeclaredMethod(&quot;copyText&quot;,String.class,String.class);</span><br><span class="line">// 赋予访问权限</span><br><span class="line">copyText1.setAccessible(true);</span><br><span class="line">// 调用 copyText 方法</span><br><span class="line">boolean isSuccess = (boolean) copyText1.invoke(clazzObj,&quot;测试复制这个功能&quot;,&quot;1111&quot;);</span><br></pre></td></tr></table></figure><h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><h5 id="设置-setAccessible-true-暴力访问权限"><a href="#设置-setAccessible-true-暴力访问权限" class="headerlink" title="设置.setAccessible(true)暴力访问权限"></a>设置.setAccessible(true)暴力访问权限</h5><ul><li>一般情况下，我们并不能对类的私有字段进行操作，利用反射也不例外，但有的时候，例如要序列化的时候，我们又必须有能力去处理这些字段，这时候，我们就需要调用AccessibleObject上的setAccessible()方法来允许这种访问，而由于反射类中的Field，Method和Constructor继承自AccessibleObject，因此，通过在这些类上调用setAccessible()方法，我们可以实现对这些字段的操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Field gradeField = clazz.getDeclaredField(&quot;code&quot;);</span><br><span class="line">// 如果是 private 或者 package 权限的，一定要赋予其访问权限</span><br><span class="line">gradeField.setAccessible(true);</span><br><span class="line"></span><br><span class="line">Method goMethod = clazz.getDeclaredMethod(&quot;getMethod&quot;);</span><br><span class="line">// 赋予访问权限</span><br><span class="line">goMethod.setAccessible(true);</span><br></pre></td></tr></table></figure><h4 id="获取Filed两个方法的区别"><a href="#获取Filed两个方法的区别" class="headerlink" title="获取Filed两个方法的区别"></a>获取Filed两个方法的区别</h4><ul><li>两者的区别就是 getDeclaredField() 获取的是 Class 中被 private 修饰的属性。 getField() 方法获取的是非私有属性，并且 getField() 在当前 Class 获取不到时会向祖先类获取。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取所有的属性，但不包括从父类继承下来的属性</span><br><span class="line">public Field[] getDeclaredFields() throws SecurityException &#123;&#125;</span><br><span class="line"></span><br><span class="line">//获取自身的所有的 public 属性，包括从父类继承下来的。</span><br><span class="line">public Field[] getFields() throws SecurityException &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="获取Field的类型"><a href="#获取Field的类型" class="headerlink" title="获取Field的类型"></a>获取Field的类型</h4><ul><li>可以看到 getGenericType() 确实把泛型都打印出来了，它比 getType() 返回的内容更详细。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public Type getGenericType() &#123;&#125;</span><br><span class="line">public Class&lt;?&gt; getType() &#123;&#125;</span><br><span class="line"></span><br><span class="line">Field[] filed2 = clazz.getFields();</span><br><span class="line">for ( Field f : filed2 ) &#123;</span><br><span class="line">    System.out.println(&quot;Field :&quot;+f.getName());</span><br><span class="line">    System.out.println(&quot;Field type:&quot;+f.getType());</span><br><span class="line">    System.out.println(&quot;Field generic type:&quot;+f.getGenericType());</span><br><span class="line">    System.out.println(&quot;-------------------&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印值</span><br><span class="line">07-31 17:20:41.027 8700-8700/com.ycbjie.ycpaidian I/System.out: Field :cars</span><br><span class="line">07-31 17:20:41.027 8700-8700/com.ycbjie.ycpaidian I/System.out: Field type:interface java.util.List</span><br><span class="line">07-31 17:20:41.028 8700-8700/com.ycbjie.ycpaidian I/System.out: Field generic type:java.util.List&lt;com.ycbjie.ycpaidian.four.Car&gt;</span><br><span class="line">07-31 17:20:41.028 8700-8700/com.ycbjie.ycpaidian I/System.out: Field :map</span><br><span class="line">07-31 17:20:41.028 8700-8700/com.ycbjie.ycpaidian I/System.out: Field type:class java.util.HashMap</span><br><span class="line">07-31 17:20:41.028 8700-8700/com.ycbjie.ycpaidian I/System.out: Field generic type:java.util.HashMap&lt;java.lang.Integer, java.lang.String&gt;</span><br><span class="line">07-31 17:20:41.028 8700-8700/com.ycbjie.ycpaidian I/System.out: Field :name</span><br><span class="line">07-31 17:20:41.028 8700-8700/com.ycbjie.ycpaidian I/System.out: Field type:class java.lang.String</span><br><span class="line">07-31 17:20:41.028 8700-8700/com.ycbjie.ycpaidian I/System.out: Field generic type:class java.lang.String</span><br></pre></td></tr></table></figure><h4 id="Method获取方法名，获取方法参数"><a href="#Method获取方法名，获取方法参数" class="headerlink" title="Method获取方法名，获取方法参数"></a>Method获取方法名，获取方法参数</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//获取方法名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//获取方法参数</span><br><span class="line">//返回的是一个 Parameter 数组，在反射中 Parameter 对象就是用来映射方法中的参数。</span><br><span class="line">public Parameter[] getParameters() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Method获取方法名</span><br><span class="line">Method[] declaredMethods1 = clazz.getDeclaredMethods();</span><br><span class="line">for ( Method m : declaredMethods1 ) &#123;</span><br><span class="line">    System.out.println(&quot;method name:&quot;+m.getName());</span><br><span class="line">&#125;</span><br><span class="line">//获取方法参数</span><br><span class="line">for ( Method m : declaredMethods1 ) &#123;</span><br><span class="line">    System.out.println(&quot;获取方法参数method name:&quot;+m.getName());</span><br><span class="line">    //获取参数</span><br><span class="line">    Parameter[] paras;</span><br><span class="line">    if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;</span><br><span class="line">        paras = m.getParameters();</span><br><span class="line">        for (Parameter c : paras ) &#123;</span><br><span class="line">            System.out.println(&quot;获取参数parameter :&quot;+c.getName()+&quot; &quot;+c.getType().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取所有的参数类型</span><br><span class="line">    Class[] pTypes = m.getParameterTypes();</span><br><span class="line">    for ( Class c : pTypes ) &#123;</span><br><span class="line">        System.out.print(&quot;参数类型method para types:&quot;+ c.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    System.out.println(&quot;==========================================&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//打印日志如下所示：</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: ==========================================</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取方法参数method name:copyText</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取参数parameter :arg0 java.lang.String</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: 参数类型method para types:java.lang.String</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: ==========================================</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取方法参数method name:copyText</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取参数parameter :arg0 java.lang.String</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取参数parameter :arg1 java.lang.String</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: 参数类型method para types:java.lang.String参数类型method para types:java.lang.String</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: ==========================================</span><br><span class="line">07-31 19:23:13.191 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取方法参数method name:getCode</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: ==========================================</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取方法参数method name:getUserInfo</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取参数parameter :arg0 java.lang.String</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: 参数类型method para types:java.lang.String</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: ==========================================</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取方法参数method name:setCode</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: 获取参数parameter :arg0 int</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: 参数类型method para types:int</span><br><span class="line">07-31 19:23:13.192 4022-4022/com.ycbjie.ycpaidian I/System.out: ==========================================</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-5-Method方法的invoke-方法执行"><a href="#3-1-5-Method方法的invoke-方法执行" class="headerlink" title="3.1.5 Method方法的invoke()方法执行"></a>3.1.5 Method方法的invoke()方法执行</h4><ul><li>Method 调用 invoke() 的时候，存在许多细节：<ul><li>invoke() 方法中第一个参数 Object 实质上是 Method 所依附的 Class 对应的类的实例，如果这个方法是一个静态方法，那么 ojb 为 null，后面的可变参数 Object 对应的自然就是参数。</li><li><strong>invoke() 返回的对象是 Object，所以实际上执行的时候要进行强制转换。</strong></li><li>在对Method调用invoke()的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由Method统一抛InvocationTargetException。而通过InvocationTargetException.getCause() 可以获取真正的异常。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;反射概述&quot;&gt;&lt;a href=&quot;#反射概述&quot; class=&quot;headerlink&quot; title=&quot;反射概述&quot;&gt;&lt;/a&gt;反射概述&lt;/h3&gt;&lt;h4 id=&quot;反射概述-1&quot;&gt;&lt;a href=&quot;#反射概述-1&quot; class=&quot;headerlink&quot; title=&quot;反射概述&quot;
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="reflex" scheme="https://Cool-Loong.github.io/tags/reflex/"/>
    
  </entry>
  
  <entry>
    <title>GitHub使用</title>
    <link href="https://Cool-Loong.github.io/2019/05/12/GitHub%E4%BD%BF%E7%94%A8/"/>
    <id>https://Cool-Loong.github.io/2019/05/12/GitHub使用/</id>
    <published>2019-05-12T06:31:43.000Z</published>
    <updated>2019-05-12T06:33:37.070Z</updated>
    
    <content type="html"><![CDATA[<h3 id="01-git简单上传代码步骤"><a href="#01-git简单上传代码步骤" class="headerlink" title="01.git简单上传代码步骤"></a>01.git简单上传代码步骤</h3><h4 id="1-1-最简单方法"><a href="#1-1-最简单方法" class="headerlink" title="1.1 最简单方法"></a>1.1 最简单方法</h4><ul><li>如下所示  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd 名称                                 //进入提交文件目录</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;command&quot;                 //command提交内容</span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line">提交失败场景：</span><br><span class="line">根据提示 “更新被拒绝，因为远程仓库包含您本地尚不存在的提交。由此可知github上面可能和本地的代码不同步，需要把远程服务器的代码更新到本地才行。【可能是网站上更改了某文件导致不同步】</span><br><span class="line">解决方法：输入命令git pull即可把github上的代码更新到本地。然后在重新提交</span><br><span class="line"></span><br><span class="line">如果还是无法提交，可以尝试强制更新</span><br><span class="line">git push -u origin +master</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-常见的命令"><a href="#1-2-常见的命令" class="headerlink" title="1.2 常见的命令"></a>1.2 常见的命令</h4><h3 id="02-初始化配置"><a href="#02-初始化配置" class="headerlink" title="02.初始化配置"></a>02.初始化配置</h3><ul><li>Git 的设置文件为 .gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。<ul><li>显示当前的 Git 配置<ul><li>$ git config –list</li></ul></li><li>编辑 Git 配置文件<ul><li>$ git config -e [–global] //–global 表示设置全局配置，不加该参数只对当前仓库生效</li></ul></li><li>设置提交代码时的用户信息<ul><li>$ git config [–global] user.name “[name]”</li><li>$ git config [–global] user.email “[email address]”</li></ul></li><li>创建 SSH key<ul><li>$ ssh-keygen -t rsa -C “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</li><li>此时会生成 id_rsa 和 id_rsa.pub 两个文件，登录网站设置点击 <strong>Add SSH Key</strong> 在 <strong>key</strong> 文本里粘贴 <strong>id_rsa.pub</strong> 文件的内容</li></ul></li></ul></li><li>关联远程仓库<ul><li>$ git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxx/xxx.git</li></ul></li><li>推送到远程 master 分支<ul><li>$ git push -u origin master</li></ul></li></ul><h3 id="03-克隆代码库"><a href="#03-克隆代码库" class="headerlink" title="03.克隆代码库"></a>03.克隆代码库</h3><ul><li>下载一个项目和它的整个代码历史<blockquote><p>$ git clone [url]</p><p>[url : <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxx/xxx.git]</p></blockquote></li></ul><h3 id="04-查看代码库信息"><a href="#04-查看代码库信息" class="headerlink" title="04.查看代码库信息"></a>04.查看代码库信息</h3><ul><li>显示有变更的文件<blockquote><p>$ git status</p></blockquote></li><li>显示当前分支的版本历史<blockquote><p>$ git log [–pretty=oneline] //–pretty=oneline 参数可以简化输出信息</p></blockquote></li><li>显示当前分支的最近几次提交<blockquote><p>$ git reflog</p></blockquote></li><li>显示暂存区和工作区的差异<blockquote><p>$ git diff</p></blockquote></li><li>显示暂存区和上一个commit的差异<blockquote><p>$ git diff –cached [file]</p></blockquote></li><li>显示工作区与当前分支最新commit之间的差异<blockquote><p>$ git diff HEAD</p></blockquote></li><li>查看文件内容<blockquote><p>$ cat [file]</p></blockquote></li><li>查看分支合并情况<blockquote><p>$ git log –graph –pretty=oneline –abbrev-commit</p></blockquote></li><li>查看分支合并图<blockquote><p>$ git log –graph</p></blockquote></li></ul><h3 id="05-拉取，提交与推送操作"><a href="#05-拉取，提交与推送操作" class="headerlink" title="05.拉取，提交与推送操作"></a>05.拉取，提交与推送操作</h3><ul><li>下载远程仓库的所有变动<blockquote><p>$ git fetch [remote]</p></blockquote></li><li>取回远程仓库的变化，并与本地分支合并<blockquote><p>$ git pull [remote] [branch]</p></blockquote></li><li>添加文件到暂存区<blockquote><p>$ git add [file1] [file2] … //添加文件名</p><p>$ git add [dir]  //添加目录</p><p>$ git add . //添加当前目录的所有文件(不包括删除文件)</p><p>$ git add -A //(-A : –all的缩写)添加当前目录的所有文件</p></blockquote></li><li>提交暂存区到仓库区<blockquote><p>$ git commit -m [message]</p></blockquote></li><li>推送到远程仓库<blockquote><p>$ git push [remote] [branch]</p><p>$ git push [remote] –all</p><p>$ git push origin(远程仓库名称) master(分支名称) //将master分支上的内容推送到远程仓库，如果远程仓库没有master分支将创建</p></blockquote></li></ul><h3 id="06-分支操作"><a href="#06-分支操作" class="headerlink" title="06.分支操作"></a>06.分支操作</h3><ul><li>查看远程仓库信息<blockquote><p>$ git remote -v</p></blockquote></li><li>列出所有本地分支和远程分支<blockquote><p>$ git branch -a</p></blockquote></li><li>新建一个分支，并切换到该分支<blockquote><p>$ git checkout -b [branch]<br>相当于<br>$ git branch [branch-name] //新建一个分支，但依然停留在当前分支</p><p>$ git checkout [branch-name] //切换到指定分支，并更新工作区；如果是远程分支将自动与远程关联本地分支</p></blockquote></li><li>新建一个分支，指向指定 commit<blockquote><p>$ git branch [branch] [commit]</p></blockquote></li><li>新建一个分支，与指定的远程分支建立追踪关系<blockquote><p>$ git branch –track [branch] [remote-branch]</p></blockquote></li><li>设置本地分支与远程origin分支链接<blockquote><p>$ git branch –set-upstream [branch] origin/[branch]</p></blockquote></li><li>合并指定分支到当前分支<blockquote><p>$ git merge [branch]</p></blockquote></li><li>查看分支合并情况<blockquote><p>$ git log –graph –pretty=oneline –abbrev-commit</p></blockquote></li><li>查看分支合并图<blockquote><p>$ git log –graph</p></blockquote></li><li>删除分支<blockquote><p>$ git branch -d [branch-name]</p><p>$ git branch -D [branch-name]    //强行删除</p></blockquote></li><li>删除远程分支<blockquote><p>$ git push origin –delete [branch-name]</p><p>$ git branch -dr [remote/branch]</p></blockquote></li></ul><h3 id="07-工作区操作"><a href="#07-工作区操作" class="headerlink" title="07.工作区操作"></a>07.工作区操作</h3><ul><li>查看工作区<blockquote><p>$ git stash save [desc]</p></blockquote></li><li>查看工作区列表<blockquote><p>$ git stash list</p></blockquote></li><li>取出工作区内容<blockquote><p>$ git stash apply [stash-name] //取出不删除</p><p>$ git stash drop [stash-name] //删除</p><p>$ git stash pop [stash-name] //取出并删除</p></blockquote></li></ul><h3 id="08-远程同步"><a href="#08-远程同步" class="headerlink" title="08.远程同步"></a>08.远程同步</h3><ul><li>默认 origin 代表远程仓库</li><li>下载远程仓库的所有变动<blockquote><p>$ git fetch [remote]</p></blockquote></li><li>显示所有远程仓库<blockquote><p>$ git remote -v</p></blockquote></li><li>显示某个远程仓库的信息<blockquote><p>$ git remote show [remote]</p></blockquote></li><li>增加一个新的远程仓库，并命名<blockquote><p>$ git remote add [shortname] [url]</p></blockquote></li><li>取回远程仓库的变化，并与本地分支合并<blockquote><p>$ git pull [remote] [branch]</p></blockquote></li><li>上传本地指定分支到远程仓库<blockquote><p>$ git push [remote] [branch]</p></blockquote></li><li>强行推送当前分支到远程仓库，即使有冲突<blockquote><p>$ git push [remote] –force</p></blockquote></li><li>推送所有分支到远程仓库<blockquote><p>$ git push [remote] –all</p></blockquote></li></ul><h3 id="09-增加-删除-撤销"><a href="#09-增加-删除-撤销" class="headerlink" title="09.增加/删除/撤销"></a>09.增加/删除/撤销</h3><h4 id="9-1-增加"><a href="#9-1-增加" class="headerlink" title="9.1 增加"></a>9.1 增加</h4><ul><li>添加指定文件到暂存区<blockquote><p>$ git add [file1] [file2] …</p></blockquote></li><li>添加指定目录到暂存区，包括子目录<blockquote><p>$ git add [dir]</p></blockquote></li><li>添加当前目录的所有文件(不包括删除文件)到暂存区<blockquote><p>$ git add .</p></blockquote></li><li>添加当前目录的所有文件到暂存区<blockquote><p>$ git add -A(–all的缩写)</p></blockquote></li><li>添加每个变化前，都会要求确认</li><li>对于同一个文件的多处变化，可以实现分次提交<blockquote><p>$ git add -p</p></blockquote></li></ul><h4 id="9-2-删除"><a href="#9-2-删除" class="headerlink" title="9.2 删除"></a>9.2 删除</h4><ul><li>删除工作区文件，并且将这次删除放入暂存区<blockquote><p>$ git rm [file1] [file2] …</p></blockquote></li><li>停止追踪指定文件，但该文件会保留在工作区<blockquote><p>$ git rm –cached [file]</p></blockquote></li><li>改名文件，并且将这个改名放入暂存区<blockquote><p>$ git mv [file-original] [file-renamed]</p></blockquote></li></ul><h4 id="9-1-撤销"><a href="#9-1-撤销" class="headerlink" title="9.1 撤销"></a>9.1 撤销</h4><ul><li>恢复暂存区的指定文件到工作区<blockquote><p>$ git checkout [file]</p></blockquote></li><li>恢复某个 commit 的指定文件到暂存区和工作区<blockquote><p>$ git checkout [commit] [file]</p></blockquote></li><li>恢复暂存区的所有文件到工作区<blockquote><p>$ git checkout .</p></blockquote></li><li>重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变<blockquote><p>$ git reset [file]</p></blockquote></li><li>重置暂存区与工作区，与上一次 commit 保持一致<blockquote><p>$ git reset –hard</p></blockquote></li><li>重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变<blockquote><p>$ git reset [commit]</p></blockquote></li><li>重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致<blockquote><p>$ git reset –hard [commit]</p></blockquote></li><li>重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变<blockquote><p>$ git reset –keep [commit]</p></blockquote></li><li>新建一个 commit，用来撤销指定 commit</li><li>后者的所有变化都将被前者抵消，并且应用到当前分支<blockquote><p>$ git revert [commit]</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;01-git简单上传代码步骤&quot;&gt;&lt;a href=&quot;#01-git简单上传代码步骤&quot; class=&quot;headerlink&quot; title=&quot;01.git简单上传代码步骤&quot;&gt;&lt;/a&gt;01.git简单上传代码步骤&lt;/h3&gt;&lt;h4 id=&quot;1-1-最简单方法&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="github" scheme="https://Cool-Loong.github.io/categories/github/"/>
    
    
      <category term="github" scheme="https://Cool-Loong.github.io/tags/github/"/>
    
      <category term="git" scheme="https://Cool-Loong.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>java线程池</title>
    <link href="https://Cool-Loong.github.io/2019/03/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://Cool-Loong.github.io/2019/03/19/java线程池/</id>
    <published>2019-03-19T08:29:17.000Z</published>
    <updated>2019-03-19T08:32:53.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于线程池关联博客有："><a href="#关于线程池关联博客有：" class="headerlink" title="关于线程池关联博客有："></a>关于线程池关联博客有：</h3><ul><li><a href="http://www.jcodecraeer.com/plus/view.php?aid=9597" target="_blank" rel="noopener">多线程1，线程基础知识</a></li><li><a href="http://www.jcodecraeer.com/plus/view.php?aid=9604" target="_blank" rel="noopener">多线程2，线程池深入理解</a></li><li><a href="https://blog.csdn.net/m0_37700275/article/details/79979097" target="_blank" rel="noopener">多线程3，线程池封装库</a></li></ul><h3 id="ThreadPoolExecutor类介绍"><a href="#ThreadPoolExecutor类介绍" class="headerlink" title="ThreadPoolExecutor类介绍"></a>ThreadPoolExecutor类介绍</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>ExecutorService是最初的线程池接口，ThreadPoolExecutor类是对线程池的具体实现，它通过构造方法来配置线程池的参数<pre><code>public ThreadPoolExecutor(int corePoolSize,                        int maximumPoolSize,                        long keepAliveTime,                        TimeUnit unit,                        BlockingQueue&lt;Runnable&gt; workQueue) {  this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,       Executors.defaultThreadFactory(), defaultHandler);}</code></pre></li></ul><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><ul><li>corePoolSize，线程池中核心线程的数量，默认情况下，即使核心线程没有任务在执行它也存在的，我们固定一定数量的核心线程且它一直存活这样就避免了一般情况下CPU创建和销毁线程带来的开销。我们如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程就会有超时策略，这个时间由keepAliveTime来设定，即keepAliveTime时间内如果核心线程没有回应则该线程就会被终止。allowCoreThreadTimeOut默认为false，核心线程没有超时时间。</li><li>maximumPoolSize，线程池中的最大线程数，当任务数量超过最大线程数时其它任务可能就会被阻塞。最大线程数=核心线程+非核心线程。非核心线程只有当核心线程不够用且线程池有空余时才会被创建，执行完任务后非核心线程会被销毁。</li><li>keepAliveTime，非核心线程的超时时长，当执行时间超过这个时间时，非核心线程就会被回收。当allowCoreThreadTimeOut设置为true时，此属性也作用在核心线程上。</li><li>unit，枚举时间单位，TimeUnit。</li><li>workQueue，线程池中的任务队列，我们提交给线程池的runnable会被存储在这个对象上。</li></ul><h4 id="遵循的规则"><a href="#遵循的规则" class="headerlink" title="遵循的规则"></a>遵循的规则</h4><ul><li>当线程池中的核心线程数量未达到最大线程数时，启动一个核心线程去执行任务；</li><li>如果线程池中的核心线程数量达到最大线程数时，那么任务会被插入到任务队列中排队等待执行；</li><li>如果在上一步骤中任务队列已满但是线程池中线程数量未达到限定线程总数，那么启动一个非核心线程来处理任务；</li><li>如果上一步骤中线程数量达到了限定线程总量，那么线程池则拒绝执行该任务，且ThreadPoolExecutor会调用RejectedtionHandler的rejectedExecution方法来通知调用者。</li></ul><h4 id="使用线程池管理线程的优点"><a href="#使用线程池管理线程的优点" class="headerlink" title="使用线程池管理线程的优点"></a>使用线程池管理线程的优点</h4><ul><li>1、线程的创建和销毁由线程池维护，一个线程在完成任务后并不会立即销毁，而是由后续的任务复用这个线程，从而减少线程的创建和销毁，节约系统的开销</li><li>2、线程池旨在线程的复用，这就可以节约我们用以往的方式创建线程和销毁所消耗的时间，减少线程频繁调度的开销，从而节约系统资源，提高系统吞吐量</li><li>3、在执行大量异步任务时提高了性能</li><li>4、Java内置的一套ExecutorService线程池相关的api，可以更方便的控制线程的最大并发数、线程的定时任务、单线程的顺序执行等</li></ul><h3 id="关于线程池的分类"><a href="#关于线程池的分类" class="headerlink" title="关于线程池的分类"></a>关于线程池的分类</h3><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><ul><li>通过Executors的newFixedThreadPool()方法创建，它是个线程数量固定的线程池，该线程池的线程全部为核心线程，它们没有超时机制且排队任务队列无限制，因为全都是核心线程，所以响应较快，且不用担心线程会被回收。</li></ul><h4 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h4><ul><li>通过Executors的newCachedThreadPool()方法来创建，它是一个数量无限多的线程池，它所有的线程都是非核心线程，当有新任务来时如果没有空闲的线程则直接创建新的线程不会去排队而直接执行，并且超时时间都是60s，所以此线程池适合执行大量耗时小的任务。由于设置了超时时间为60s，所以当线程空闲一定时间时就会被系统回收，所以理论上该线程池不会有占用系统资源的无用线程。</li></ul><h4 id="ScheduledThreadPool"><a href="#ScheduledThreadPool" class="headerlink" title="ScheduledThreadPool"></a>ScheduledThreadPool</h4><ul><li>通过Executors的newScheduledThreadPool()方法来创建，ScheduledThreadPool线程池像是上两种的合体，它有数量固定的核心线程，且有数量无限多的非核心线程，但是它的非核心线程超时时间是0s，所以非核心线程一旦空闲立马就会被回收。这类线程池适合用于执行定时任务和固定周期的重复任务。</li></ul><h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><ul><li>通过Executors的newSingleThreadExecutor()方法来创建，它内部只有一个核心线程，它确保所有任务进来都要排队按顺序执行。它的意义在于，统一所有的外界任务到同一线程中，让调用者可以忽略线程同步问题。</li></ul><h3 id="线程池一般用法"><a href="#线程池一般用法" class="headerlink" title="线程池一般用法"></a>线程池一般用法</h3><h4 id="一般方法介绍"><a href="#一般方法介绍" class="headerlink" title="一般方法介绍"></a>一般方法介绍</h4><ul><li>shutDown()，关闭线程池，需要执行完已提交的任务；</li><li>shutDownNow()，关闭线程池，并尝试结束已提交的任务；</li><li>allowCoreThreadTimeOut(boolen)，允许核心线程闲置超时回收；</li><li>execute()，提交任务无返回值；</li><li>submit()，提交任务有返回值；</li></ul><h4 id="newFixedThreadPool的使用"><a href="#newFixedThreadPool的使用" class="headerlink" title="newFixedThreadPool的使用"></a>newFixedThreadPool的使用</h4><ul><li><strong>创建一个newFixedThreadPool线程池</strong></li></ul><pre><code>private void newFixedThreadPool() {    ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5);    for (int i = 1; i &lt;= 20; i++) {        final int index = i;        fixedThreadPool.execute(new Runnable() {            @Override            public void run() {                String threadName = Thread.currentThread().getName();                Log.e(&quot;潇湘剑雨&quot;, &quot;线程：&quot;+threadName+&quot;,正在执行第&quot; + index + &quot;个任务&quot;);                try {                    Thread.sleep(2000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });    }}</code></pre><ul><li><strong>打印日志如下</strong></li><li>创建了一个线程数为5的固定线程数量的线程池，同理该线程池支持的线程最大并发数也是5，模拟20个任务让它处理，执行任务。最后我们获取线程的信息，打印日志。</li><li>日志如图所示：<br><img src="https://upload-images.jianshu.io/upload_images/4432347-ba0b93632ac0f80f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="newSingleThreadExecutor的使用"><a href="#newSingleThreadExecutor的使用" class="headerlink" title="newSingleThreadExecutor的使用"></a>newSingleThreadExecutor的使用</h4><ul><li><strong>创建一个newSingleThreadExecutor线程池</strong></li></ul><pre><code>private void newSingleThreadExecutor() {    ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();    for (int i = 1; i &lt;= number; i++) {        final int index = i;        singleThreadPool.execute(new Runnable() {            @Override            public void run() {                String threadName = Thread.currentThread().getName();                Log.v(&quot;潇湘剑雨&quot;, &quot;线程：&quot;+threadName+&quot;,正在执行第&quot; + index + &quot;个任务&quot;);                try {                    Thread.sleep(1000);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });    }}</code></pre><ul><li><strong>打印日志如下</strong></li><li>改了线程池的实现方式，即依次一个一个的处理任务，而且都是复用一个线程，日志为<br><img src="https://upload-images.jianshu.io/upload_images/4432347-5ad122ee9d55f409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="newCachedThreadPool的使用"><a href="#newCachedThreadPool的使用" class="headerlink" title="newCachedThreadPool的使用"></a>newCachedThreadPool的使用</h4><ul><li><strong>创建一个newCachedThreadPool线程池</strong></li></ul><pre><code>private void newCachedThreadPool() {    ExecutorService cachedThreadPool = Executors.newCachedThreadPool();    for (int i = 1; i &lt;= number; i++) {        final int index = i;        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }        cachedThreadPool.execute(new Runnable() {            @Override            public void run() {                String threadName = Thread.currentThread().getName();                Log.v(&quot;潇湘剑雨newCachedThreadPool&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行第&quot; + index + &quot;个任务&quot;);                try {                    long time = index * 500;                    Thread.sleep(time);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });    }}</code></pre><ul><li><strong>打印日志如下</strong></li><li>为了体现该线程池可以自动根据实现情况进行线程的重用，而不是一味的创建新的线程去处理任务，我设置了每隔1s去提交一个新任务，这个新任务执行的时间也是动态变化的，所以，效果为：<br><img src="https://upload-images.jianshu.io/upload_images/4432347-54da4f08327cca18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="newScheduledThreadPool的使用"><a href="#newScheduledThreadPool的使用" class="headerlink" title="newScheduledThreadPool的使用"></a>newScheduledThreadPool的使用</h4><ul><li><strong>创建一个newScheduledThreadPool线程池</strong></li></ul><pre><code>private void newScheduledThreadPool() {    ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);    //延迟2秒后执行该任务    scheduledThreadPool.schedule(new Runnable() {        @SuppressLint(&quot;LongLogTag&quot;)        @Override        public void run() {            String threadName = Thread.currentThread().getName();            Log.e(&quot;潇湘剑雨newScheduledThreadPool&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行&quot;);        }    }, 2, TimeUnit.SECONDS);    //延迟1秒后，每隔2秒执行一次该任务    scheduledThreadPool.scheduleAtFixedRate(new Runnable() {        @Override        public void run() {            String threadName = Thread.currentThread().getName();            Log.e(&quot;潇湘剑雨&quot;, &quot;线程：&quot; + threadName + &quot;,正在执行&quot;);        }    }, 1, 2, TimeUnit.SECONDS);}</code></pre><ul><li><strong>打印日志如下</strong></li><li>通过日志可以发现schedule方法的任务只是执行了一次，然后每隔2秒执行一次该scheduleAtFixedRate方法中的任务<br><img src="https://upload-images.jianshu.io/upload_images/4432347-859e1af04c62dc09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="线程创建规则"><a href="#线程创建规则" class="headerlink" title="线程创建规则"></a>线程创建规则</h4><ul><li>ThreadPoolExecutor对象初始化时，不创建任何执行线程，当有新任务进来时，才会创建执行线程。构造ThreadPoolExecutor对象时，需要配置该对象的核心线程池大小和最大线程池大小</li><li><ol><li>当目前执行线程的总数小于核心线程大小时，所有新加入的任务，都在新线程中处理。</li></ol></li><li><ol start="2"><li>当目前执行线程的总数大于或等于核心线程时，所有新加入的任务，都放入任务缓存队列中。</li></ol></li><li><ol start="3"><li>当目前执行线程的总数大于或等于核心线程，并且缓存队列已满，同时此时线程总数小于线程池的最大大小，那么创建新线程，加入线程池中，协助处理新的任务。</li></ol></li><li><ol start="4"><li>当所有线程都在执行，线程池大小已经达到上限，并且缓存队列已满时，就rejectHandler拒绝新的任务。</li></ol></li></ul><h3 id="线程池封装"><a href="#线程池封装" class="headerlink" title="线程池封装"></a>线程池封装</h3><h4 id="具体可以参考下篇文章"><a href="#具体可以参考下篇文章" class="headerlink" title="具体可以参考下篇文章"></a>具体可以参考下篇文章</h4><h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><ul><li>Android性能优化之使用线程池处理异步任务：<a href="https://blog.csdn.net/u010687392/article/details/49850803" target="_blank" rel="noopener">https://blog.csdn.net/u010687392/article/details/49850803</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于线程池关联博客有：&quot;&gt;&lt;a href=&quot;#关于线程池关联博客有：&quot; class=&quot;headerlink&quot; title=&quot;关于线程池关联博客有：&quot;&gt;&lt;/a&gt;关于线程池关联博客有：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jcodecra
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="Thread" scheme="https://Cool-Loong.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>java线程基础</title>
    <link href="https://Cool-Loong.github.io/2019/03/13/java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://Cool-Loong.github.io/2019/03/13/java线程基础/</id>
    <published>2019-03-13T12:26:37.000Z</published>
    <updated>2019-03-13T12:42:57.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.jcodecraeer.com/plus/view.php?aid=9597" target="_blank" rel="noopener">多线程1，线程基础知识</a></li><li><a href="http://www.jcodecraeer.com/plus/view.php?aid=9604" target="_blank" rel="noopener">多线程2，线程池深入理解</a></li><li><a href="https://blog.csdn.net/m0_37700275/article/details/79979097" target="_blank" rel="noopener">多线程3，线程池封装库</a></li></ul><h3 id="进程概述及多进程的意义-理解"><a href="#进程概述及多进程的意义-理解" class="headerlink" title="进程概述及多进程的意义[理解]"></a>进程概述及多进程的意义[理解]</h3><h4 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h4><ul><li>要想说线程，首先必须得聊聊进程，因为线程是依赖于进程存在的。</li></ul><h4 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h4><ul><li>什么是进程呢?通过任务管理器我们就可以看到进程的存在。</li><li>概念：进程就是正在运行的程序，是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。</li></ul><h4 id="多进程的意义"><a href="#多进程的意义" class="headerlink" title="多进程的意义"></a>多进程的意义</h4><ul><li>单进程计算机只能做一件事情。而我们现在的计算机都可以一边玩游戏(游戏进程),一边听音乐(音乐进程)，所以我们常见的操作系统都是多进程操作系统。比如：Windows，Mac和Linux等，能在同一个时间段内执行多个任务。</li><li>对于单核计算机来讲，游戏进程和音乐进程是同时运行的吗?不是。</li><li>因为CPU在某个时间点上只能做一件事情，计算机是在游戏进程和音乐进程间做着频繁切换，且切换速度很快，</li><li>所以，我们感觉游戏和音乐在同时进行，其实并不是同时执行的。多进程的作用不是提高执行速度，而是提高CPU的使用率。</li></ul><h3 id="线程的概述和多线程的意义-理解"><a href="#线程的概述和多线程的意义-理解" class="headerlink" title="线程的概述和多线程的意义[理解]"></a>线程的概述和多线程的意义[理解]</h3><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><ul><li>在一个进程内部又可以执行多个任务，而这每一个任务我们就可以看成是一个线程。是程序使用CPU的基本单位。</li></ul><h4 id="多线程有什么意义"><a href="#多线程有什么意义" class="headerlink" title="多线程有什么意义"></a>多线程有什么意义</h4><ul><li>多线程的作用不是提高执行速度，而是为了提高应用程序的使用率。</li><li>那么怎么理解这个问题呢?我们程序在运行的使用,都是在抢CPU的时间片(执行权),如果是多线程的程序,那么在抢到CPU的执行权的概率应该比较单线程程序抢到的概率要大.那么也就是说,CPU在多线程程序中执行的时间要比单线程多,所以就提高了程序的使用率.但是即使是多线程程序,那么他们中的哪个线程能抢占到CPU的资源呢,这个是不确定的,所以多线程具有随机性.</li></ul><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li>前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。</li><li>后者是物理上同时发生，指在某一个时间点同时运行多个程序。</li></ul><h3 id="JVM运行原理以及JVM启动的线程探讨-理解"><a href="#JVM运行原理以及JVM启动的线程探讨-理解" class="headerlink" title="JVM运行原理以及JVM启动的线程探讨[理解]"></a>JVM运行原理以及JVM启动的线程探讨[理解]</h3><h4 id="Java程序运行原理"><a href="#Java程序运行原理" class="headerlink" title="Java程序运行原理"></a>Java程序运行原理</h4><ul><li>Java命令会启动java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。</li><li>该进程会自动启动一个 “主线程” ，然后主线程去调用某个类的 main 方法。所以 main方法运行在主线程中。</li></ul><h4 id="JVM的启动是多线程的吗"><a href="#JVM的启动是多线程的吗" class="headerlink" title="JVM的启动是多线程的吗"></a>JVM的启动是多线程的吗</h4><ul><li>JVM启动至少启动了垃圾回收线程和主线程，所以是多线程的。</li></ul><h3 id="多线程程序实现的方式-掌握"><a href="#多线程程序实现的方式-掌握" class="headerlink" title="多线程程序实现的方式[掌握]"></a>多线程程序实现的方式[掌握]</h3><h4 id="多线程程序实现的方式"><a href="#多线程程序实现的方式" class="headerlink" title="多线程程序实现的方式"></a>多线程程序实现的方式</h4><ul><li><strong>第一种方式：是类继承Thread</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">第一种方式的步骤:</span><br><span class="line">1: 定义一个类,让该类去继承Thread类</span><br><span class="line">2: 重写run方法</span><br><span class="line">3: 创建该类的对象</span><br><span class="line">4: 启动线程</span><br><span class="line"></span><br><span class="line">public class ThreadDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 创建对象</span><br><span class="line">MyThread t1 = new MyThread() ;</span><br><span class="line">MyThread t2 = new MyThread() ;</span><br><span class="line">// 启动线程: 需要使用start方法启动线程, 如果我们在这里调用的是run方法,那么我们只是把该方法作为普通方法进行执行</span><br><span class="line">//t1.run() ;</span><br><span class="line">//t1.run() ;</span><br><span class="line">t1.start() ;// 告诉jvm开启一个线程调用run方法</span><br><span class="line">// t1.start() ;// 一个线程只能被启动一次</span><br><span class="line">t2.start() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int x = 0 ; x &lt; 1000 ; x++) &#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>第二种方式：是实现接口Runnable</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">实现多线程的第二中方式步骤:</span><br><span class="line">1: 定义一个类,让该类去实现Runnable接口</span><br><span class="line">2: 重写run方法</span><br><span class="line">3: 创建定义的类的对象</span><br><span class="line">4: 创建Thread的对象吧第三步创建的对象作为参数传递进来</span><br><span class="line">5: 启动线程</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 创建定义的类的对象</span><br><span class="line">MyThread mt = new MyThread() ;</span><br><span class="line">// 创建Thread的对象吧第三步创建的对象作为参数传递进来</span><br><span class="line">Thread t1 = new Thread(mt , &quot;张三&quot;) ;</span><br><span class="line">Thread t2 = new Thread(mt , &quot;李四&quot;) ;</span><br><span class="line">// 启动线程</span><br><span class="line">t1.start() ;</span><br><span class="line">t2.start() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyThread implements Runnable &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">for(int x = 0 ; x &lt; 1000 ; x++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;---&quot; + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多线程两种方式的区别"><a href="#多线程两种方式的区别" class="headerlink" title="多线程两种方式的区别"></a>多线程两种方式的区别</h4><ul><li>run()方法只是调用了Thread实例的run()方法而已，它仍然运行在主线程上，而start()方法会开辟一个新的线程，在新的线程上调用run()方法，此时它运行在新的线程上。</li></ul><h4 id="几个小问题探索"><a href="#几个小问题探索" class="headerlink" title="几个小问题探索"></a>几个小问题探索</h4><ul><li><strong>为什么要重写run方法</strong></li><li>可以在定义的类中,定义多个方法,而方法中的代码并不是所有的都需要线程来进行执行; 如果我们想让某一个段代码被线程,那么我们只需要将那一段代码放在run方法中。那么也就是说run方法中封装的都是要被线程执行的代码 ; </li><li>run方法中的代码的特点: 封装的都是一些比较耗时的代码</li></ul><ul><li><strong>线程能不能多次启动</strong></li><li>一个线程只能被启动一次</li></ul><ul><li><strong>run()和start()方法的区别</strong></li><li>启动线程: 需要使用start方法启动线程， 如果我们在这里调用的是run方法，那么我们只是把该方法作为普通方法进行执行。</li></ul><h4 id="匿名内部类的方式实现多线程程序"><a href="#匿名内部类的方式实现多线程程序" class="headerlink" title="匿名内部类的方式实现多线程程序"></a>匿名内部类的方式实现多线程程序</h4><ul><li>new Thread(){代码…}.start();</li><li>new Thread(new Runnable(){代码…}).start();</li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="线程的调度问题"><a href="#线程的调度问题" class="headerlink" title="线程的调度问题"></a>线程的调度问题</h4><ul><li>应用程序在执行的时候都需要依赖于线程去抢占CPU的时间片 , 谁抢占到了CPU的时间片,那么CPU就会执行谁</li><li>线程的执行：假如我们的计算机只有一个 CPU，那么 CPU在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。</li></ul><h4 id="线程有两种调度模型"><a href="#线程有两种调度模型" class="headerlink" title="线程有两种调度模型"></a>线程有两种调度模型</h4><ul><li><strong>分时调度模型</strong>     </li><li>所有线程轮流使用CPU的使用权，平均分配每个线程占用 CPU 的时间片</li><li><strong>抢占式调度模型</strong></li><li>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。Java使用的是抢占式调度模型。</li></ul><h3 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h3><h4 id="线程控制之休眠线程"><a href="#线程控制之休眠线程" class="headerlink" title="线程控制之休眠线程"></a>线程控制之休眠线程</h4><ul><li>public static void sleep(long time) ;    </li><li>time表达的意思是休眠的时间 , 单位是毫秒</li></ul><h4 id="线程控制之加入线程"><a href="#线程控制之加入线程" class="headerlink" title="线程控制之加入线程"></a>线程控制之加入线程</h4><ul><li>public final void join()</li><li>等待该线程执行完毕了以后,其他线程才能再次执行</li><li><strong>注意事项: 在线程启动之后,在调用方法</strong></li></ul><h4 id="线程控制之礼让线程"><a href="#线程控制之礼让线程" class="headerlink" title="线程控制之礼让线程"></a>线程控制之礼让线程</h4><ul><li>public static void yield():    </li><li>暂停当前正在执行的线程对象，并执行其他线程。 </li><li>线程礼让的原理是: 暂定当前的线程,然CPU去执行其他的线程, 这个暂定的时间是相当短暂的; 当我某一个线程暂定完毕以后,其他的线程还没有抢占到cpu的执行权 ; 那么这个是时候当前的线程会和其他的线程再次抢占cpu的执行权; </li></ul><h4 id="线程控制之守护线程"><a href="#线程控制之守护线程" class="headerlink" title="线程控制之守护线程"></a>线程控制之守护线程</h4><ul><li>public final void setDaemon(boolean on)</li><li>将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。</li><li>jvm会线程程序中存在的线程类型,如果线程全部是守护线程,那么jvm就停止。</li></ul><h4 id="线程控制之中断线程"><a href="#线程控制之中断线程" class="headerlink" title="线程控制之中断线程"></a>线程控制之中断线程</h4><ul><li>public final void stop():        </li><li>停止线程的运行</li><li>public void interrupt():        </li><li>中断线程(这个翻译不太好),查看API可得当线程调用wait(),sleep(long time)方法的时候处于阻塞状态,可以通过这个方法清除阻塞</li></ul><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="继承Thread类的方式卖电影票案例"><a href="#继承Thread类的方式卖电影票案例" class="headerlink" title="继承Thread类的方式卖电影票案例"></a>继承Thread类的方式卖电影票案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">/**</span><br><span class="line"> * 需求：某电影院目前正在上映贺岁大片，共有100张票，而它有3个售票窗口售票，请设计一个程序模拟该电影院售票。</span><br><span class="line"> */</span><br><span class="line">// 创建3个线程对象</span><br><span class="line">SellTicktes t1 = new SellTicktes() ;</span><br><span class="line">SellTicktes t2 = new SellTicktes() ;</span><br><span class="line">SellTicktes t3 = new SellTicktes() ;</span><br><span class="line">// 设置名称</span><br><span class="line">t1.setName(&quot;窗口1&quot;) ;</span><br><span class="line">t2.setName(&quot;窗口2&quot;) ;</span><br><span class="line">t3.setName(&quot;窗口3&quot;) ;</span><br><span class="line">// 启动线程</span><br><span class="line">t1.start() ;</span><br><span class="line">t2.start() ;</span><br><span class="line">t3.start() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SellTicktes extends Thread &#123;</span><br><span class="line">private static int num = 100 ;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">/**</span><br><span class="line"> * 定义总票数</span><br><span class="line"> * </span><br><span class="line"> * 如果我们把票数定义成了局部变量,那么表示的意思是每一个窗口出售了各自的100张票; 而我们的需求是: 总共有100张票</span><br><span class="line"> * 而这100张票要被3个窗口出售; 因此我们就不能把票数定义成局部变量,只能定义成成员变量</span><br><span class="line"> */</span><br><span class="line">// 模拟售票</span><br><span class="line">while(true) &#123;</span><br><span class="line">if( num &gt; 0 ) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;正在出售&quot; + (num--) + &quot;张票&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Runnable接口的方式卖电影票"><a href="#实现Runnable接口的方式卖电影票" class="headerlink" title="实现Runnable接口的方式卖电影票"></a>实现Runnable接口的方式卖电影票</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class SellTicektesDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 创建SellTicektes对象</span><br><span class="line">SellTicektes st = new SellTicektes() ;</span><br><span class="line">// 创建Thread对象</span><br><span class="line">Thread t1 = new Thread(st , &quot;窗口1&quot;) ;</span><br><span class="line">Thread t2 = new Thread(st , &quot;窗口2&quot;) ;</span><br><span class="line">Thread t3 = new Thread(st , &quot;窗口3&quot;) ;</span><br><span class="line">// 启动线程</span><br><span class="line">t1.start() ;</span><br><span class="line">t2.start() ;</span><br><span class="line">t3.start() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SellTicektes implements Runnable &#123;</span><br><span class="line">private static int num = 100 ;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">while(true) &#123;</span><br><span class="line">if(num &gt; 0) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + (num--) + &quot;张票&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="买电影票出现了同票和负数票的原因分析"><a href="#买电影票出现了同票和负数票的原因分析" class="headerlink" title="买电影票出现了同票和负数票的原因分析"></a>买电影票出现了同票和负数票的原因分析</h4><ul><li>讲解过电影院售票程序，从表面上看不出什么问题，但是在真实生活中，售票时网络是不能实时传输的，总是存在延迟的情况，所以，在出售一张票以后，需要一点时间的延迟。改实现接口方式的卖票程序,每次卖票延迟100毫秒<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 创建3个线程对象</span><br><span class="line">SellTicktes t1 = new SellTicktes() ;</span><br><span class="line">SellTicktes t2 = new SellTicktes() ;</span><br><span class="line">SellTicktes t3 = new SellTicktes() ;</span><br><span class="line">// 设置名称</span><br><span class="line">t1.setName(&quot;窗口1&quot;) ;</span><br><span class="line">t2.setName(&quot;窗口2&quot;) ;</span><br><span class="line">t3.setName(&quot;窗口3&quot;) ;</span><br><span class="line">// 启动线程</span><br><span class="line">t1.start() ;</span><br><span class="line">t2.start() ;</span><br><span class="line">t3.start() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SellTicktes extends Thread &#123;</span><br><span class="line">private static int num = 100 ;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">// 模拟售票</span><br><span class="line">while(true) &#123;</span><br><span class="line">if( num &gt; 0 ) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(100) ;</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + &quot;正在出售&quot; + (num--) + &quot;张票&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="线程安全问题的产生原因分析"><a href="#线程安全问题的产生原因分析" class="headerlink" title="线程安全问题的产生原因分析"></a>线程安全问题的产生原因分析</h4><ul><li>首先想为什么出现问题?</li><li>是否是多线程环境，是否有共享数据，是否有多条语句操作共享数据</li><li>如何解决多线程安全问题呢?</li><li>基本思想：让程序没有安全问题的环境。怎么实现呢?把多个语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="同步代码块的方式解决线程安全问题"><a href="#同步代码块的方式解决线程安全问题" class="headerlink" title="同步代码块的方式解决线程安全问题"></a>同步代码块的方式解决线程安全问题</h4><ul><li><strong>同步代码块的格式</strong></li><li><p>同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized(对象)&#123;</span><br><span class="line">需要同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>同步代码块优势和劣势</strong></p></li><li>同步的好处:同步的出现解决了多线程的安全问题。</li><li>同步的弊端:当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jcodecraeer.com/plus/view.php?aid=9597&quot; targ
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="Thread" scheme="https://Cool-Loong.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>java匿名内部类和其他</title>
    <link href="https://Cool-Loong.github.io/2019/02/22/java%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%85%B6%E4%BB%96/"/>
    <id>https://Cool-Loong.github.io/2019/02/22/java匿名内部类和其他/</id>
    <published>2019-02-22T07:31:53.000Z</published>
    <updated>2019-02-22T07:34:17.990Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内部类概述和访问特点"><a href="#内部类概述和访问特点" class="headerlink" title="内部类概述和访问特点"></a>内部类概述和访问特点</h3><ul><li>A:内部类概述:   <ul><li>把类定义在其他类的内部，这个类就被称为内部类。</li><li>举例：在类A中定义了一个类B，类B就是内部类。</li></ul></li><li>B:内部类访问特点<ul><li>a:内部类可以直接访问外部类的成员，包括私有。</li><li>b:外部类要访问内部类的成员，必须创建对象。</li></ul></li></ul><h4 id="内部类分类及成员内部类的直接使用"><a href="#内部类分类及成员内部类的直接使用" class="headerlink" title="内部类分类及成员内部类的直接使用"></a>内部类分类及成员内部类的直接使用</h4><ul><li>A:按照内部类位置分类<ul><li>成员位置:在成员位置定义的类，被称为成员内部类。   </li><li>局部位置:在局部位置定义的类，被称为局部内部类。</li></ul></li><li>B:成员内部类<ul><li>如何在测试类中直接访问内部类的成员。</li><li>格式:     外部类名.内部类名 对象名 = 外部类对象.内部类对象;</li></ul></li></ul><h4 id="成员内部类的常见修饰符及应用"><a href="#成员内部类的常见修饰符及应用" class="headerlink" title="成员内部类的常见修饰符及应用"></a>成员内部类的常见修饰符及应用</h4><ul><li>A:成员内部类的修饰符：<ul><li>private     为了保证数据的安全性</li><li>static         为了方便访问数据</li><li>注意事项: <ul><li>a:静态内部类访问的外部类数据必须用静态修饰。</li><li>b: 成员方法可以是静态的也可以是非静态的</li></ul></li></ul></li><li>B:成员内部类被静态修饰后的访问方式是:<pre><code>* 格式:    外部类名.内部类名 对象名 = new 外部类名.内部类名();</code></pre></li></ul><h4 id="局部内部类访问局部变量的问题"><a href="#局部内部类访问局部变量的问题" class="headerlink" title="局部内部类访问局部变量的问题"></a>局部内部类访问局部变量的问题</h4><ul><li>A: 可以直接访问外部类的成员</li><li>B: 可以创建内部类对象，通过对象调用内部类方法，来使用局部内部类功能</li><li>C:局部内部类访问局部变量必须用final修饰<ul><li>为什么呢?<ul><li>因为局部变量会随着方法的调用完毕而消失，这个时候，局部对象并没有立马从堆内存中消失，还要使用那个变量。 为了让数据还能继续被使用，就用fianl修饰，这样，在堆内存里面存储的其实是一个常量值。</li><li>当我们添加了final其实就是延长了生命周期 , 其实就是一个常量 , 常量在常量池中 , 在方法区中</li></ul></li></ul></li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><h4 id="匿名内部类的格式和理解"><a href="#匿名内部类的格式和理解" class="headerlink" title="匿名内部类的格式和理解"></a>匿名内部类的格式和理解</h4><ul><li>A:匿名内部类:    就是局部内部类的简化写法。</li><li>B:前提：            存在一个类或者接口;这里的类可以是具体类也可以是抽象类。</li><li>C:格式：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 类名或者接口名()&#123;</span><br><span class="line">     重写方法;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure></li></ul><h4 id="本质是什么呢"><a href="#本质是什么呢" class="headerlink" title="本质是什么呢?"></a>本质是什么呢?</h4><ul><li>是一个继承了该类或者实现了该接口的子类匿名对象。</li><li>匿名内部类的面试题<ul><li>A:面试题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">按照要求，补齐代码</span><br><span class="line">interface Inter &#123; void show(); &#125;</span><br><span class="line">class Outer &#123; //补齐代码 &#125;</span><br><span class="line">class OuterDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Outer.method().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">要求在控制台输出”HelloWorld”</span><br><span class="line"></span><br><span class="line">- 答案</span><br><span class="line">//补齐代码</span><br><span class="line">public static Inter method() &#123;</span><br><span class="line">    //匿名内部类</span><br><span class="line">    return new Inter() &#123;</span><br><span class="line">        public void show()&#123;</span><br><span class="line">            System.out.println(&quot;HelloWorld&quot;) ;</span><br><span class="line">        &#125; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="包的定义及package"><a href="#包的定义及package" class="headerlink" title="包的定义及package"></a>包的定义及package</h3><h4 id="package关键字的概述及作用"><a href="#package关键字的概述及作用" class="headerlink" title="package关键字的概述及作用"></a>package关键字的概述及作用</h4><ul><li>A:包的概述:    就是文件夹</li><li>B:包的作用:    用来解决同一个路径下不能存在同名文件的问题(分类管理)</li><li>C:包的划分:    按照功能,按照模块</li></ul><h4 id="包的定义及注意事项"><a href="#包的定义及注意事项" class="headerlink" title="包的定义及注意事项"></a>包的定义及注意事项</h4><ul><li>A:定义包的格式<ul><li>package 包名;</li><li>多级包用.分开即可</li></ul></li><li>B:定义包的注意事项<ul><li>A:package语句必须是程序的第一条可执行的代码</li><li>B:package语句在一个java文件中只能有一个</li><li>C:如果没有package，默认表示无包名</li></ul></li></ul><h3 id="import关键字的概述和使用"><a href="#import关键字的概述和使用" class="headerlink" title="import关键字的概述和使用"></a>import关键字的概述和使用</h3><h4 id="A-导包的概述"><a href="#A-导包的概述" class="headerlink" title="A:导包的概述"></a>A:导包的概述</h4><ul><li>不同包下的类之间的访问，我们发现，每次使用不同包下的类的时候，都需要加包的全路径。比较麻烦。这个时候，java就提供了导包的功能</li></ul><h4 id="B-导包格式"><a href="#B-导包格式" class="headerlink" title="B:导包格式"></a>B:导包格式</h4><ul><li>import 包名;</li><li>注意：</li><li>这种方式导入是到类的名称。</li><li>虽然可以最后写*，但是不建议。</li></ul><h3 id="四种权限修饰符的测试"><a href="#四种权限修饰符的测试" class="headerlink" title="四种权限修饰符的测试"></a>四种权限修饰符的测试</h3><ul><li>修饰符<ul><li>四种权限修饰符: private(私有的)  , 默认 , protected(受保护的) , public(公共的)</li></ul></li><li>结论<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*            本类   同一个包下  不同包下(子类) 不同包下(无关类)</span><br><span class="line">* private      Y       </span><br><span class="line">* 默认         Y       Y</span><br><span class="line">* protected    Y       Y          Y</span><br><span class="line">* public       Y       Y          Y           Y</span><br></pre></td></tr></table></figure></li></ul><h3 id="类及其组成所使用的常见修饰符"><a href="#类及其组成所使用的常见修饰符" class="headerlink" title="类及其组成所使用的常见修饰符"></a>类及其组成所使用的常见修饰符</h3><ul><li><strong>A:修饰符：</strong><ul><li>权限修饰符：private，默认的，protected，public</li><li>状态修饰符：static，final</li><li>抽象修饰符：abstract</li></ul></li><li><strong>B:类：</strong><ul><li>权限修饰符：默认修饰符，public</li><li>状态修饰符：final</li><li>抽象修饰符：abstract</li><li>用的最多的就是：public</li></ul></li><li><strong>C:成员变量：</strong><ul><li>权限修饰符：private，默认的，protected，public</li><li>状态修饰符：static，final</li><li>用的最多的就是：private</li></ul></li><li><strong>D:构造方法：</strong><ul><li>权限修饰符：private，默认的，protected，public</li><li>用的最多的就是：public</li></ul></li><li><strong>E:成员方法：</strong><ul><li>权限修饰符：private，默认的，protected，public</li><li>状态修饰符：static，final</li><li>抽象修饰符：abstract</li><li>用的最多的就是：public</li></ul></li><li><strong>F:除此以外的组合规则：</strong><ul><li>成员变量： public static final</li><li>成员方法： public static / public abstract  /  public final</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内部类概述和访问特点&quot;&gt;&lt;a href=&quot;#内部类概述和访问特点&quot; class=&quot;headerlink&quot; title=&quot;内部类概述和访问特点&quot;&gt;&lt;/a&gt;内部类概述和访问特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:内部类概述:   &lt;ul&gt;
&lt;li&gt;把类定义在其他类的内部，
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="class" scheme="https://Cool-Loong.github.io/tags/class/"/>
    
      <category term="package" scheme="https://Cool-Loong.github.io/tags/package/"/>
    
  </entry>
  
  <entry>
    <title>java抽象类和接口</title>
    <link href="https://Cool-Loong.github.io/2019/02/22/java%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"/>
    <id>https://Cool-Loong.github.io/2019/02/22/java抽象类和接口/</id>
    <published>2019-02-22T06:40:37.000Z</published>
    <updated>2019-02-22T06:43:05.868Z</updated>
    
    <content type="html"><![CDATA[<h3 id="抽象类特点"><a href="#抽象类特点" class="headerlink" title="抽象类特点"></a>抽象类特点</h3><ul><li>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</li><li>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractClassExample &#123;</span><br><span class="line"></span><br><span class="line">    protected int x;</span><br><span class="line">    private int y;</span><br><span class="line"></span><br><span class="line">    public abstract void func1();</span><br><span class="line"></span><br><span class="line">    public void func2() &#123;</span><br><span class="line">        System.out.println(&quot;func2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AbstractExtendClassExample extends AbstractClassExample &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        System.out.println(&quot;func1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接口特点"><a href="#接口特点" class="headerlink" title="接口特点"></a>接口特点</h3><ul><li>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</li><li>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</li><li>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</li><li>接口的字段默认都是 static 和 final 的。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface InterfaceExample &#123;</span><br><span class="line"></span><br><span class="line">    void func1();</span><br><span class="line"></span><br><span class="line">    default void func2()&#123;</span><br><span class="line">        System.out.println(&quot;func2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int x = 123;</span><br><span class="line">    public int z = 0;       // Modifier &apos;public&apos; is redundant for interface fields</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InterfaceImplementExample implements InterfaceExample &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void func1() &#123;</span><br><span class="line">        System.out.println(&quot;func1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><ul><li>使用接口：<ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul></li><li>使用抽象类：<ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul></li></ul><h3 id="面向对象之类名作为形式参数"><a href="#面向对象之类名作为形式参数" class="headerlink" title="面向对象之类名作为形式参数"></a>面向对象之类名作为形式参数</h3><ul><li>案例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/*要的都是对象具体类的作为参数传递的问题*/</span><br><span class="line">class Student &#123;</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;student.....show.............&quot;) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class StudentDemo &#123;</span><br><span class="line">    public void method(Student s) &#123;</span><br><span class="line">        s.show() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">class ArgsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建StudentDemo的对象</span><br><span class="line">        StudentDemo sd = new StudentDemo() ;</span><br><span class="line">        // 创建Student的对象</span><br><span class="line">        Student s = new Student() ;</span><br><span class="line">        // 调用方法</span><br><span class="line">        // sd.method(s) ;</span><br><span class="line">        sd.method(new Student()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面向对象之抽象类名作为形式参数"><a href="#面向对象之抽象类名作为形式参数" class="headerlink" title="面向对象之抽象类名作为形式参数"></a>面向对象之抽象类名作为形式参数</h3><ul><li>案例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/*抽象类作为参数的时候如何进行调用*/</span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">    // 定义一个抽象方法</span><br><span class="line">    public abstract void eat() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个类</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;吃.................&quot;) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义一个类</span><br><span class="line">class AnimalDemo &#123;</span><br><span class="line">    public void method(Animal a) &#123;</span><br><span class="line">        a.eat() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">class ArgsDemo2  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建AnimalDemo的对象</span><br><span class="line">        AnimalDemo ad = new AnimalDemo() ;</span><br><span class="line">        // 对Animal进行间接实例化</span><br><span class="line">        // Animal a = new Cat() ;</span><br><span class="line">        Cat a = new Cat() ;</span><br><span class="line">        // 调用method方法</span><br><span class="line">        ad.method(a) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面向对象之接口名作为形式参数"><a href="#面向对象之接口名作为形式参数" class="headerlink" title="面向对象之接口名作为形式参数"></a>面向对象之接口名作为形式参数</h3><ul><li>案例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/*接口作为参数的时候我们如何进行调用*/</span><br><span class="line">interface Jump &#123;</span><br><span class="line">    // 跳高接口</span><br><span class="line">    public abstract void jump() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个子类</span><br><span class="line">class JumpImpl implements Jump &#123;</span><br><span class="line">    public void jump()&#123;</span><br><span class="line">        System.out.println(&quot;jump.............................&quot;) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个类</span><br><span class="line">class JumpDemo &#123;</span><br><span class="line">    public void method(Jump jump) &#123;</span><br><span class="line">        jump.jump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">class ArgsDemo3  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 1. 创建JumpDemo对象</span><br><span class="line">        JumpDemo jd = new JumpDemo() ;</span><br><span class="line">        // 2. 调用method方法</span><br><span class="line">        // 对Jump进行间接实例化</span><br><span class="line">        Jump jump = new JumpImpl() ;</span><br><span class="line">        jd.method(jump) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面向对象之类名作为返回值类型"><a href="#面向对象之类名作为返回值类型" class="headerlink" title="面向对象之类名作为返回值类型"></a>面向对象之类名作为返回值类型</h3><ul><li>案例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*具体类作为返回值类型*/</span><br><span class="line">class Student &#123;</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;student....show.....................&quot;) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个类</span><br><span class="line">class StudentDemo &#123;</span><br><span class="line">    public Student getStudent() &#123;</span><br><span class="line">        return new Student() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">class ReturnDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建StudentDemo的对象</span><br><span class="line">        StudentDemo sd = new StudentDemo() ;</span><br><span class="line">        // 调用 public Student getStudent()</span><br><span class="line">        Student s = sd.getStudent() ;</span><br><span class="line">        // 调用方法</span><br><span class="line">        s.show() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面向对象之抽象类名作为返回值类型"><a href="#面向对象之抽象类名作为返回值类型" class="headerlink" title="面向对象之抽象类名作为返回值类型"></a>面向对象之抽象类名作为返回值类型</h3><ul><li>案例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*抽象类作为返回值类型*/</span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">    public abstract void eat() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个子类</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(&quot;吃..........................&quot;) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个类</span><br><span class="line">class AnimalDemo &#123;</span><br><span class="line">    public static Animal getAnimal() &#123;   </span><br><span class="line">        // Animal a = new Cat() ;</span><br><span class="line">        // return a;</span><br><span class="line">        return new Cat() ;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">class ReturnDemo2  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 调用AnimalDemo的getAnimal这个方法</span><br><span class="line">        Animal a =  AnimalDemo.getAnimal() ;</span><br><span class="line">        // 调用方法</span><br><span class="line">        a.eat() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="面向对象之接口名作为返回值类型"><a href="#面向对象之接口名作为返回值类型" class="headerlink" title="面向对象之接口名作为返回值类型"></a>面向对象之接口名作为返回值类型</h3><ul><li>案例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*接口作为返回值类型*/</span><br><span class="line">interface Jump &#123;</span><br><span class="line">    public abstract void jump() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个子类</span><br><span class="line">class JumpImpl implements Jump &#123;</span><br><span class="line">    public void jump()&#123;</span><br><span class="line">        System.out.println(&quot;jum....................&quot;) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个类</span><br><span class="line">class JumpDemo &#123;</span><br><span class="line">    public static Jump getJump() &#123;</span><br><span class="line">        return new JumpImpl() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试类</span><br><span class="line">class ReturnDemo3  &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 调用getJump方法</span><br><span class="line">        Jump jump = JumpDemo.getJump() ;</span><br><span class="line">        // 调用</span><br><span class="line">        jump.jump() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;抽象类特点&quot;&gt;&lt;a href=&quot;#抽象类特点&quot; class=&quot;headerlink&quot; title=&quot;抽象类特点&quot;&gt;&lt;/a&gt;抽象类特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="abstract" scheme="https://Cool-Loong.github.io/tags/abstract/"/>
    
      <category term="interface" scheme="https://Cool-Loong.github.io/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>java面向对象知识点</title>
    <link href="https://Cool-Loong.github.io/2019/02/22/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://Cool-Loong.github.io/2019/02/22/java面向对象知识点/</id>
    <published>2019-02-22T02:18:58.000Z</published>
    <updated>2019-02-22T06:38:41.224Z</updated>
    
    <content type="html"><![CDATA[<h4 id="面向对象的思想"><a href="#面向对象的思想" class="headerlink" title="面向对象的思想"></a>面向对象的思想</h4><ul><li><strong>面向对象的思想</strong></li></ul><blockquote><p>  A:面向过程思想概述</p><blockquote><p>  我们来回想一下，这几天我们完成一个需求的步骤：首先是搞清楚我们要做什么，然后在分析怎么做，最后我们再代码体现。<br>            一步一步去实现，而具体的每一步都需要我们去实现和操作。这些步骤相互调用和协作，完成我们的需求。<br>            在上面的每一个具体步骤中我们都是参与者，并且需要面对具体的每一个步骤和过程，这就是面向过程最直接的体现。<br>            那么什么是面向过程开发呢? 面向过程开发，其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。<br>            面向过程的代表语言：C语言</p></blockquote></blockquote><blockquote><p>B:面向对象思想概述</p><blockquote><p>  当需求单一，或者简单时，我们一步一步去操作没问题，并且效率也挺高。<br>            可随着需求的更改，功能的增多，发现需要面对每一个步骤很麻烦了。这时就开始思索，<br>            能不能把这些步骤和功能在进行封装，封装时根据不同的功能，进行不同的封装，功能类似的封装在一起。<br>            这样结构就清晰了很多。用的时候，找到对应的类就可以了。这就是面向对象的思想。</p></blockquote></blockquote><blockquote><p>  C:面向对象思想特点</p><blockquote><p>a:是一种更符合我们思想习惯的思想<br>        b:可以将复杂的事情简单化<br>        c:将我们从执行者变成了指挥者，角色发生了转换</p></blockquote></blockquote><ul><li><strong>面向对象的特征</strong></li><li>有三个特征<ul><li>封装</li><li>继承</li><li>多态</li></ul></li></ul><h4 id="类与对象及其应用"><a href="#类与对象及其应用" class="headerlink" title="类与对象及其应用"></a>类与对象及其应用</h4><ul><li><strong>描述现实世界事物</strong></li><li>描述学生事务<ul><li>属性：姓名，年龄，性别</li><li>行为：学习，吃饭，睡觉</li><li>属性：就是该事物的描述信息【成员变量】</li><li>行为：就是该事物能够做什么【成员方法】</li></ul></li></ul><ul><li><strong>类和对象的概念</strong><ul><li>a:类：是一组相关的属性和行为的集合</li><li>b:对象：是该类事物的具体体现</li><li>c:举例：<ul><li>类    学生</li><li>对象    班长就是一个对象</li></ul></li></ul></li></ul><h4 id="对象的内存图"><a href="#对象的内存图" class="headerlink" title="对象的内存图"></a>对象的内存图</h4><ul><li><strong>创建对象过程</strong><ul><li>(1):加载A.class文件进内存</li><li>(2):在栈内存为s开辟空间</li><li>(3):在堆内存为学生对象开辟空间</li><li>(4):对学生对象的成员变量进行默认初始化</li><li>(5):对学生对象的成员变量进行显示初始化</li><li>(6):通过构造方法对学生对象的成员变量赋值</li><li>(7):学生对象初始化完毕，把对象地址赋值给s变量</li></ul></li></ul><ul><li><strong> 一个对象的内存图</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-e4c71acc1249a4c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><ul><li><strong>二个对象的内存图</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-9ff740d90e7c286b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><ul><li><strong> 三个对象的内存图</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-309a3d5d84512dd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><ul><li><strong> A:在类中的位置不同</strong><ul><li>成员变量：在类中方法外</li><li>局部变量：在方法定义中或者方法声明上</li></ul></li></ul><ul><li><strong> B:在内存中的位置不同</strong><ul><li>成员变量：在堆内存</li><li>局部变量：在栈内存</li></ul></li></ul><ul><li><strong> C:生命周期不同</strong><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li></ul></li></ul><ul><li><strong> D:初始化值不同</strong><ul><li>成员变量：有默认初始化值</li><li>局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。</li><li>注意事项：: 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</li></ul></li></ul><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><ul><li><strong> 什么是匿名对象</strong><ul><li>就是没有名字的对象</li></ul></li></ul><ul><li><strong>匿名对象应用场景</strong><ul><li>a:调用方法，仅仅只调用一次的时候。</li><li>b:匿名对象可以作为实际参数传递</li></ul></li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li><strong>封装的概述</strong></li><li>封装概述<ul><li>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</li></ul></li><li>封装好处<ul><li>隐藏实现细节，提供公共的访问方式</li><li>提高代码复用性</li><li>提高安全性[禁止对象之间的不良交互提高模块化]</li></ul></li><li>封装原则<ul><li>将不需要对外提供的内容都隐藏起来。</li><li>把属性隐藏，提供公共方法对其访问。</li></ul></li><li>案例展示<ul><li>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</li><li>注意到gender属性使用int数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int gender;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getGender() &#123;</span><br><span class="line">        return gender == 0 ? &quot;man&quot; : &quot;woman&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void work() &#123;</span><br><span class="line">        if (18 &lt;= age &amp;&amp; age &lt;= 50) &#123;</span><br><span class="line">            System.out.println(name + &quot; is working very hard!&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(name + &quot; can&apos;t work any more!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="面向对象之private关键字"><a href="#面向对象之private关键字" class="headerlink" title="面向对象之private关键字"></a>面向对象之private关键字</h4><ul><li>private关键字特点<ul><li>是一个权限修饰符</li><li>可以修饰成员变量和成员方法</li><li>被其修饰的成员只能在本类中被访问</li></ul></li><li>private最常见的应用<ul><li>把成员变量用private修饰，提供对应的getXxx()和setXxx()方法</li></ul></li></ul><h4 id="面向对象之this关键字"><a href="#面向对象之this关键字" class="headerlink" title="面向对象之this关键字"></a>面向对象之this关键字</h4><ul><li>为什么要有this<ul><li>当我们的局部变量和成员变量相同的时候,如果我们不使用this关键字,那么会导致一个问题:就是局部变量隐藏了成员变量的问题</li></ul></li><li>this关键字特点<ul><li>是当前类的对象引用</li><li>简单的记，它就代表当前类的一个对象。谁调用这个方法,那么该方法的内部的this就代表谁</li></ul></li><li>this的应用场景<ul><li>解决局部变量隐藏成员变量</li></ul></li></ul><h4 id="面向对象之构造方法"><a href="#面向对象之构造方法" class="headerlink" title="面向对象之构造方法"></a>面向对象之构造方法</h4><ul><li>构造方法概述和作用<ul><li>给对象中的成员进行初始化</li></ul></li><li>构造方法格式特点<ul><li>方法名与类名相同；没有返回值类型，连void都没有</li></ul></li><li>构造方法注意事项<ul><li>如果我们没有给出构造方法，系统将自动提供一个无参构造方法。</li><li>如果我们给出了构造方法，系统将不再提供默认的无参构造方法。<ul><li>注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法</li></ul></li></ul></li></ul><h4 id="创建对象的步骤"><a href="#创建对象的步骤" class="headerlink" title="创建对象的步骤"></a>创建对象的步骤</h4><ul><li>对象的创建步骤<ul><li>(1):加载A.class文件进内存</li><li>(2):在栈内存为s开辟空间</li><li>(3):在堆内存为学生对象开辟空间</li><li>(4):对学生对象的成员变量进行默认初始化</li><li>(5):对学生对象的成员变量进行显示初始化</li><li>(6):通过构造方法对学生对象的成员变量赋值</li><li>(7):学生对象初始化完毕，把对象地址赋值给s变量</li></ul></li></ul><h4 id="面向对象之static关键字的特点"><a href="#面向对象之static关键字的特点" class="headerlink" title="面向对象之static关键字的特点"></a>面向对象之static关键字的特点</h4><ul><li><strong>static关键字的特点</strong><ul><li>随着类的加载而加载</li><li>优先于对象存在</li><li>被类的所有对象共享</li><li>可以通过类名调用【静态修饰的内容一般我们称其为：与类相关的，类成员】</li></ul></li><li><strong>static的注意事项</strong><ul><li>在静态方法中是没有this关键字的<ul><li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li><li>静态比对象先存在。</li></ul></li><li>静态方法只能访问静态的成员变量和静态的成员方法【静态只能访问静态,非静态可以访问静态的也可以访问非静态的】</li></ul></li></ul><h4 id="静态变量和成员变量的区别"><a href="#静态变量和成员变量的区别" class="headerlink" title="静态变量和成员变量的区别"></a>静态变量和成员变量的区别</h4><ul><li>A:所属不同<ul><li>静态变量属于类，所以也称为类变量</li><li>成员变量属于对象，所以也称为实例变量(对象变量)</li></ul></li><li>B:内存中位置不同<ul><li>静态变量存储于方法区的静态区</li><li>成员变量存储于堆内存</li></ul></li><li>C:内存出现时间不同<ul><li>静态变量随着类的加载而加载，随着类的消失而消失</li><li>成员变量随着对象的创建而存在，随着对象的消失而消失</li></ul></li><li>D:调用不同<ul><li>静态变量可以通过类名调用，也可以通过对象调用</li><li>成员变量只能通过对象名调用</li></ul></li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ul><li>A:代码块概述<ul><li>在Java中，使用{}括起来的代码被称为代码块。</li></ul></li><li>B:代码块分类<ul><li>根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块。</li></ul></li><li>C:常见代码块的应用<ul><li>a:局部代码块<ul><li>在方法中出现；限定变量生命周期，及早释放，提高内存利用率</li></ul></li><li>b:构造代码块<ul><li>在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li></ul></li><li>c:静态代码块<ul><li>在类中方法外出现，加了static修饰</li><li>在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。</li></ul></li></ul></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li><strong>继承概述</strong><ul><li>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li></ul></li><li><strong>继承格式</strong><ul><li>通过extends关键字可以实现类与类的继承</li><li>class 子类名 extends 父类名 {} </li><li>单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类</li></ul></li><li><strong>继承的好处</strong><ul><li>a:提高了代码的复用性</li><li>b:提高了代码的维护性</li><li>c:让类与类之间产生了关系，是多态的前提</li></ul></li><li><strong>继承的弊端</strong><ul><li>类的耦合性增强了。</li><li>开发的原则：高内聚，低耦合。</li><li>耦合：类与类的关系</li><li>内聚：就是自己完成某件事情的能力</li></ul></li><li><strong>继承的注意事项</strong><ul><li>a:子类只能继承父类所有非私有的成员(成员方法和成员变量)</li><li>b:子类不能继承父类的构造方法，但是可以通过super(待会儿讲)关键字去访问父类构造方法。</li><li>c:不要为了部分功能而去继承</li></ul></li><li><strong>继承中成员变量的关系</strong><ul><li>A:子类中的成员变量和父类中的成员变量名称不一样</li><li>B:子类中的成员变量和父类中的成员变量名称一样</li><li>在子类中访问一个变量的查找顺序(“就近原则”)<ul><li>a: 在子类的方法的局部范围找,有就使用</li><li>b: 在子类的成员范围找,有就使用</li><li>c: 在父类的成员范围找,有就使用<ul><li>d:如果还找不到,就报错</li></ul></li></ul></li></ul></li><li><strong>继承中构造方法的注意事项</strong><ul><li>父类没有无参构造方法,子类怎么办?<ul><li>a: 在父类中添加一个无参的构造方法</li><li>b:子类通过super去显示调用父类其他的带参的构造方法</li><li>c:子类通过this去调用本类的其他构造方法</li><li>本类其他构造也必须首先访问了父类构造</li></ul></li><li>B:注意事项<ul><li>super(…)或者this(….)必须出现在第一条语句上</li></ul></li></ul></li></ul><h4 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h4><ul><li><strong>A:通过问题引出super</strong><ul><li>子类局部范围访问父类成员变量</li></ul></li><li><strong>B:说说this和super的区别</strong><ul><li>this     代表的是本类对象的引用</li><li>super     代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员)</li></ul></li><li><strong>C:this和super的使用</strong><ul><li>a:调用成员变量<ul><li>this.成员变量     调用本类的成员变量</li><li>super.成员变量     调用父类的成员变量</li></ul></li><li>b:调用构造方法<ul><li>this(…)        调用本类的构造方法</li><li>super(…)        调用父类的构造方法</li></ul></li><li>c:调用成员方法<ul><li>this.成员方法     调用本类的成员方法</li><li>super.成员方法     调用父类的成员方法</li></ul></li></ul></li></ul><h4 id="方法重写，方法重载"><a href="#方法重写，方法重载" class="headerlink" title="方法重写，方法重载"></a>方法重写，方法重载</h4><ul><li><strong>方法重写</strong></li><li><strong>A:什么是方法重写</strong><ul><li>子类中出现了和父类中一模一样的方法声明(方法名,参数列表,返回值类型)，也被称为方法覆盖，方法复写。</li></ul></li><li>B: Override和Overload的区别?Overload能改变返回值类型吗?</li><li><strong>C:方法重写的应用</strong><ul><li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。</li><li>这样，即沿袭了父类的功能，又定义了子类特有的内容。</li></ul></li><li><strong>方法重写注意事项</strong><ul><li>a:父类中私有方法不能被重写 ，因为父类私有方法子类根本就无法继承</li><li>b:子类重写父类方法时，访问权限不能更低 ，最好就一致</li><li>c:父类静态方法，子类也必须通过静态方法进行重写 ，其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解</li></ul></li></ul><ul><li><strong>方法重载</strong></li><li>A.什么是方法重载？</li><li>一个类中，有若干个方法名字相同，但方法参数形式不同，成为方法重载</li><li>B.方法重载原则？</li><li>方法名相同；方法的参数类型不同，或者参数个数不同；与方法的参数名，返回类型和修饰符无关</li></ul><h4 id="final关键字概述"><a href="#final关键字概述" class="headerlink" title="final关键字概述"></a>final关键字概述</h4><ul><li><strong>A:为什么会有final</strong><ul><li>由于继承中有一个方法重写的现象,而有时候我们不想让子类去重写父类的方法.这对这种情况java就给我们提供了一个关键字: final</li></ul></li><li><strong>B:final概述</strong><ul><li>final关键字是最终的意思，可以修饰类，变量，成员方法。</li></ul></li><li><strong>C:final修饰特点</strong><ul><li>修饰类:    被修饰类不能被继承</li><li>修饰方法:    被修饰的方法不能被重写</li><li>修饰变量:    被修饰的变量不能被重新赋值,因为这个量其实是一个常量</li></ul></li><li><strong>D:final关键字修饰局部变量 </strong>     <ul><li>基本类型，是值不能被改变</li><li>引用类型，是地址值不能被改变</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;面向对象的思想&quot;&gt;&lt;a href=&quot;#面向对象的思想&quot; class=&quot;headerlink&quot; title=&quot;面向对象的思想&quot;&gt;&lt;/a&gt;面向对象的思想&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向对象的思想&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockqu
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="extends" scheme="https://Cool-Loong.github.io/tags/extends/"/>
    
  </entry>
  
  <entry>
    <title>java异常</title>
    <link href="https://Cool-Loong.github.io/2019/02/21/java%E5%BC%82%E5%B8%B8/"/>
    <id>https://Cool-Loong.github.io/2019/02/21/java异常/</id>
    <published>2019-02-21T06:55:50.000Z</published>
    <updated>2019-02-21T08:50:48.509Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解-Throwable、Exception、Error-的分类"><a href="#理解-Throwable、Exception、Error-的分类" class="headerlink" title="理解 Throwable、Exception、Error 的分类"></a>理解 Throwable、Exception、Error 的分类</h3><p><img src="https://upload-images.jianshu.io/upload_images/4432347-246194d0356632f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="请对比Exception和-Error，运行时异常与一般异常有什么区别？"><a href="#请对比Exception和-Error，运行时异常与一般异常有什么区别？" class="headerlink" title="请对比Exception和 Error，运行时异常与一般异常有什么区别？"></a>请对比Exception和 Error，运行时异常与一般异常有什么区别？</h3><h4 id="Exception-和-Error不同之处"><a href="#Exception-和-Error不同之处" class="headerlink" title="Exception 和 Error不同之处"></a>Exception 和 Error不同之处</h4><ul><li>Exception<ul><li>1．可以是可被控制(checked) 或不可控制的(unchecked)。</li><li>2．表示一个由程序员导致的错误。</li><li>3．应该在应用程序级被处理。</li></ul></li><li>Error<ul><li>1．总是不可控制的(unchecked)。</li><li>2．经常用来用于表示系统错误或低层资源的错误。</li><li>3．如何可能的话，应该在系统级被捕捉。</li></ul></li><li>概括<ul><li>异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</li></ul></li></ul><h3 id="程序出现异常，但是没有捕获到信息"><a href="#程序出现异常，但是没有捕获到信息" class="headerlink" title="程序出现异常，但是没有捕获到信息"></a>程序出现异常，但是没有捕获到信息</h3><h4 id="程序明明出现了异常，也catch（Exception-e）了，却没有捕获到任何信息。"><a href="#程序明明出现了异常，也catch（Exception-e）了，却没有捕获到任何信息。" class="headerlink" title="程序明明出现了异常，也catch（Exception e）了，却没有捕获到任何信息。"></a>程序明明出现了异常，也catch（Exception e）了，却没有捕获到任何信息。</h4><ul><li><strong>原因无非有两个：</strong><ul><li>1.异常所在的线程跟你捕获的线程不是同一个线程;</li><li>2.程序抛出的不是Exception而是Error。Error跟Exception一样都继承自Throwable，是指不应该被捕获的严重错误。</li></ul></li><li><strong>为什么不该捕获Error呢？</strong><ul><li>因为出现Error的情况会造成程序直接无法运行，所以捕获了也没有任何意义</li></ul></li></ul><h3 id="一旦某个catch捕获到匹配的异常类，其它的catch还会执行吗？"><a href="#一旦某个catch捕获到匹配的异常类，其它的catch还会执行吗？" class="headerlink" title="一旦某个catch捕获到匹配的异常类，其它的catch还会执行吗？"></a>一旦某个catch捕获到匹配的异常类，其它的catch还会执行吗？</h3><ul><li>一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</li><li>对于有多个catch子句的异常程序而言，应该尽量将捕获底层异常类的catch子 句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获底层异常类的catch子句将可能会被屏蔽。</li><li>举个例子：RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在 最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。</li></ul><h3 id="异常思维导图"><a href="#异常思维导图" class="headerlink" title="异常思维导图"></a>异常思维导图</h3><p><img src="https://upload-images.jianshu.io/upload_images/4432347-78a464137c7f1d26.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h3><ul><li><strong> 什么是异常?</strong><ul><li>异常是正常程序流程所不能处理或者没有处理的异常情况或异常事件，比如算术运算被0除，数组下标越界等。</li><li>Java采用try-catch-finally语句捕获并处理异常并且处理异常。</li></ul></li></ul><ul><li><strong> finally一定会执行吗</strong><ul><li>finally是异常处理的统一出口，常用来实现资源释放，比如关闭文件，关于数据库连接等。除非遇到System.exit()强制退出程序外，finally语句块无论是否发生异常都要执行。</li></ul></li></ul><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2.异常"></a>2.异常</h3><ol><li><strong> 异常的概述和分类</strong><ul><li>A:异常的概述:    异常就是Java程序在运行过程中出现的错误。</li><li>B:异常的分类:    </li><li>C:异常的继承体系<ul><li>异常的基类:    Throwable</li><li>严重问题:    Error    不予处理,因为这种问题一般是很严重的问题,比如: 内存溢出</li><li>非严重问题:    Exception<ul><li>编译时异常:  非RuntimeException</li><li>运行时异常:  RuntimeException</li></ul></li></ul></li></ul></li></ol><ol start="2"><li><strong> JVM默认是如何处理异常的</strong><ul><li>JVM默认是如何处理异常的<ol><li>main函数收到这个问题时,有两种处理方式:<ul><li>a:自己将该问题处理,然后继续运行</li><li>b:自己没有针对的处理方式,只有交给调用main的jvm来处理</li></ul></li><li>jvm有一个默认的异常处理机制,就将该异常进行处理.</li><li>并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行</li></ol></li></ul></li></ol><ol start="3"><li><strong> 异常处理的两种方式</strong><ul><li>try…catch…finally</li><li>throws</li></ul></li></ol><ol start="4"><li><p><strong> try…catch的方式处理异常【掌握】</strong></p><ul><li>try…catch处理异常的基本格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try    &#123;</span><br><span class="line">    可能出现问题的代码 ;</span><br><span class="line">&#125;catch(异常名 变量名)&#123;</span><br><span class="line">    针对问题的处理 ;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    释放资源;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意事项:</p><ul><li>a：try中的代码越少越好</li><li>b：catch中要做处理,哪怕是一条输出语句也可以.(不能将异常信息隐藏)</li><li>c：处理多个异常<ul><li>1:能明确的尽量明确，不要用大的来处理。</li><li>2:平级关系的异常谁前谁后无所谓，如果出现了子父关系，父必须在后面。</li></ul></li></ul></li></ol><ol start="6"><li><strong> 编译期异常和运行期异常的区别【理解】</strong><ul><li>编译期异常和运行期异常的区别</li><li>Java中的异常被分为两大类：编译时异常和运行时异常。<ul><li>所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常</li><li>编译时异常:    Java程序必须显示处理，否则程序就会发生错误，无法通过编译</li><li>运行时异常:    无需显示处理，也可以和编译时异常一样处理</li></ul></li></ul></li></ol><ol start="7"><li><p><strong> throw的概述以及和throws的区别【掌握】</strong></p><ul><li>throws的方式处理异常:<br>  定义功能方法时，需要把出现的问题暴露出来让调用者去处理。那么就通过throws在方法上标识。</li><li>throw的概述:<br>  在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。</li></ul><ul><li><strong>a:throws</strong></li></ul><ol><li>用在方法声明后面，跟的是异常类名</li><li>可以跟多个异常类名，用逗号隔开</li><li>表示抛出异常，由该方法的调用者来处理</li><li><p>throws表示出现异常的一种可能性，并不一定会发生这些异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void pop() throws NegativeArraySizeException &#123;</span><br><span class="line">// 定义方法并抛出NegativeArraySizeException异常</span><br><span class="line">int[] arr = new int[-3]; // 创建数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; // 主方法</span><br><span class="line">try &#123; // try语句处理异常信息</span><br><span class="line">pop(); // 调用pop()方法</span><br><span class="line">&#125; catch (NegativeArraySizeException e) &#123;</span><br><span class="line">System.out.println(&quot;pop()方法抛出的异常&quot;);// 输出异常信息</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。</p></li></ol><ul><li><strong>b:throw</strong></li></ul><ul><li>用在方法体内，跟的是异常对象名</li><li>只能抛出一个异常对象名</li><li>表示抛出异常，由方法体内的语句处理  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public PlayService getPlayService() &#123;</span><br><span class="line">    PlayService playService = BaseAppHelper.get().getPlayService();</span><br><span class="line">    if (playService == null) &#123;</span><br><span class="line">        //待解决：当长期处于后台，如何保活？避免service被杀死……</span><br><span class="line">        throw new NullPointerException(&quot;play service is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return playService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><strong> 异常的注意事项及如何使用异常处理【了解】</strong><ul><li>A:异常注意事项(针对编译期异常)<ul><li>a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)</li><li>b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</li><li>c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</li></ul></li><li>B:如何使用异常处理<ul><li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li><li>区别:<ul><li>后续程序需要继续运行就try</li><li>后续程序不需要继续运行就throws</li><li>如果JDK没有提供对应的异常，需要自定义异常。</li></ul></li></ul></li></ul></li></ul><h4 id="Throwable类中的常用方法"><a href="#Throwable类中的常用方法" class="headerlink" title="Throwable类中的常用方法"></a>Throwable类中的常用方法</h4><ul><li>注意：catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。catch代码块中语句”e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:<ul><li>getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</li><li>getMeage()：返回异常的消息信息。</li><li>printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。</li></ul></li><li>有时为了简单会忽略掉catch语句后的代码，这样try-catch语句就成了一种摆设，一旦程序在运行过程中出现了异常，就会忽略处理异常，而错误发生的原因很难查找。</li></ul><h3 id="Error-错误"><a href="#Error-错误" class="headerlink" title="Error(错误)"></a>Error(错误)</h3><ul><li>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h3><ol><li>Exception（异常）:是程序本身可以处理的异常。</li><li>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。<ol><li>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</li><li>非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</li></ol></li></ol><h3 id="处理异常机制深入理解"><a href="#处理异常机制深入理解" class="headerlink" title="处理异常机制深入理解"></a>处理异常机制深入理解</h3><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><ul><li>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</li></ul><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><ul><li>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li></ul><h4 id="异常处理方式不同"><a href="#异常处理方式不同" class="headerlink" title="异常处理方式不同"></a>异常处理方式不同</h4><ul><li>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。<ul><li><strong>可查异常</strong>（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</li><li><strong>不可查异常</strong>(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。</li><li>总结：一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</li></ul></li><li><strong>处理运行时异常</strong><ul><li>由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</li></ul></li><li><strong>处理Error</strong><ul><li>对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</li></ul></li><li><strong>处理可查异常</strong><ul><li>对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</li></ul></li></ul><h3 id="异常总结"><a href="#异常总结" class="headerlink" title="异常总结"></a>异常总结</h3><h4 id="异常总结-1"><a href="#异常总结-1" class="headerlink" title="异常总结"></a>异常总结</h4><ol><li>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</li><li>catch 块：用于处理try捕获到的异常。</li><li>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：<br>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</li></ol><h4 id="try-catch-finally规则"><a href="#try-catch-finally规则" class="headerlink" title="try-catch-finally规则"></a>try-catch-finally规则</h4><ol><li>必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。</li><li>必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。</li><li>catch 块与相应的异常类的类型相关。</li><li>一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块</li><li>可嵌套 try-catch-finally 结构。</li><li>在 try-catch-finally 结构中，可重新抛出异常。</li><li>除了下列情况，总将执行 finally 做为结束：JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。</li></ol><h4 id="try、catch、finally语句块的执行顺序"><a href="#try、catch、finally语句块的执行顺序" class="headerlink" title="try、catch、finally语句块的执行顺序"></a>try、catch、finally语句块的执行顺序</h4><ol><li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li><li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li><li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li></ol><h4 id="Throws抛出异常的规则"><a href="#Throws抛出异常的规则" class="headerlink" title="Throws抛出异常的规则"></a>Throws抛出异常的规则</h4><ol><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol><li>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。</li><li>在程序中使用自定义异常类，大体可分为以下几个步骤。<ol><li>创建自定义异常类。</li><li>在方法中通过throw关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;理解-Throwable、Exception、Error-的分类&quot;&gt;&lt;a href=&quot;#理解-Throwable、Exception、Error-的分类&quot; class=&quot;headerlink&quot; title=&quot;理解 Throwable、Exception、Error
      
    
    </summary>
    
      <category term="java" scheme="https://Cool-Loong.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://Cool-Loong.github.io/tags/java/"/>
    
      <category term="Expection" scheme="https://Cool-Loong.github.io/tags/Expection/"/>
    
  </entry>
  
</feed>
