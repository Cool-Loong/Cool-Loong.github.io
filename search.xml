<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>java异常</title>
      <link href="/2019/02/21/java%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/02/21/java%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="理解-Throwable、Exception、Error-的分类"><a href="#理解-Throwable、Exception、Error-的分类" class="headerlink" title="理解 Throwable、Exception、Error 的分类"></a>理解 Throwable、Exception、Error 的分类</h3><p><img src="https://upload-images.jianshu.io/upload_images/4432347-246194d0356632f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="请对比Exception和-Error，运行时异常与一般异常有什么区别？"><a href="#请对比Exception和-Error，运行时异常与一般异常有什么区别？" class="headerlink" title="请对比Exception和 Error，运行时异常与一般异常有什么区别？"></a>请对比Exception和 Error，运行时异常与一般异常有什么区别？</h3><h4 id="Exception-和-Error不同之处"><a href="#Exception-和-Error不同之处" class="headerlink" title="Exception 和 Error不同之处"></a>Exception 和 Error不同之处</h4><ul><li>Exception<ul><li>1．可以是可被控制(checked) 或不可控制的(unchecked)。</li><li>2．表示一个由程序员导致的错误。</li><li>3．应该在应用程序级被处理。</li></ul></li><li>Error<ul><li>1．总是不可控制的(unchecked)。</li><li>2．经常用来用于表示系统错误或低层资源的错误。</li><li>3．如何可能的话，应该在系统级被捕捉。</li></ul></li><li>概括<ul><li>异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</li></ul></li></ul><h3 id="程序出现异常，但是没有捕获到信息"><a href="#程序出现异常，但是没有捕获到信息" class="headerlink" title="程序出现异常，但是没有捕获到信息"></a>程序出现异常，但是没有捕获到信息</h3><h4 id="程序明明出现了异常，也catch（Exception-e）了，却没有捕获到任何信息。"><a href="#程序明明出现了异常，也catch（Exception-e）了，却没有捕获到任何信息。" class="headerlink" title="程序明明出现了异常，也catch（Exception e）了，却没有捕获到任何信息。"></a>程序明明出现了异常，也catch（Exception e）了，却没有捕获到任何信息。</h4><ul><li><strong>原因无非有两个：</strong><ul><li>1.异常所在的线程跟你捕获的线程不是同一个线程;</li><li>2.程序抛出的不是Exception而是Error。Error跟Exception一样都继承自Throwable，是指不应该被捕获的严重错误。</li></ul></li><li><strong>为什么不该捕获Error呢？</strong><ul><li>因为出现Error的情况会造成程序直接无法运行，所以捕获了也没有任何意义</li></ul></li></ul><h3 id="一旦某个catch捕获到匹配的异常类，其它的catch还会执行吗？"><a href="#一旦某个catch捕获到匹配的异常类，其它的catch还会执行吗？" class="headerlink" title="一旦某个catch捕获到匹配的异常类，其它的catch还会执行吗？"></a>一旦某个catch捕获到匹配的异常类，其它的catch还会执行吗？</h3><ul><li>一旦某个catch捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个try-catch语句结束。其他的catch子句不再有匹配和捕获异常类型的机会。</li><li>对于有多个catch子句的异常程序而言，应该尽量将捕获底层异常类的catch子 句放在前面，同时尽量将捕获相对高层的异常类的catch子句放在后面。否则，捕获底层异常类的catch子句将可能会被屏蔽。</li><li>举个例子：RuntimeException异常类包括运行时各种常见的异常，ArithmeticException类和ArrayIndexOutOfBoundsException类都是它的子类。因此，RuntimeException异常类的catch子句应该放在 最后面，否则可能会屏蔽其后的特定异常处理或引起编译错误。</li></ul><h3 id="异常思维导图"><a href="#异常思维导图" class="headerlink" title="异常思维导图"></a>异常思维导图</h3><p><img src="https://upload-images.jianshu.io/upload_images/4432347-78a464137c7f1d26.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h3><ul><li><strong> 什么是异常?</strong><ul><li>异常是正常程序流程所不能处理或者没有处理的异常情况或异常事件，比如算术运算被0除，数组下标越界等。</li><li>Java采用try-catch-finally语句捕获并处理异常并且处理异常。</li></ul></li></ul><ul><li><strong> finally一定会执行吗</strong><ul><li>finally是异常处理的统一出口，常用来实现资源释放，比如关闭文件，关于数据库连接等。除非遇到System.exit()强制退出程序外，finally语句块无论是否发生异常都要执行。</li></ul></li></ul><h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2.异常"></a>2.异常</h3><ol><li><strong> 异常的概述和分类</strong><ul><li>A:异常的概述:    异常就是Java程序在运行过程中出现的错误。</li><li>B:异常的分类:    </li><li>C:异常的继承体系<ul><li>异常的基类:    Throwable</li><li>严重问题:    Error    不予处理,因为这种问题一般是很严重的问题,比如: 内存溢出</li><li>非严重问题:    Exception<ul><li>编译时异常:  非RuntimeException</li><li>运行时异常:  RuntimeException</li></ul></li></ul></li></ul></li></ol><ol start="2"><li><strong> JVM默认是如何处理异常的</strong><ul><li>JVM默认是如何处理异常的<ol><li>main函数收到这个问题时,有两种处理方式:<ul><li>a:自己将该问题处理,然后继续运行</li><li>b:自己没有针对的处理方式,只有交给调用main的jvm来处理</li></ul></li><li>jvm有一个默认的异常处理机制,就将该异常进行处理.</li><li>并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行</li></ol></li></ul></li></ol><ol start="3"><li><strong> 异常处理的两种方式</strong><ul><li>try…catch…finally</li><li>throws</li></ul></li></ol><ol start="4"><li><p><strong> try…catch的方式处理异常【掌握】</strong></p><ul><li>try…catch处理异常的基本格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try    &#123;</span><br><span class="line">    可能出现问题的代码 ;</span><br><span class="line">&#125;catch(异常名 变量名)&#123;</span><br><span class="line">    针对问题的处理 ;</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    释放资源;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意事项:</p><ul><li>a：try中的代码越少越好</li><li>b：catch中要做处理,哪怕是一条输出语句也可以.(不能将异常信息隐藏)</li><li>c：处理多个异常<ul><li>1:能明确的尽量明确，不要用大的来处理。</li><li>2:平级关系的异常谁前谁后无所谓，如果出现了子父关系，父必须在后面。</li></ul></li></ul></li></ol><ol start="6"><li><strong> 编译期异常和运行期异常的区别【理解】</strong><ul><li>编译期异常和运行期异常的区别</li><li>Java中的异常被分为两大类：编译时异常和运行时异常。<ul><li>所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常</li><li>编译时异常:    Java程序必须显示处理，否则程序就会发生错误，无法通过编译</li><li>运行时异常:    无需显示处理，也可以和编译时异常一样处理</li></ul></li></ul></li></ol><ol start="7"><li><p><strong> throw的概述以及和throws的区别【掌握】</strong></p><ul><li>throws的方式处理异常:<br>  定义功能方法时，需要把出现的问题暴露出来让调用者去处理。那么就通过throws在方法上标识。</li><li>throw的概述:<br>  在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。</li></ul><ul><li><strong>a:throws</strong></li></ul><ol><li>用在方法声明后面，跟的是异常类名</li><li>可以跟多个异常类名，用逗号隔开</li><li>表示抛出异常，由该方法的调用者来处理</li><li><p>throws表示出现异常的一种可能性，并不一定会发生这些异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void pop() throws NegativeArraySizeException &#123;</span><br><span class="line">// 定义方法并抛出NegativeArraySizeException异常</span><br><span class="line">int[] arr = new int[-3]; // 创建数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123; // 主方法</span><br><span class="line">try &#123; // try语句处理异常信息</span><br><span class="line">pop(); // 调用pop()方法</span><br><span class="line">&#125; catch (NegativeArraySizeException e) &#123;</span><br><span class="line">System.out.println(&quot;pop()方法抛出的异常&quot;);// 输出异常信息</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用throws关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。</p></li></ol><ul><li><strong>b:throw</strong></li></ul><ul><li>用在方法体内，跟的是异常对象名</li><li>只能抛出一个异常对象名</li><li>表示抛出异常，由方法体内的语句处理  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public PlayService getPlayService() &#123;</span><br><span class="line">    PlayService playService = BaseAppHelper.get().getPlayService();</span><br><span class="line">    if (playService == null) &#123;</span><br><span class="line">        //待解决：当长期处于后台，如何保活？避免service被杀死……</span><br><span class="line">        throw new NullPointerException(&quot;play service is null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return playService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><strong> 异常的注意事项及如何使用异常处理【了解】</strong><ul><li>A:异常注意事项(针对编译期异常)<ul><li>a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏)</li><li>b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常</li><li>c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws</li></ul></li><li>B:如何使用异常处理<ul><li>原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws</li><li>区别:<ul><li>后续程序需要继续运行就try</li><li>后续程序不需要继续运行就throws</li><li>如果JDK没有提供对应的异常，需要自定义异常。</li></ul></li></ul></li></ul></li></ul><h4 id="Throwable类中的常用方法"><a href="#Throwable类中的常用方法" class="headerlink" title="Throwable类中的常用方法"></a>Throwable类中的常用方法</h4><ul><li>注意：catch关键字后面括号中的Exception类型的参数e。Exception就是try代码块传递给catch代码块的变量类型，e就是变量名。catch代码块中语句”e.getMessage();”用于输出错误性质。通常异常处理常用3个函数来获取异常的有关信息:<ul><li>getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。</li><li>getMeage()：返回异常的消息信息。</li><li>printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段 System.err 的值。</li></ul></li><li>有时为了简单会忽略掉catch语句后的代码，这样try-catch语句就成了一种摆设，一旦程序在运行过程中出现了异常，就会忽略处理异常，而错误发生的原因很难查找。</li></ul><h3 id="Error-错误"><a href="#Error-错误" class="headerlink" title="Error(错误)"></a>Error(错误)</h3><ul><li>Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="Exception-异常"><a href="#Exception-异常" class="headerlink" title="Exception(异常)"></a>Exception(异常)</h3><ol><li>Exception（异常）:是程序本身可以处理的异常。</li><li>Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。<ol><li>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。</li><li>非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</li></ol></li></ol><h3 id="处理异常机制深入理解"><a href="#处理异常机制深入理解" class="headerlink" title="处理异常机制深入理解"></a>处理异常机制深入理解</h3><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><ul><li>当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</li></ul><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><ul><li>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li></ul><h4 id="异常处理方式不同"><a href="#异常处理方式不同" class="headerlink" title="异常处理方式不同"></a>异常处理方式不同</h4><ul><li>Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。<ul><li><strong>可查异常</strong>（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</li><li><strong>不可查异常</strong>(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。</li><li>总结：一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的。</li></ul></li><li><strong>处理运行时异常</strong><ul><li>由于运行时异常的不可查性，为了更合理、更容易地实现应用程序，Java规定，运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常。</li></ul></li><li><strong>处理Error</strong><ul><li>对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数Error异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。</li></ul></li><li><strong>处理可查异常</strong><ul><li>对于所有的可查异常，Java规定：一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉可查异常时，它必须声明将抛出异常。</li></ul></li></ul><h3 id="异常总结"><a href="#异常总结" class="headerlink" title="异常总结"></a>异常总结</h3><h4 id="异常总结-1"><a href="#异常总结-1" class="headerlink" title="异常总结"></a>异常总结</h4><ol><li>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</li><li>catch 块：用于处理try捕获到的异常。</li><li>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行：<br>1）在finally语句块中发生了异常。<br>2）在前面的代码中用了System.exit()退出程序。<br>3）程序所在的线程死亡。<br>4）关闭CPU。</li></ol><h4 id="try-catch-finally规则"><a href="#try-catch-finally规则" class="headerlink" title="try-catch-finally规则"></a>try-catch-finally规则</h4><ol><li>必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。</li><li>必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。</li><li>catch 块与相应的异常类的类型相关。</li><li>一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块</li><li>可嵌套 try-catch-finally 结构。</li><li>在 try-catch-finally 结构中，可重新抛出异常。</li><li>除了下列情况，总将执行 finally 做为结束：JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。</li></ol><h4 id="try、catch、finally语句块的执行顺序"><a href="#try、catch、finally语句块的执行顺序" class="headerlink" title="try、catch、finally语句块的执行顺序"></a>try、catch、finally语句块的执行顺序</h4><ol><li>当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句；</li><li>当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行；</li><li>当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句；</li></ol><h4 id="Throws抛出异常的规则"><a href="#Throws抛出异常的规则" class="headerlink" title="Throws抛出异常的规则"></a>Throws抛出异常的规则</h4><ol><li>如果是不可查异常（unchecked exception），即Error、RuntimeException或它们的子类，那么可以不使用throws关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。</li><li>必须声明方法可抛出的任何可查异常（checked exception）。即如果一个方法可能出现受可查异常，要么用try-catch语句捕获，要么用throws子句声明将它抛出，否则会导致编译错误</li><li>仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。</li><li>调用方法必须遵循任何可查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol><li>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承Exception类即可。</li><li>在程序中使用自定义异常类，大体可分为以下几个步骤。<ol><li>创建自定义异常类。</li><li>在方法中通过throw关键字抛出异常对象。</li><li>如果在当前抛出异常的方法中处理异常，可以使用try-catch语句捕获并处理；否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作。</li><li>在出现异常方法的调用者中捕获并处理异常。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Expection </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java类的加载机制</title>
      <link href="/2019/02/21/java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/02/21/java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="01-Java对象的创建过程"><a href="#01-Java对象的创建过程" class="headerlink" title="01.Java对象的创建过程"></a>01.Java对象的创建过程</h3><h4 id="1-1-看下创建类加载过程"><a href="#1-1-看下创建类加载过程" class="headerlink" title="1.1 看下创建类加载过程"></a>1.1 看下创建类加载过程</h4><ul><li>Person p = new Person()请写一下类的加载过程？  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1).因为new用到了Person.class，所以会先找到Person.class文件，并加载到内存中;</span><br><span class="line">2).执行该类中的static代码块，如果有的话，给Person.class类进行初始化;</span><br><span class="line">3).在堆内存中开辟空间分配内存地址;</span><br><span class="line">4).在堆内存中建立对象的特有属性，并进行默认初始化;</span><br><span class="line">5).对属性进行显示初始化;</span><br><span class="line">6).对对象进行构造代码块初始化;</span><br><span class="line">7).对对象进行与之对应的构造函数进行初始化;</span><br><span class="line">8).将内存地址付给栈内存中的p变量</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-1-对象的创建"><a href="#1-1-对象的创建" class="headerlink" title="1.1 对象的创建"></a>1.1 对象的创建</h4><ul><li>Java对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。<ul><li>1.类加载检查</li><li>2.分配内存</li><li>3.初始化零值</li><li>4.设置对象头</li><li>5.执行init方法</li></ul></li><li><strong>①类加载检查：</strong> <ul><li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li></ul></li><li><strong>②分配内存：</strong> <ul><li>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</li><li><strong>内存分配的两种方式：</strong><ul><li>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（”标记-压缩”），值得注意的是，复制算法内存也是规整的</li></ul></li><li><strong>内存分配并发问题</strong><ul><li>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</li></ul></li><li><strong>CAS+失败重试：</strong><ul><li>CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li></ul></li><li><strong>TLAB：</strong><ul><li>为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配</li></ul></li></ul></li><li><strong>③初始化零值：</strong> <ul><li>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li></ul></li><li><strong>④设置对象头：</strong>   <ul><li>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。</li><li><strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li></ul></li><li><strong>⑤执行 init 方法：</strong><ul><li>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul></li></ul><h4 id="1-2-对象的内存布局"><a href="#1-2-对象的内存布局" class="headerlink" title="1.2 对象的内存布局"></a>1.2 对象的内存布局</h4><ul><li>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3快区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</li><li><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希吗、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</li><li><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</li><li><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong></li><li>因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ul><h3 id="02-Java内存区域"><a href="#02-Java内存区域" class="headerlink" title="02.Java内存区域"></a>02.Java内存区域</h3><h4 id="2-0-运行时数据区域"><a href="#2-0-运行时数据区域" class="headerlink" title="2.0 运行时数据区域"></a>2.0 运行时数据区域</h4><ul><li>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</li><li>这些组成部分一些事线程私有的，其他的则是线程共享的。<ul><li><strong>线程私有的：</strong><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li><strong>线程共享的：</strong><ul><li>Java堆</li><li>方法区</li><li>运行时常量池</li><li>直接内存</li></ul></li></ul></li><li><img src="https://upload-images.jianshu.io/upload_images/4432347-a7bbacca96a92dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h4><ul><li>程序计数器：是一个数据结构，用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为“线程私有”。</li><li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></li><li>程序计数器主要有两个作用：<ul><li>1.字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>2.在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿。</li></ul></li><li><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></li></ul><h4 id="2-2-虚拟机栈"><a href="#2-2-虚拟机栈" class="headerlink" title="2.2 虚拟机栈"></a>2.2 虚拟机栈</h4><ul><li>Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。</li><li><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong>（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</li><li><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</li><li><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong><ul><li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong> 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul></li><li>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</li></ul><h4 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h4><ul><li>本地方法栈：跟虚拟机栈很像， <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li><li>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</li><li>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</li></ul><h4 id="2-4-Java堆"><a href="#2-4-Java堆" class="headerlink" title="2.4 Java堆"></a>2.4 Java堆</h4><ul><li>Java堆：所有线程共享的一块内存区域，此内存区域的唯一目的就是存放对象实例，对象实例几乎都在这分配内存。在虚拟机启动时创建。</li><li>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：在细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong><ul><li><img src="https://upload-images.jianshu.io/upload_images/4432347-99889839cf683c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul></li><li><strong>在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</strong></li></ul><h4 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h4><ul><li>方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。<ul><li>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</li></ul></li><li><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong>如何理解这句话？</li></ul><h4 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h4><ul><li>运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。<ul><li>。Class 文件中包括类的版本、字段、方法、接口等描述信息 </li></ul></li><li>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。<strong>JDK1.7及之后版本的 JVM已经将运行时常量池从方法区中移了出来，在Java堆（Heap）中开辟了一块区域存放运行时常量池。</strong> </li></ul><h4 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h4><ul><li>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。</li><li>JDK1.4中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</li><li>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</li></ul><h3 id="03-Java对象的访问定位方式"><a href="#03-Java对象的访问定位方式" class="headerlink" title="03.Java对象的访问定位方式"></a>03.Java对象的访问定位方式</h3><ul><li>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定</li><li>目前主流的访问方式有<ul><li><strong>①使用句柄</strong></li><li><strong>②直接指针</strong></li></ul></li><li><strong>这两种对象访问方式各有优势。</strong><ul><li>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li><li>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</li></ul></li></ul><h4 id="3-1-句柄"><a href="#3-1-句柄" class="headerlink" title="3.1 句柄"></a>3.1 句柄</h4><ul><li>如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；<br><img src="https://upload-images.jianshu.io/upload_images/4432347-5b5462dfa50f4e54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="3-2-直接指针"><a href="#3-2-直接指针" class="headerlink" title="3.2 直接指针"></a>3.2 直接指针</h4><ul><li>如果使用直接指针访问，那么 Java 堆对像的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。<br><img src="https://upload-images.jianshu.io/upload_images/4432347-89ff06972fe7d216.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h3 id="04-Java对象销毁分析"><a href="#04-Java对象销毁分析" class="headerlink" title="04.Java对象销毁分析"></a>04.Java对象销毁分析</h3><ul><li><img src="https://upload-images.jianshu.io/upload_images/4432347-61f54fc79524d982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="4-1-JVM内存分配与回收"><a href="#4-1-JVM内存分配与回收" class="headerlink" title="4.1 JVM内存分配与回收"></a>4.1 JVM内存分配与回收</h4><ul><li>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</li><li><strong>JDK1.8之前的堆内存示意图：</strong><ul><li><img src="https://upload-images.jianshu.io/upload_images/4432347-648638971a947150.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>从上图可以看出堆内存的分为新生代、老年代和永久代。新生代又被进一步分为：Eden 区＋Survior1 区＋Survior2 区。值得注意的是，在JDK1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）。</li></ul></li><li>分代回收算法<ul><li>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</li><li>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</li></ul></li><li><strong>Minor Gc和Full GC 有什么不同呢？</strong><ul><li><strong>新生代GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li><li><strong>老年代GC（Major GC/Full GC）</strong>:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul></li></ul><h4 id="4-2-判断对象是否死亡"><a href="#4-2-判断对象是否死亡" class="headerlink" title="4.2 判断对象是否死亡"></a>4.2 判断对象是否死亡</h4><ul><li>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。<ul><li><img src="https://upload-images.jianshu.io/upload_images/4432347-2a2d50bb59c70459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul></li></ul><h5 id="4-2-1-引用计数法"><a href="#4-2-1-引用计数法" class="headerlink" title="4.2.1 引用计数法"></a>4.2.1 引用计数法</h5><ul><li>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。<ul><li><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></li><li>所谓对象之间的相互引用问题，如下面代码所示：除了对象objA和objB相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    Object instance = null;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Test objA = new Test();</span><br><span class="line">Test objB = new Test();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line">objA = null;</span><br><span class="line">objB = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="4-2-2-可达性分析算法"><a href="#4-2-2-可达性分析算法" class="headerlink" title="4.2.2 可达性分析算法"></a>4.2.2 可达性分析算法</h5><ul><li>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。<ul><li><img src="https://upload-images.jianshu.io/upload_images/4432347-68378382046ae5b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul></li></ul><h5 id="4-2-3-再谈引用"><a href="#4-2-3-再谈引用" class="headerlink" title="4.2.3 再谈引用"></a>4.2.3 再谈引用</h5><ul><li>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</li><li>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</li></ul><h4 id="4-3-不可达的对象并非“非死不可”"><a href="#4-3-不可达的对象并非“非死不可”" class="headerlink" title="4.3 不可达的对象并非“非死不可”"></a>4.3 不可达的对象并非“非死不可”</h4><ul><li>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</li><li>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</li></ul><h4 id="4-4-如何判断一个常量是废弃常量"><a href="#4-4-如何判断一个常量是废弃常量" class="headerlink" title="4.4 如何判断一个常量是废弃常量"></a>4.4 如何判断一个常量是废弃常量</h4><h4 id="4-5-如何判断一个类是无用的类"><a href="#4-5-如何判断一个类是无用的类" class="headerlink" title="4.5 如何判断一个类是无用的类"></a>4.5 如何判断一个类是无用的类</h4><ul><li>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：<ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul></li><li>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</li></ul><h3 id="05-String类和常量池"><a href="#05-String类和常量池" class="headerlink" title="05.String类和常量池"></a>05.String类和常量池</h3><h4 id="5-1-String对象的两种创建方式"><a href="#5-1-String对象的两种创建方式" class="headerlink" title="5.1 String对象的两种创建方式"></a>5.1 String对象的两种创建方式</h4><ul><li><p><strong>1 String 对象的两种创建方式：</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = &quot;abcd&quot;;</span><br><span class="line">String str2 = new String(&quot;abcd&quot;);</span><br><span class="line">System.out.println(str1==str2);//false</span><br></pre></td></tr></table></figure></li><li><p>这两种不同的创建方法是有差别的【记住：只要使用new方法，便需要创建新的对象】</p><ul><li>第一种方式是在常量池中拿对象</li><li>第二种方式是直接在堆内存空间创建一个新的对象。</li></ul></li><li><img src="https://upload-images.jianshu.io/upload_images/4432347-af57ef349075687a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="5-2-String类型的常量池"><a href="#5-2-String类型的常量池" class="headerlink" title="5.2 String类型的常量池"></a>5.2 String类型的常量池</h4><ul><li><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong><ul><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;yc&quot;);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = &quot;yc&quot;;</span><br><span class="line">System.out.println(s2);//yc</span><br><span class="line">System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，</span><br><span class="line">System.out.println(s3 == s2);//true，因为两个都是常量池中的String对</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Class </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java中int和Integer分析</title>
      <link href="/2019/02/21/java%E4%B8%ADint%E5%92%8CInteger%E5%88%86%E6%9E%90/"/>
      <url>/2019/02/21/java%E4%B8%ADint%E5%92%8CInteger%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-关于int和Integer的问题区别分析"><a href="#1-关于int和Integer的问题区别分析" class="headerlink" title="1.关于int和Integer的问题区别分析"></a>1.关于int和Integer的问题区别分析</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>1.1 编译阶段、运行时，自动装箱 / 自动拆箱是发生在什么阶段？</li><li>1.2使用静态工厂方法 valueOf 会使用到缓存机制，那么自动装箱的时候，缓存机制起作用吗？</li><li>1.3为什么我们需要原始数据类型，Java 的对象似乎也很高效，应用中具体会产生哪些差异？</li><li>1.4 阅读过 Integer 源码吗？分析下类或某些方法的设计要点？</li><li>1.5 int和Integer的区别</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li>Integer是int的包装类，int则是java的一种基本数据类型 </li><li>Integer变量必须实例化后才能使用，而int变量不需要 </li><li>Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 </li><li>Integer的默认值是null，int的默认值是0</li></ol><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><blockquote><p>关于Integer和int的比较 </p><ol><li>由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。<br>Integer i = new Integer(100);<br>Integer j = new Integer(100);<br>System.out.print(i == j); //false</li><li>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）<br>Integer i = new Integer(100);<br>int j = 100；<br>System.out.print(i == j); //true</li><li>非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。（因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同）<br>Integer i = new Integer(100);<br>Integer j = 100;<br>System.out.print(i == j); //false</li><li>对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false<br>Integer i = 100;<br>Integer j = 100;<br>System.out.print(i == j); //true<br>Integer i = 128;<br>Integer j = 128;<br>System.out.print(i == j); //false</li></ol></blockquote><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li><p>对于第4条的原因：<br>  java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)；，而java API中对Integer类型的valueOf的定义如下：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i)&#123;</span><br><span class="line">    assert IntegerCache.high &gt;= 127;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  java对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了</p></li></ul><h3 id="2-Integer的值缓存的原理"><a href="#2-Integer的值缓存的原理" class="headerlink" title="2.Integer的值缓存的原理"></a>2.Integer的值缓存的原理</h3><h4 id="2-1-Java-5-中引入缓存特性"><a href="#2-1-Java-5-中引入缓存特性" class="headerlink" title="2.1 Java 5 中引入缓存特性"></a>2.1 Java 5 中引入缓存特性</h4><ul><li>在 Java 5 中，为 Integer 的操作引入了一个新的特性，用来节省内存和提高性能。整型对象在内部实现中通过使用相同的对象引用实现了缓存和重用。</li><li>这种 Integer 缓存策略仅在自动装箱（autoboxing）的时候有用，使用构造器创建的 Integer 对象不能被缓存。</li></ul><h4 id="2-2-Integer类中的IntegerCache类"><a href="#2-2-Integer类中的IntegerCache类" class="headerlink" title="2.2 Integer类中的IntegerCache类"></a>2.2 Integer类中的IntegerCache类</h4><ul><li>在创建新的 Integer 对象之前会先在 IntegerCache.cache (是个Integer类型的数组)中查找。有一个专门的 Java 类来负责 Integer 的缓存。</li><li>这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。这个缓存会在 Integer 类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static Integer valueOf(int i) &#123;</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private static class IntegerCache &#123;</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</span><br><span class="line">        if (integerCacheHighPropValue != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, 127);</span><br><span class="line">                // Maximum array size is Integer.MAX_VALUE</span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">            &#125; catch( NumberFormatException nfe) &#123;</span><br><span class="line">                // If the property cannot be parsed into an int, ignore it.</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private IntegerCache() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-其他整型类型的缓存机制"><a href="#2-3-其他整型类型的缓存机制" class="headerlink" title="2.3 其他整型类型的缓存机制"></a>2.3 其他整型类型的缓存机制</h4><ul><li>这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。<ul><li>有 ByteCache 用于缓存 Byte 对象</li><li>有 ShortCache 用于缓存 Short 对象</li><li>有 LongCache 用于缓存 Long 对象</li><li>有 CharacterCache 用于缓存 Character 对象</li><li>Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。</li></ul></li></ul><h3 id="3-理解自动装箱和拆箱"><a href="#3-理解自动装箱和拆箱" class="headerlink" title="3.理解自动装箱和拆箱"></a>3.理解自动装箱和拆箱</h3><h4 id="3-1-什么是装箱？什么是拆箱？"><a href="#3-1-什么是装箱？什么是拆箱？" class="headerlink" title="3.1 什么是装箱？什么是拆箱？"></a>3.1 什么是装箱？什么是拆箱？</h4><ul><li>装箱就是  自动将基本数据类型转换为包装器类型；拆箱就是  自动将包装器类型转换为基本数据类型。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//拆箱</span><br><span class="line">int yc = 5;</span><br><span class="line">//装箱</span><br><span class="line">Integer yc = 5;</span><br></pre></td></tr></table></figure><h4 id="3-2-装箱和拆箱是如何实现的"><a href="#3-2-装箱和拆箱是如何实现的" class="headerlink" title="3.2 装箱和拆箱是如何实现的"></a>3.2 装箱和拆箱是如何实现的</h4><ul><li><p>以Interger类为例，下面看一段代码来了解装箱和拆箱的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer y = 10;</span><br><span class="line">        int c = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后来编译一下，看下图所示：</p><ul><li>从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。</li><li>因此可以用一句话总结装箱和拆箱的实现过程：装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。<br><img src="https://upload-images.jianshu.io/upload_images/4432347-9a3efbd0f681629e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul></li></ul><h4 id="3-3-装箱和拆箱在编程实际中注意点"><a href="#3-3-装箱和拆箱在编程实际中注意点" class="headerlink" title="3.3 装箱和拆箱在编程实际中注意点"></a>3.3 装箱和拆箱在编程实际中注意点</h4><ul><li>建议避免无意中的装箱、拆箱行为，尤其是在性能敏感的场合，创建 10 万个 Java 对象和 10 万个整数的开销可不是一个数量级的，不管是内存使用还是处理速度，光是对象头的空间占用就已经是数量级的差距了。</li></ul><h3 id="4-原始类型线程安全问题"><a href="#4-原始类型线程安全问题" class="headerlink" title="4.原始类型线程安全问题"></a>4.原始类型线程安全问题</h3><h4 id="4-1-那些类型是线程安全的"><a href="#4-1-那些类型是线程安全的" class="headerlink" title="4.1 那些类型是线程安全的"></a>4.1 那些类型是线程安全的</h4><ul><li>Java自带的线程安全的基本类型包括： AtomicInteger, AtomicLong, AtomicBoolean, AtomicIntegerArray,AtomicLongArray等</li></ul><h4 id="4-2-如何验证int类型是否线程安全"><a href="#4-2-如何验证int类型是否线程安全" class="headerlink" title="4.2 如何验证int类型是否线程安全"></a>4.2 如何验证int类型是否线程安全</h4><ul><li>200个线程，每个线程对共享变量 count 进行 50 次 ++ 操作 </li><li>int 作为基本类型，直接存储在内存栈，且对其进行+,-操作以及++,–操作都不是原子操作，都有可能被其他线程抢断，所以不是线程安全。int 用于单线程变量存取，开销小，速度快</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int count = 0;</span><br><span class="line">private void startThread() &#123;</span><br><span class="line">    for (int i = 0;i &lt; 200; i++)&#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int k = 0; k &lt; 50; k++)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    // 休眠10秒，以确保线程都已启动</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000*10);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        Log.e(&quot;打印日志----&quot;,count+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//期望输出10000，最后输出的是9818</span><br><span class="line">//注意：打印日志----: 9818</span><br></pre></td></tr></table></figure><h4 id="4-3-AtomicInteger线程安全版"><a href="#4-3-AtomicInteger线程安全版" class="headerlink" title="4.3 AtomicInteger线程安全版"></a>4.3 AtomicInteger线程安全版</h4><ul><li>AtomicInteger类中有有一个变量valueOffset，用来描述AtomicInteger类中value的内存位置 。</li><li>当需要变量的值改变的时候，先通过get（）得到valueOffset位置的值，也即当前value的值.给该值进行增加，并赋给next</li><li>compareAndSet（）比较之前取到的value的值当前有没有改变，若没有改变的话，就将next的值赋给value，倘若和之前的值相比的话发生变化的话，则重新一次循环，直到存取成功，通过这样的方式能够保证该变量是线程安全的</li><li>value使用了volatile关键字，使得多个线程可以共享变量，使用volatile将使得VM优化失去作用，在线程数特别大时，效率会较低。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">private static AtomicInteger atomicInteger = new AtomicInteger(1);</span><br><span class="line">static Integer count1 = Integer.valueOf(0);</span><br><span class="line">private void startThread1() &#123;</span><br><span class="line">    for (int i = 0;i &lt; 200; i++)&#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int k = 0; k &lt; 50; k++)&#123;</span><br><span class="line">                    // getAndIncrement: 先获得值，再自增1，返回值为自增前的值</span><br><span class="line">                    count1 = atomicInteger.getAndIncrement();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    // 休眠10秒，以确保线程都已启动</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(1000*10);</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">        Log.e(&quot;打印日志----&quot;,count1+&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//期望输出10000，最后输出的是10000</span><br><span class="line">//注意：打印日志----: 10000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//AtomicInteger使用了volatile关键字进行修饰，使得该类可以满足线程安全。</span><br><span class="line">private volatile int value;</span><br><span class="line">/**</span><br><span class="line"> * Creates a new AtomicInteger with the given initial value.</span><br><span class="line"> *</span><br><span class="line"> * @param initialValue the initial value</span><br><span class="line"> */</span><br><span class="line">public AtomicInteger(int initialValue) &#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Java-原始数据类型和引用类型局限性"><a href="#5-Java-原始数据类型和引用类型局限性" class="headerlink" title="5.Java 原始数据类型和引用类型局限性"></a>5.Java 原始数据类型和引用类型局限性</h3><h4 id="5-1-原始数据类型和-Java-泛型并不能配合使用"><a href="#5-1-原始数据类型和-Java-泛型并不能配合使用" class="headerlink" title="5.1 原始数据类型和 Java 泛型并不能配合使用"></a>5.1 原始数据类型和 Java 泛型并不能配合使用</h4><ul><li>Java 的泛型某种程度上可以算作伪泛型，它完全是一种编译期的技巧，Java 编译期会自动将类型转换为对应的特定类型，这就决定了使用泛型，必须保证相应类型可以转换为Object。</li></ul><h4 id="5-2-无法高效地表达数据，也不便于表达复杂的数据结构"><a href="#5-2-无法高效地表达数据，也不便于表达复杂的数据结构" class="headerlink" title="5.2 无法高效地表达数据，也不便于表达复杂的数据结构"></a>5.2 无法高效地表达数据，也不便于表达复杂的数据结构</h4><ul><li>Java 的对象都是引用类型，如果是一个原始数据类型数组，它在内存里是一段连续的内存，而对象数组则不然，数据存储的是引用，对象往往是分散地存储在堆的不同位置。这种设计虽然带来了极大灵活性，但是也导致了数据操作的低效，尤其是无法充分利用现代 CPU 缓存机制。</li><li>Java 为对象内建了各种多态、线程安全等方面的支持，但这不是所有场合的需求，尤其是数据处理重要性日益提高，更加高密度的值类型是非常现实的需求。</li></ul><h3 id="6-关于其他知识延伸"><a href="#6-关于其他知识延伸" class="headerlink" title="6.关于其他知识延伸"></a>6.关于其他知识延伸</h3><h4 id="6-1-对象的内存结构"><a href="#6-1-对象的内存结构" class="headerlink" title="6.1 对象的内存结构"></a>6.1 对象的内存结构</h4><ul><li>对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</li></ul><h4 id="6-2-对象头的结构"><a href="#6-2-对象头的结构" class="headerlink" title="6.2 对象头的结构"></a>6.2 对象头的结构</h4><ul><li>HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为”Mark Word”。</li><li>对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</li></ul><h4 id="6-3-如何计算或者获取某个Java对象的大小"><a href="#6-3-如何计算或者获取某个Java对象的大小" class="headerlink" title="6.3 如何计算或者获取某个Java对象的大小"></a>6.3 如何计算或者获取某个Java对象的大小</h4><ul><li>获取一个JAVA对象的大小，可以将一个对象进行序列化为二进制的Byte，便可以查看大小</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//获取一个JAVA对象的大小，可以将一个对象进行序列化为二进制的Byte，便可以查看大小</span><br><span class="line">Integer value = 10;</span><br><span class="line">ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos ;</span><br><span class="line">try &#123;</span><br><span class="line">    oos = new ObjectOutputStream(bos);</span><br><span class="line">    oos.writeObject(value);</span><br><span class="line">    oos.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">// 读出当前对象的二进制流信息</span><br><span class="line">Log.e(&quot;打印日志----&quot;,bos.size()+&quot;&quot;);</span><br><span class="line">//打印日志----: 81</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Integer </tag>
            
            <tag> int </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java的String类</title>
      <link href="/2019/02/21/java%E7%9A%84String%E7%B1%BB/"/>
      <url>/2019/02/21/java%E7%9A%84String%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-String的创建机理"><a href="#1-String的创建机理" class="headerlink" title="1.String的创建机理"></a>1.String的创建机理</h3><ul><li>由于String在Java世界中使用过于频繁，Java为了避免在一个系统中产生大量的String对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的String对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。上述原则只适用于通过直接量给String对象引用赋值的情况。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">举例：String str1 = &quot;123&quot;; //通过直接量赋值方式，放入字符串常量池</span><br><span class="line">String str2 = new String(“123”);//通过new方式赋值方式，不放入字符串常量池</span><br></pre></td></tr></table></figure><ul><li>注意：String提供了inter()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。</li></ul><h3 id="2-StringBuffer-StringBuilder"><a href="#2-StringBuffer-StringBuilder" class="headerlink" title="2.StringBuffer/StringBuilder"></a>2.StringBuffer/StringBuilder</h3><ul><li>StringBuffer和StringBuilder都实现了AbstractStringBuilder抽象类，拥有几乎一致对外提供的调用接口；其底层在内存中的存储方式与String相同，都是以一个有序的字符序列（char类型的数组）进行存储，不同点是StringBuffer/StringBuilder对象的值是可以改变的，并且值改变以后，对象引用不会发生改变;两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。</li></ul><h3 id="3-String类的考点分析"><a href="#3-String类的考点分析" class="headerlink" title="3.String类的考点分析"></a>3.String类的考点分析</h3><ul><li>通过 String 和相关类，考察基本的线程安全设计与实现，各种基础编程实践。</li><li>考察 JVM 对象缓存机制的理解以及如何良好地使用。</li><li>考察 JVM 优化 Java 代码的一些技巧。</li><li>String 相关类的演进，比如 Java 9 中实现的巨大…</li></ul><h3 id="4-String技术点深入分析"><a href="#4-String技术点深入分析" class="headerlink" title="4.String技术点深入分析"></a>4.String技术点深入分析</h3><h4 id="4-1-String类是典型的Immutable类"><a href="#4-1-String类是典型的Immutable类" class="headerlink" title="4.1 String类是典型的Immutable类"></a>4.1 String类是典型的Immutable类</h4><ul><li>是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。</li></ul><h4 id="4-2-字符串设计和实现考量"><a href="#4-2-字符串设计和实现考量" class="headerlink" title="4.2 字符串设计和实现考量"></a>4.2 字符串设计和实现考量</h4><ul><li>String 是 Immutable 类的典型实现，原生的保证了基础线程安全，因为你无法对它内部数据进行任何修改，这种便利甚至体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。</li><li>为了实现修改字符序列的目的，StringBuffer 和 StringBuilder 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 AbstractStringBuilder，里面包含了基本操作，区别仅在于最终的方法是否加了 synchronized。</li><li>这个内部数组应该创建成多大的呢？如果太小，拼接的时候可能要重新创建足够大的数组；如果太大，又会浪费空间。目前的实现是，构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行arraycopy。</li></ul><h4 id="4-3-字符串缓存"><a href="#4-3-字符串缓存" class="headerlink" title="4.3 字符串缓存"></a>4.3 字符串缓存</h4><ul><li>String 在 Java 6 以后提供了 intern()方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。在我们创建字符串对象并调用 intern() 方法的时候，如果已经有缓存的字符串，就会返回缓存里的实例，否则将其缓存起来。</li><li>在后续版本中，这个缓存被放置在堆中，这样就极大避免了永久代占满的问题，甚至永久代在 JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断地扩大中，从最初的 1009，到 7u40 以后被修改为 60013。</li></ul><h3 id="5-String不可变的好处"><a href="#5-String不可变的好处" class="headerlink" title="5.String不可变的好处"></a>5.String不可变的好处</h3><ul><li><strong>5.1 可以缓存 hash 值</strong> <ul><li>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li></ul></li><li><strong>5.2 String Pool 的需要</strong> <ul><li>如果一个String对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li></ul></li><li><strong>5.3 安全性</strong> <ul><li>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li></ul></li><li><strong>5.4 线程安全</strong> <ul><li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java常见API方法</title>
      <link href="/2019/02/21/java%E5%B8%B8%E8%A7%81API%E6%96%B9%E6%B3%95/"/>
      <url>/2019/02/21/java%E5%B8%B8%E8%A7%81API%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h4><ul><li><strong>1.1 Object有哪些公用方法？</strong><ul><li>a.方法equals测试的是两个对象是否相等</li><li>b.方法clone进行对象拷贝【问题：是浅拷贝还是深拷贝？】</li><li>c.方法getClass返回和当前对象相关的Class对象</li><li>d.方法notify,notifyall,wait都是用来对给定对象进行线程同步的</li></ul></li></ul><h4 id="2-String类"><a href="#2-String类" class="headerlink" title="2.String类"></a>2.String类</h4><ul><li><strong>2.1 String类的一些特性</strong><ul><li>String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</li><li>字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。</li><li>Java 语言提供对字符串串联符号（”+”）以及将其他对象转换为字符串的特殊支持。字符串串联是通过 StringBuilder（或 StringBuffer）类及其 append 方法实现的。</li></ul></li></ul><ul><li><strong>2.2 一旦被创建就不能改变</strong><ul><li>String s = new String(“hello”)和String s = “hello”;的区别</li><li>String的特点一旦被创建就不能改变【内容不能变，引用可以变】</li></ul></li></ul><ul><li><strong>问答题</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A:String的特点:    一旦被创建就不能改变</span><br><span class="line">B:案例演示   </span><br><span class="line">     a:如何理解这句话</span><br><span class="line">     String s = &quot;hello&quot; ;</span><br><span class="line">     s =  &quot;world&quot; + &quot;java&quot;; 问s的结果是多少?</span><br><span class="line"></span><br><span class="line">下面这条语句一共创建了多少个对象:String s = “a”+“b”+”c”; 分别都是什么？</span><br><span class="line">答案：5个对象</span><br><span class="line">分别是 &quot;a&quot; , &quot;b&quot; , &quot;c&quot; , &quot;ab&quot; , &quot;abc&quot;</span><br><span class="line">因为字符串的特点是一旦被创建就不能被改变,所有在使用常量进行相加的时候,都是在创建新的字符串对象</span><br><span class="line">最后在把字符串&quot;abc&quot;这个常量值赋值给引用变量s</span><br></pre></td></tr></table></figure><ul><li>输出结果：<br><img src="https://upload-images.jianshu.io/upload_images/4432347-6e12adf73739cfdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="3-StringBuffer类与StringBuilder类"><a href="#3-StringBuffer类与StringBuilder类" class="headerlink" title="3.StringBuffer类与StringBuilder类"></a>3.StringBuffer类与StringBuilder类</h4><ul><li><strong>3.1 StringBuffer类概述</strong><ul><li>字符串缓冲区，StringBuffer是一个容器</li><li>我们如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。 而StringBuffer就可以解决这个问题</li><li>线程安全的可变的字符序列 , 安全对应的效率比较低</li></ul></li></ul><ul><li><strong>3.2 StringBuffer和String的区别</strong><ul><li>String是不可变的字符序列</li><li>StringBuffer 是可以的字符序列</li></ul></li></ul><ul><li><strong>3.3 StringBuffer和String的相互转换</strong></li><li>A:String – StringBuffer<ul><li>a:通过构造方法</li><li>b:通过append()方法</li></ul></li><li>B:StringBuffer – String<ul><li>a: 使用substring方法</li><li>b:通过构造方法</li><li>c:通过toString()方法</li></ul></li></ul><ul><li><strong>3.4 StringBuilder类</strong><ul><li>StringBuilder是线程不安全的，其他跟StringBuffer一样；StringBuffer和StringBuilder底层是 char[]数组实现的 </li></ul></li></ul><h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h4><ul><li><strong>4.1 数组高级冒泡排序原理图解</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-0ddf7d279e144929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li><p>冒泡排序原理</p><ul><li>相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处</li><li>冒泡排序代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 冒泡排序</span><br><span class="line">* @param arr</span><br><span class="line">*/</span><br><span class="line">private static void bubbleSort(int[] arr) &#123;</span><br><span class="line">    for(int y = 0 ; y &lt; arr.length - 1; y++) &#123;</span><br><span class="line">        for(int x = 0 ; x &lt; arr.length - 1 - y ; x++ ) &#123;</span><br><span class="line">            if(arr[x] &gt; arr[x+1]) &#123;</span><br><span class="line">                int temp = arr[x] ;</span><br><span class="line">                arr[x] = arr[x+1] ;</span><br><span class="line">                arr[x+1] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>4.2 数组高级选择排序原理图解</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-a498eca1c7f5b8ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>选择排序原理<ul><li>从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处</li></ul></li><li>数组高级选择排序代码实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void selectSort(int[] arr) &#123;</span><br><span class="line">    for(int index = 0 ; index &lt; arr.length - 1 ; index++) &#123;</span><br><span class="line">        for(int x = index + 1 ; x &lt; arr.length ; x++) &#123;</span><br><span class="line">            if(arr[index] &gt; arr[x]) &#123;</span><br><span class="line">                int temp = arr[index] ;</span><br><span class="line">                arr[index] = arr[x] ;</span><br><span class="line">                arr[x] = temp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>4.3 数组高级二分查找原理图解</strong><br><img src="https://upload-images.jianshu.io/upload_images/4432347-ce32a3a24ec74748.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>数组高级二分查找思想<ul><li>每一次都查中间的那个元素，比较大或者小就能减少一半的元素</li></ul></li><li>数组高级二分查找代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 二分查找</span><br><span class="line"> * @param arr</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private static int binarySearch2(int[] arr , int value) &#123;</span><br><span class="line">    // 定义三个变量</span><br><span class="line">    int minIndex = 0 ;</span><br><span class="line">    int maxIndex = arr.length - 1 ;</span><br><span class="line">    while(minIndex &lt;= maxIndex) &#123;</span><br><span class="line">        int midIndex = (minIndex + maxIndex) &gt;&gt;&gt; 1 ;</span><br><span class="line">        // 比较</span><br><span class="line">        if(arr[midIndex] == value) &#123;</span><br><span class="line">            return midIndex ;</span><br><span class="line">        &#125;else if(arr[midIndex] &gt; value) &#123;</span><br><span class="line">            maxIndex = midIndex - 1 ;</span><br><span class="line">        &#125;else if(arr[midIndex] &lt; value) &#123;</span><br><span class="line">            minIndex = midIndex + 1 ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-基本类型包装类"><a href="#5-基本类型包装类" class="headerlink" title="5.基本类型包装类"></a>5.基本类型包装类</h4><ul><li><strong>5.1 为什么会有基本类型包装类</strong><ul><li>为了对基本数据类型进行更多的操作,更方便的操作,java就针对每一种基本数据类型提供了对应的类类型.</li><li>常用操作:<ul><li>常用的操作之一：用于基本数据类型与字符串之间的转换</li></ul></li></ul></li></ul><ul><li><strong>5.2 基本类型和包装类的对应</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte           Byte</span><br><span class="line">short          Short</span><br><span class="line">int            Integer</span><br><span class="line">long           Long</span><br><span class="line">float          Float</span><br><span class="line">double         Double</span><br><span class="line">char           Character</span><br><span class="line">boolean        Boolean</span><br></pre></td></tr></table></figure><h4 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6.正则表达式"></a>6.正则表达式</h4><ul><li>正则表达式，不需要记忆，用的时候去查就可以呢<ul><li>是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。</li><li>具体使用直接上网搜索<ul><li>例如，匹配手机号，邮箱，身份证号等等</li></ul></li></ul></li></ul><h4 id="7-Pattern和Matcher类"><a href="#7-Pattern和Matcher类" class="headerlink" title="7.Pattern和Matcher类"></a>7.Pattern和Matcher类</h4><pre><code>* 正则的获取功能需要使用的类</code></pre><h4 id="8-Math类"><a href="#8-Math类" class="headerlink" title="8.Math类"></a>8.Math类</h4><pre><code>* Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。* 成员变量</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static final double E :         自然底数</span><br><span class="line">public static final double PI:        圆周率</span><br><span class="line">* 成员方法</span><br><span class="line"></span><br><span class="line">public static int abs(int a)               取绝对值</span><br><span class="line">public static double ceil(double a)        向上取整</span><br><span class="line">public static double floor(double a)       向下取整</span><br><span class="line">public static int max(int a,int b)         获取最大值</span><br><span class="line">public static int min(int a, int b)        获取最小值</span><br><span class="line">public static double pow(double a,double b)获取a的b次幂</span><br><span class="line">public static double random()              获取随机数  返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。</span><br><span class="line">public static int round(float a)           四舍五入</span><br><span class="line">public static double sqrt(double a)        获取正平方根</span><br></pre></td></tr></table></figure><h4 id="9-Random类"><a href="#9-Random类" class="headerlink" title="9.Random类"></a>9.Random类</h4><ul><li>随机类<ul><li>此类用于产生随机数如果用相同的种子创建两个 Random 实例，则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列</li><li>构造方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public Random()             没有给定种子,使用的是默认的(当前系统的毫秒值)</span><br><span class="line">public Random(long seed) 给定一个long类型的种子,给定以后每一次生成的随机数是相同的</span><br><span class="line">public int nextInt()</span><br><span class="line">public int nextInt(int n)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="10-System类"><a href="#10-System类" class="headerlink" title="10.System类"></a>10.System类</h4><ul><li>系统级类<ul><li>System 类包含一些有用的类字段和方法。它不能被实例化。</li><li>系统级操作</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java泛型</title>
      <link href="/2019/02/20/java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/02/20/java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-泛型的概述"><a href="#1-泛型的概述" class="headerlink" title="1.泛型的概述"></a>1.泛型的概述</h3><h4 id="1-1-泛型由来"><a href="#1-1-泛型由来" class="headerlink" title="1.1 泛型由来"></a>1.1 泛型由来</h4><ul><li>我们的集合可以存储多种数据类型的元素,那么在存储的时候没有任何问题,但是在获取元素,并向下转型的时候,可能会存在一个错误,而这个错误就是ClassCastException . 很显然,集合的这种可以存储多种数据类型的元素的这个特点,不怎么友好 , 程序存在一些安全隐患,那么为了出来这种安全隐患,我们应该限定一个集合存储元素的数据类型,我们只让他存储统一中数据类型的元素,那么在做向下转型的是就不会存在这种安全隐患了. 怎么限定集合只能给我存储同一种数据类型的元素呢? 需要使用泛型。</li></ul><h4 id="1-2-基本概述"><a href="#1-2-基本概述" class="headerlink" title="1.2 基本概述"></a>1.2 基本概述</h4><ul><li>是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。参数化类型，把类型当作参数一样的传递。</li><li>泛型的出现减少了很多强转的操作，同时避免了很多运行时的错误，在编译期完成检查类型转化</li></ul><h3 id="2-泛型的格式"><a href="#2-泛型的格式" class="headerlink" title="2.泛型的格式"></a>2.泛型的格式</h3><h4 id="2-1-泛型格式如下"><a href="#2-1-泛型格式如下" class="headerlink" title="2.1 泛型格式如下"></a>2.1 泛型格式如下</h4><ul><li>&lt;数据类型&gt;    这里的数据类型只能是引用数据类型</li><li>&lt;数据类型1 , 数据类型2 , ….&gt;</li></ul><h3 id="3-泛型的好处"><a href="#3-泛型的好处" class="headerlink" title="3.泛型的好处"></a>3.泛型的好处</h3><h4 id="3-1-好处"><a href="#3-1-好处" class="headerlink" title="3.1 好处"></a>3.1 好处</h4><ul><li>(1):把运行时期的问题提前到了编译期间</li><li>(2):避免了强制类型转换</li><li>(3):优化了程序设计，解决了黄色警告线</li></ul><h3 id="4-泛型的使用"><a href="#4-泛型的使用" class="headerlink" title="4.泛型的使用"></a>4.泛型的使用</h3><h4 id="4-1-泛型类的概述及使用"><a href="#4-1-泛型类的概述及使用" class="headerlink" title="4.1 泛型类的概述及使用"></a>4.1 泛型类的概述及使用</h4><ul><li>A:泛型类概述:        把泛型定义在类上</li><li>B:定义格式:           public class 类名&lt;泛型类型1,…&gt;</li><li>C:注意事项:           泛型类型必须是引用类型</li></ul><h4 id="4-2-泛型方法的概述和使用"><a href="#4-2-泛型方法的概述和使用" class="headerlink" title="4.2 泛型方法的概述和使用"></a>4.2 泛型方法的概述和使用</h4><ul><li>A:泛型方法概述:    把泛型定义在方法上</li><li>B:定义格式:           public &lt;泛型类型&gt; 返回类型 方法名(泛型类型 变量名)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; void show(T t) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-3-泛型接口的概述和使用"><a href="#4-3-泛型接口的概述和使用" class="headerlink" title="4.3 泛型接口的概述和使用"></a>4.3 泛型接口的概述和使用</h4><ul><li>A:泛型接口概述:    把泛型定义在接口上</li><li>B:定义格式:        public interface 接口名&lt;泛型类型&gt;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 泛型接口的定义格式:        修饰符  interface 接口名&lt;数据类型&gt; &#123;&#125;</span><br><span class="line"> */</span><br><span class="line">public interface Inter&lt;T&gt; &#123;</span><br><span class="line">    public abstract void show(T t) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 子类是泛型类</span><br><span class="line"> */</span><br><span class="line">public class InterImpl&lt;E&gt; implements Inter&lt;E&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void show(E t) &#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Inter&lt;String&gt; inter = new InterImpl&lt;String&gt;() ;</span><br><span class="line">inter.show(&quot;hello&quot;) ;</span><br></pre></td></tr></table></figure><h3 id="5-泛型高级之通配符"><a href="#5-泛型高级之通配符" class="headerlink" title="5.泛型高级之通配符"></a>5.泛型高级之通配符</h3><h4 id="5-1-为什么要使用通配符"><a href="#5-1-为什么要使用通配符" class="headerlink" title="5.1 为什么要使用通配符"></a>5.1 为什么要使用通配符</h4><ul><li>通配符的设计存在一定的场景，例如在使用泛型后，首先声明了一个Animal的类，而后声明了一个继承Animal类的Cat类，显然Cat类是Animal类的子类，但是List<cat>却不是List<animal>的子类型，而在程序中往往需要表达这样的逻辑关系。为了解决这种类似的场景，在泛型的参数类型的基础上新增了通配符的用法。</animal></cat></li></ul><h4 id="5-1-lt-extends-T-gt-上界通配符"><a href="#5-1-lt-extends-T-gt-上界通配符" class="headerlink" title="5.1 &lt;? extends T&gt; 上界通配符"></a>5.1 &lt;? extends T&gt; 上界通配符</h4><ul><li>上界通配符顾名思义，&lt;? extends T&gt;表示的是类型的上界【 <strong>包含自身</strong>】，因此通配的参数化类型可能是T或T的子类。正因为无法确定具体的类型是什么，add方法受限（可以添加null，因为null表示任何类型），但可以从列表中获取元素后赋值给父类型。如上图中的第一个例子，第三个add()操作会受限，原因在于List<animal>和List<cat>是List&lt;? extends Animal&gt;的子类型。</cat></animal></li></ul><h4 id="5-2-lt-super-T-gt-下界通配符"><a href="#5-2-lt-super-T-gt-下界通配符" class="headerlink" title="5.2 &lt;? super T&gt; 下界通配符"></a>5.2 &lt;? super T&gt; 下界通配符</h4><ul><li>下界通配符&lt;? super T&gt;表示的是参数化类型是T的超类型（<strong>包含自身</strong>），层层至上，直至Object，编译器无从判断get()返回的对象的类型是什么，因此get()方法受限。但是可以进行add()方法，add()方法可以添加T类型和T类型的子类型，如第二个例子中首先添加了一个Cat类型对象，然后添加了两个Cat子类类型的对象，这种方法是可行的，但是如果添加一个Animal类型的对象，显然将继承的关系弄反了，是不可行的。</li></ul><h4 id="5-3-lt-gt-无界通配符"><a href="#5-3-lt-gt-无界通配符" class="headerlink" title="5.3 &lt;?&gt; 无界通配符"></a>5.3 &lt;?&gt; 无界通配符</h4><ul><li>任意类型，如果没有明确，那么就是Object以及任意的Java类了</li><li>无界通配符用&lt;?&gt;表示，?代表了任何的一种类型，能代表任何一种类型的只有null（Object本身也算是一种类型，但却不能代表任何一种类型，所以List<object>和List<null>的含义是不同的，前者类型是Object，也就是继承树的最上层，而后者的类型完全是未知的）。</null></object></li></ul><h3 id="6-可变参数的概述和使用"><a href="#6-可变参数的概述和使用" class="headerlink" title="6.可变参数的概述和使用"></a>6.可变参数的概述和使用</h3><h4 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h4><ul><li>A:可变参数概述:          定义方法的时候不知道该定义多少个参数</li><li>B:格式:                       修饰符 返回值类型 方法名(数据类型…  变量名){}</li><li>C:注意事项：<ul><li>a:    这里的变量其实是一个数组</li><li>b:    如果一个方法有可变参数，并且有多个参数，那么，可变参数肯定是最后一个</li></ul></li></ul><h3 id="7-关于泛型拓展"><a href="#7-关于泛型拓展" class="headerlink" title="7.关于泛型拓展"></a>7.关于泛型拓展</h3><h4 id="7-1-编译器类型检查"><a href="#7-1-编译器类型检查" class="headerlink" title="7.1 编译器类型检查"></a>7.1 编译器类型检查</h4><pre><code>* A.编译器类型检查</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/4432347-b5e6e5cfa996fc1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 在引入泛型之后，通过将代码中的“public class Box”更改为“public class Box&lt;T&gt;”来创建泛型类型的声明，而这个声明的背后实质上是引入了可以在类中任何地方使用的类型变量T。如实例4中所示：可以看到，除了新增的泛型类型声明&lt;T&gt;外，所有在原来代码中出现的Object都被类型变量T所替换。</span><br><span class="line">* 乍一看类型变量这个词，感觉有点晦涩难懂，但其实如果仔细思量一番会发现它其实并不难理解，上面的实例4可以理解为“在使用泛型时，可以将类型参数T传递给Box类型本身”，结合Oracle给出的官方定义“泛型的本质是类型参数化”会有更深的理解。</span><br><span class="line">* 在实例5中，在对象声明和初始化的时候，都指定了类型参数T，在场景一种，T为String；在场景二中，T为Integer。这样，在场景二中向IntegerBox中传入String类型的数据“aaaaa”时，程序会报错。实例6中的泛型集合对象的操作也与之类似，在声明了一个List&lt;String&gt;的boxes对象之后，如果向boxes中传入Integer对象11111，程序会报错。</span><br><span class="line">* 可以看到，通过对于泛型的使用，之前的多业务场景中的问题都得到了解决，因为现在在编译阶段就可以解决之前类型不匹配的问题，而不用等到运行时才暴露问题，只要合理使用泛型，就能在很大程度上规避此类风险。对于泛型的使用，这种参数化类型的作用表面上看是声明，背后其实是约定。</span><br></pre></td></tr></table></figure><h4 id="7-2-可读性和灵活性"><a href="#7-2-可读性和灵活性" class="headerlink" title="7.2 可读性和灵活性"></a>7.2 可读性和灵活性</h4><ul><li>泛型除了能进行编译器类型检查和规避类型强制转换外，还能有效地提高代码的可读性。如果不使用泛型，当一个不清楚业务场景的人在对集合进行操作时，无法知道list中存储的是什么类型的对象，如果使用了泛型，就能够通过其类型参数判断出当前的业务场景，也增加了代码的可读性，同时也可以大胆地在抽象继承的基础上进行开发了。</li><li>泛型使用上的灵活性体现在很多方面，因为它本身实质上就是对于继承在使用上的一种增强。因为泛型在具体工作时，当编译器在编译源码的时候，首先要进行泛型类型参数的检查，检查出类型不匹配等问题，然后进行类型擦除并同时在类型参数出现的位置插入强制转换指令，从而实现泛型。</li></ul><h4 id="7-3-泛型方法和泛型类的比较"><a href="#7-3-泛型方法和泛型类的比较" class="headerlink" title="7.3 泛型方法和泛型类的比较"></a>7.3 泛型方法和泛型类的比较</h4><ul><li>例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;()</span>&#123;</span><br><span class="line">    <span class="comment">//泛型类的成员方法，该T受A后面的T的限制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">memberFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//泛型方法，这里的T和和类A的T是不同的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">genericFunc</span><span class="params">(T a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Integer i = A&lt;String&gt;().findByUserName("s");</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        Set&lt;Integer&gt; set=  A&lt;String&gt;().findByConditions(<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这里<code>Integer i = A&lt;String&gt;().findByUserName(&quot;s&quot;);</code>会编译报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(35, 61) java: 不兼容的类型: java.lang.String无法转换为java.lang.Integer`</span><br></pre></td></tr></table></figure></li><li><p>由这个例子可知，泛型方法的T和和类A的T是不同的。</p></li></ul><h4 id="7-4-泛型擦除案例"><a href="#7-4-泛型擦除案例" class="headerlink" title="7.4 泛型擦除案例"></a>7.4 泛型擦除案例</h4><ul><li><p>泛型是提供给javac编译器使用的，限定集合的输入类型，编译器编译带类型说明的集合时会去掉“类型”信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new GenericTest().testType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testType()&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; collection1 = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; collection2= new ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        System.out.println(collection1.getClass()==collection2.getClass());</span><br><span class="line">        //两者class类型一样,即字节码一致</span><br><span class="line">        </span><br><span class="line">        System.out.println(collection2.getClass().getName());</span><br><span class="line">        //class均为java.util.ArrayList,并无实际类型参数信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">java.util.ArrayList</span><br></pre></td></tr></table></figure></li><li><p><em>使用反射可跳过编译器，往某个泛型集合加入其它类型数据。</em></p><ul><li>只有引用类型才能作为泛型方法的实际参数</li><li>例子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        swap(new String[]&#123;&quot;111&quot;,&quot;222&quot;&#125;,0,1);//编译通过</span><br><span class="line">        </span><br><span class="line">        //swap(new int[]&#123;1,2&#125;,0,1);</span><br><span class="line">        //编译不通过,因为int不是引用类型</span><br><span class="line">        </span><br><span class="line">        swap(new Integer[]&#123;1,2&#125;,0,1);//编译通过</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /*交换数组a 的第i个和第j个元素*/</span><br><span class="line">    public static &lt;T&gt; void swap(T[]a,int i,int j)&#123;</span><br><span class="line">        T temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>但注意基本类型<strong>有时</strong>可以作为实参，因为有<strong>自动装箱</strong>和<strong>拆箱</strong>。</p><ul><li><p>例子(编译通过了)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new GenericTest().testType();</span><br><span class="line">        int a = biggerOne(3,5);</span><br><span class="line">        //int 和 double,取交为Number</span><br><span class="line">        Number b = biggerOne(3,5.5);</span><br><span class="line">        //String和int 取交为Object</span><br><span class="line">        Object c = biggerOne(&quot;1&quot;,2);</span><br><span class="line">    &#125;</span><br><span class="line">    //从x,y中返回y</span><br><span class="line">    public static &lt;T&gt; T biggerOne(T x,T y)&#123;</span><br><span class="line">        return y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同时，该例还表明，<strong>当实参不一致时，T取交集，即第一个共同的父类。</strong></p></li><li><p>另外，如果用<code>Number b = biggerOne(3,5.5);</code>改为<code>String c = biggerOne(3,5.5);</code>则编译报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error:(17, 29) java: 不兼容的类型: 推断类型不符合上限</span><br><span class="line">    推断: java.lang.Number&amp;java.lang.Comparable&lt;? extends java.lang.Number&amp;java.lang.Comparable&lt;?&gt;&gt;</span><br><span class="line">    上限: java.lang.String,java.lang.Object</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="8-泛型和反射"><a href="#8-泛型和反射" class="headerlink" title="8.泛型和反射"></a>8.泛型和反射</h3><h4 id="通过反射获得泛型的实际类型参数"><a href="#通过反射获得泛型的实际类型参数" class="headerlink" title="通过反射获得泛型的实际类型参数"></a>通过反射获得泛型的实际类型参数</h4><ul><li>把泛型变量当成方法的参数，利用Method类的getGenericParameterTypes方法来获取泛型的实际类型参数</li><li><p>例子：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        getParamType();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     /*利用反射获取方法参数的实际参数类型*/</span><br><span class="line">    public static void getParamType() throws NoSuchMethodException&#123;</span><br><span class="line">        Method method = GenericTest.class.getMethod(&quot;applyMap&quot;,Map.class);</span><br><span class="line">        //获取方法的泛型参数的类型</span><br><span class="line">        Type[] types = method.getGenericParameterTypes();</span><br><span class="line">        System.out.println(types[0]);</span><br><span class="line">        //参数化的类型</span><br><span class="line">        ParameterizedType pType  = (ParameterizedType)types[0];</span><br><span class="line">        //原始类型</span><br><span class="line">        System.out.println(pType.getRawType());</span><br><span class="line">        //实际类型参数</span><br><span class="line">        System.out.println(pType.getActualTypeArguments()[0]);</span><br><span class="line">        System.out.println(pType.getActualTypeArguments()[1]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*供测试参数类型的方法*/</span><br><span class="line">    public static void applyMap(Map&lt;Integer,String&gt; map)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Map&lt;java.lang.Integer, java.lang.String&gt;</span><br><span class="line">interface java.util.Map</span><br><span class="line">class java.lang.Integer</span><br><span class="line">class java.lang.String</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java关键字</title>
      <link href="/2019/02/20/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/02/20/java%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="1-常见的关键字"><a href="#1-常见的关键字" class="headerlink" title="1.常见的关键字"></a>1.常见的关键字</h3><ul><li>用于定义数据类型的关键字<blockquote><p>class interface    byte short int long float double char boolean void               </p></blockquote></li><li>用于定义数据类型值的关键字<br>true false null       </li><li>用于定义流程控制的关键字<blockquote><p>if    else switch    case default while do for break    continue return           </p></blockquote></li><li>用于定义访问权限修饰符的关键字<blockquote><p>private    protected public       </p></blockquote></li><li>用于定义类，函数，变量修饰符的关键字<blockquote><p>abstract final static synchronized   </p></blockquote></li><li>用于定义类与类之间关系的关键字<blockquote><p>extends    implements           </p></blockquote></li><li>用于定义建立实例及引用实例，判断实例的关键字<blockquote><p>new    this super instanceof   </p></blockquote></li><li>用于异常处理的关键字<blockquote><p>try    catch finally throw    throws</p></blockquote></li><li>用于包的关键字<blockquote><p>package    import           </p></blockquote></li><li>其他修饰符关键字<blockquote><p>native strictfp transient volatile assert</p></blockquote></li></ul><h3 id="2-关键字的作用说明"><a href="#2-关键字的作用说明" class="headerlink" title="2.关键字的作用说明"></a>2.关键字的作用说明</h3><ul><li>break           <blockquote><p>用在 switch 或者循环语句中，表示中断结束的意思,  跳出循环直接可以结束该语句  </p></blockquote></li><li>continue        <blockquote><p>用在循环语句中，表示中断结束的意思，不过跟 break 有区别,它是退出本次循环后继续执行下一次循环           </p></blockquote></li><li>return          <blockquote><p>常用功能是结束一个方法（退出一个方法），跳转到上层调用的方法</p></blockquote></li><li>interface       <blockquote><p>接口的意思，用来定义接口。</p></blockquote></li><li>static          <blockquote><p>静态修饰符，被修饰后成员被该类所有的对象所共有。也可以通过类名调用</p></blockquote></li><li>private         <blockquote><p>权限修饰符，可以修饰成员变量和成员方法，被修饰的成员只能在本类中被访问        隐藏具体实现细节，提供对外公共访问方法，提高安全性</p></blockquote></li><li>this            <blockquote><p>当成员变量和局部变量名称一样时，需要用 this 修饰，谁调用这个方法,那么该方法的内部的this就代表谁，如果不适用 this ，那么局部变量隐藏了成员变量</p></blockquote></li><li>super           <blockquote><p>代表的是父类存储空间的标识(可以理解成父类的引用,可以操作父类的成员)</p></blockquote></li><li>final           <blockquote><p>由于继承中有一个方法重写的现象,而有时候我们不想让子类去重写父类的方法.<br>  这对这种情况java就给我们提供了一个关键字: final可以修饰类，变量，成员方法。<br>  被修饰类不能被继承；被修饰的方法不能被重写；被修饰的变量不能被重新赋值,因为这个量其实是一个常量。<br>  修饰基本数据类型    指的是值不能被改变；修饰引用数据类型    指的是地址值不能被改变</p></blockquote></li><li>finally         <blockquote><p>被finally控制的语句体一定会执行；特殊情况：在执行到finally之前jvm退出了(比如System.exit(0))<br>  finally的作用:    用于释放资源，在IO流操作和数据库操作中会见到</p></blockquote></li><li>abstract        <blockquote><p>抽象的意思，用来修饰抽象类与抽象方法<br>  abstract 不能和哪些关键字共存?<br>  private    冲突        被private修饰的方法不能被子类继承,就不能被重写,而我们的抽象方法还需要被子类重写<br>  final      冲突        被final修饰的方法,不能被子类重写 , ,而我们的抽象方法还需要被子类重写<br>  static     无意义    因为被static修饰的方法可以通过类名直接访问,但是我们的抽象方法没有方法体,所以这样访问没有意思</p></blockquote></li><li>extends         <blockquote><p>继承的意思，通过它可以类与类之间产生继承关系。</p></blockquote></li><li>implements      <blockquote><p>实现的意思，通过它可以让类与接口之间产生实现关系。</p></blockquote></li><li>instanceof      <blockquote><p>测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据</p></blockquote></li></ul><h3 id="3-重要关键字说明"><a href="#3-重要关键字说明" class="headerlink" title="3.重要关键字说明"></a>3.重要关键字说明</h3><h4 id="3-1-instanceof"><a href="#3-1-instanceof" class="headerlink" title="3.1 instanceof"></a>3.1 instanceof</h4><ul><li>instanceof是Java的一个二元操作符，和==，&gt;，&lt;是同一类东西。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据。</li></ul><h4 id="3-2-final，finally，finalize有什么不同？"><a href="#3-2-final，finally，finalize有什么不同？" class="headerlink" title="3.2 final，finally，finalize有什么不同？"></a>3.2 final，finally，finalize有什么不同？</h4><ul><li><strong>final可以修饰类，方法，变量</strong><ul><li>final修饰类代表类不可以继承拓展</li><li>final修饰变量表示变量不可以修改</li><li>final修饰方法表示方法不可以被重写</li></ul></li><li><strong>finally则是Java保证重点代码一定要被执行的一种机制</strong><ul><li>可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC连接、保证 unlock 锁等动作。</li></ul></li><li><strong>finalize 是基础类 java.lang.Object的一个方法</strong><ul><li>它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9开始被标记为 deprecated。</li></ul></li><li><strong>final 关键字深入理解</strong><ul><li>可以将方法或者类声明为 final，这样就可以明确告知别人，这些行为是不许修改的。</li><li>如果你关注过 Java 核心类库的定义或源码， 有没有发现java.lang 包下面的很多类，相当一部分都被声明成为final class？在第三方类库的一些基础类中同样如此，这可以有效避免 API 使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。</li><li>使用 final 修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成 final。</li><li>final 变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能再赋值 final 变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。</li></ul></li></ul><h4 id="3-3-static"><a href="#3-3-static" class="headerlink" title="3.3 static"></a>3.3 static</h4><ul><li>可以用来修饰：成员变量，成员方法，代码块，内部类等。具体如下所示<ul><li><strong>修饰成员变量和成员方法</strong> <ul><li>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。</li><li>被static 声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。</li></ul></li><li><strong>静态代码块</strong> <ul><li>静态代码块定义在类中方法外,静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)</li><li>该类不管创建多少对象，静态代码块只执行一次.</li></ul></li><li><strong>静态内部类（static修饰类的话只能修饰内部类）</strong> </li><li>静态内部类与非静态内部类之间存在一个最大的区别:<ul><li>非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着：1.它的创建是不需要依赖外围类的创建。2.它不能使用任何外围类的非static成员变量和方法。</li></ul></li><li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong><ul><li>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础总结</title>
      <link href="/2019/02/20/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/20/java%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="0-Java语言概述"><a href="#0-Java语言概述" class="headerlink" title="0.Java语言概述"></a>0.Java语言概述</h4><ul><li><strong>0.1 jdk工具部分exe解释</strong><ul><li>jar.exe       jar包</li><li>javadoc.exe   文档生成器</li><li>Java.exe      解释器</li><li>Javac.exe     编辑器</li></ul></li></ul><ul><li><p><strong>0.2 开发与运行Java程序需经过哪些过程？</strong></p><ul><li>用工具编辑源程序，也就是写代码，保存</li><li>用Java编辑器工具javac.exe编译源程序文件，生成字节码.class文件</li><li>用Java解释器工具Java.exe解释运行生成.class文件</li></ul></li><li><p><strong>0.3 Java是如何实现跨平台的？</strong></p></li><li><p>跨平台是怎样实现的呢？<br>  这就要谈及Java虚拟机（Java Virtual Machine，简称 JVM）。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JVM也是一个软件，不同的平台有不同的版本。我们编写的Java源码，编译后会生成一种 .class 文件，称为字节码文件。</span><br><span class="line">Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码然后运行。也就是说，只要在不同平台上安装对应的JVM，</span><br><span class="line">就可以运行字节码文件，运行我们编写的Java程序。而这个过程中，我们编写的Java程序没有做任何改变，仅仅是通过JVM</span><br><span class="line">这一”中间层“，就能在不同平台上运行，真正实现了”一次编译，到处运行“的目的。JVM是一个”桥梁“，是一个”中间件“,</span><br><span class="line">是实现跨平台的关键，Java代码首先被编译成字节码文件，再由JVM将字节码文件翻译成机器语言，从而达到运行Java</span><br><span class="line">程序的目的。</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行。<br>        不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。<br>        所以，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须要经过JVM的再次翻译才能执行。<br>        即使你将Java程序打包成可执行文件（例如 .exe），仍然需要JVM的支持。</p></blockquote><blockquote><p>注意：跨平台的是Java程序，不是JVM。JVM是用C/C++开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的JVM。</p></blockquote><h4 id="1-Java标识符规则"><a href="#1-Java标识符规则" class="headerlink" title="1.Java标识符规则"></a>1.Java标识符规则</h4><ul><li><strong>1.1 组成规则</strong><ul><li>英文大小写字母</li><li>数字字符</li><li>$或_</li></ul></li><li><strong>1.2 注意事项</strong><ul><li>不能以数字开头</li><li>不能是Java中的关键字</li><li>区分大小写</li><li>不能有空格</li></ul></li><li><strong>1.3 命名规范【必须见名知意】</strong><ul><li>下划线式命名：my_name</li><li>驼峰式命名：myName</li><li>类，接口命名：必须是大写字母开头，比如PersonActivity</li><li>方法，变量【字符串】命名：getData()，otherName</li><li>常量命名：一般全是大写，比如MAX_VALUE</li></ul></li></ul><h4 id="2-常量和变量"><a href="#2-常量和变量" class="headerlink" title="2.常量和变量"></a>2.常量和变量</h4><ul><li><strong>2.1 什么是常量和变量</strong><ul><li>其值不可以改变的称之为常量</li><li>其值会发生变化的称之为变量</li></ul></li><li><strong>2.2 常量有哪些</strong><ul><li>字符串常量     用双引号包括的     “hello world”</li><li>整型常量         所有的整数     199</li><li>小数常量         所有的小数     4.50</li><li>字符常量         用单引号包括的     ‘a’</li><li>布尔常量         true和false    </li><li>空常量            null</li></ul></li><li><strong>2.3 变量</strong><ul><li>用来描述值可以变化的量，比如室外温度，App活跃用户量等</li></ul></li></ul><h4 id="3-进制"><a href="#3-进制" class="headerlink" title="3.进制"></a>3.进制</h4><ul><li><strong>3.1 进制有哪些</strong></li><li>二进制<ul><li>0和1     前缀0B或者0b       比如：0B1001      转为十进制是9</li></ul></li><li>八进制<ul><li>0-7       前缀0       比如：0103       </li></ul></li><li>十进制【我们常用的】<ul><li>0-9       没有前缀</li></ul></li><li>十六进制<ul><li>0-9 和 A-F     前缀0x或者0X          比如：0x123</li></ul></li><li>进制转化<ul><li>任何进制转化为十进制公式：系数 * 底数 ^ 指数</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0b1010 = 1 * 2^3 + 0 *2^2 + 1*2^1 + 0*2^0</span><br><span class="line">       = 8 + 0 + 2 + 0</span><br><span class="line">       = 10</span><br><span class="line"></span><br><span class="line">0123  = 1*8^2 + 2*8^1 + 3*8^0</span><br><span class="line">      = 64 + 16 + 3</span><br><span class="line">      = 83</span><br><span class="line"></span><br><span class="line">0x123 = 1*16^2 + 2*16^1 + 3*16^0</span><br><span class="line">      = 256 + 32 + 3</span><br><span class="line">      = 291</span><br></pre></td></tr></table></figure><ul><li><strong>3.2 补码</strong><ul><li>正数的补码和原码相同</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">原码：0000 0101</span><br><span class="line">补码：0000 0101</span><br><span class="line">* 负数的补码是它的反码加1</span><br><span class="line"></span><br><span class="line">-5：</span><br><span class="line">原码：1000 0101</span><br><span class="line">反码：1111 1010</span><br><span class="line">    +         1</span><br><span class="line">------------------</span><br><span class="line">补码  1111 1011</span><br></pre></td></tr></table></figure><h4 id="4-Java数据类型"><a href="#4-Java数据类型" class="headerlink" title="4.Java数据类型"></a>4.Java数据类型</h4><ul><li><strong>4.1 数据类型有哪些</strong></li><li>byte类型<ul><li>1个字节，8位【-128到127之间】</li></ul></li><li>short类型<ul><li>2个字节，16位【-2^15 到 2^15 -1】</li></ul></li><li>int类型<ul><li>4个字节，32位【-2^31 到 2^31 -1】</li></ul></li><li>float类型【浮点型】<ul><li>4个字节，32位</li></ul></li><li>double类型【浮点型】<ul><li>8个字节，64位</li></ul></li><li>long类型<ul><li>8个字节，64位【-2^63  到 2^63 -1】</li></ul></li><li>char类型<ul><li>2个字节，16位【1个汉字刚好2个字节】</li></ul></li><li>boolean类型<ul><li>1个字节，true和false</li></ul></li></ul><ul><li><strong>4.2 数据的转换</strong></li><li>默认转换<ul><li>1：byte,short,char—int—long—float—double</li><li>2：byte,short,char相互之间补转换，他们参与运算首先转换为int类型</li></ul></li><li>强制转换<ul><li>格式: 目标类型 变量名 = (目标类型)值或变量名</li><li>int a = (int) 15.7f;</li></ul></li><li>注意要点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!!!!!!!注意!!!!!!!!</span><br><span class="line">1:在java中，任何一个整数默认为 int 类型 (1)</span><br><span class="line">2:在java种，任何一个小数，默认为 double 类型( 1.0)</span><br><span class="line">3:123L 或者 1231 编译器会将该数当成long类型</span><br><span class="line">4:12.345f 或者12.345F 编译器会将该数当成float类型</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-字符编码"><a href="#5-字符编码" class="headerlink" title="5.字符编码"></a>5.字符编码</h4><ul><li>常见的字符编码<ul><li>ASCII码</li><li>GBK码</li><li>Unicode码【占2个字节】</li></ul></li></ul><h4 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6.运算符"></a>6.运算符</h4><ul><li><strong>6.1 运算符有哪些？</strong><ul><li>算术运算符</li><li>赋值运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>三目运算符</li><li>特殊运算符：位运算符</li></ul></li><li><strong>6.2 算术运算符</strong><ul><li><ul><li>，- ， * ， / ， %【取余】 ， ++【自加】， –【自减】</li></ul></li></ul></li><li><strong>6.3 赋值运算符</strong><ul><li>= ， += ， -= ， *= ， /= ， %= </li></ul></li><li><strong>6.4 关系运算符</strong><ul><li>== ， &gt; , &lt; , &gt;= , &lt;= , !=</li></ul></li><li><strong>6.5 逻辑运算符</strong><ul><li>&amp; ，^ ，| ，&amp;&amp; ，|| ，！ ， ^</li></ul></li><li><strong>6.6 三目运算符【Android中用的很多】</strong><ul><li>a == b ？ c ： d</li><li>格式：(条件表达式)？表达式1：表达式2</li></ul></li><li><strong>6.7 位运算符</strong><ul><li>&amp; , |   ,  ^ ,  ~  ,  &lt;&lt;  ,  &gt;&gt;  ,  &gt;&gt;&gt;</li></ul></li></ul><h4 id="7-Java基本语句结构"><a href="#7-Java基本语句结构" class="headerlink" title="7.Java基本语句结构"></a>7.Java基本语句结构</h4><ul><li><strong>7.1 语句结构种类</strong><ul><li>顺序结构</li><li>选择结构</li><li>循环结构</li></ul></li><li><strong>7.2 顺序结构</strong><ul><li>从上到下依次执行</li></ul></li><li><strong>7.3 选择结构【可以嵌套】</strong><ul><li>if  ，  if  else  ， if  else if …… else</li><li>switch case【支持byte，short，char，int，String】</li></ul></li><li><strong>7.4 循环结构</strong></li><li><p>for</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(初始化语句;判断条件语句;控制条件语句) &#123;</span><br><span class="line">         循环体语句;</span><br><span class="line">&#125;</span><br><span class="line">第一步：先执行初始化语句，只执行一次</span><br><span class="line">第二步：执行判断条件语句</span><br><span class="line">第三部：执行循环体语句</span><br><span class="line">第四步：执行控制条件语句，然后再执行循环体语句【循环】</span><br></pre></td></tr></table></figure></li><li><p>while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line">while(判断条件语句) &#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">    控制条件语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">         循环体语句;</span><br><span class="line">&#125;while((判断条件语句);</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-Java方法"><a href="#8-Java方法" class="headerlink" title="8.Java方法"></a>8.Java方法</h4><ul><li><strong>8.1 定义</strong></li><li>方法就是完成特定功能的代码块<ul><li>1：系统方法，只需要会使用，不需要知道内部的结构</li><li>2：自定义方法：方法的内部实现需要我们来写</li><li>3：方法内部不能再嵌套方法</li></ul></li></ul><ul><li><strong>8.2 格式</strong></li><li><p>方法格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符   返回值类型   方法名(参数类型 参数 , ……)&#123;</span><br><span class="line">     函数体</span><br><span class="line">     return 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修饰符: public static或直接是public或是其它private</p></li><li>返回类型:所有的数据类型（基本类型：int ,char ,float, long, 引用类型:String）</li><li>方法名：1:见名知意 2: getMax</li><li>参数类型:所有的数据类型 ，如果一个方法没有返回值，则返回值类型为void</li><li>参数名:变量名</li><li>返回值：就是要返回的结果（这个结果必须和返回类型一致）</li></ul><h4 id="9-数组"><a href="#9-数组" class="headerlink" title="9.数组"></a>9.数组</h4><ul><li><strong>9.1 数组概念</strong><ul><li>数组是一个容器，可以存储多个变量，这些变量数据类型要一致</li><li>数组既可以存储基本数据类型，也可以存储引用数据类型</li></ul></li></ul><ul><li><strong>9.2 一维数组</strong></li><li><p>数组定义格式</p><ul><li>格式1：数据类型【】 数组名</li><li>格式2：数据类型   数组名【】<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] a；     定义了一个int类型的数组a；</span><br><span class="line">int a[];    定义了一个int类型的a数组；</span><br><span class="line">推荐使用第一种定义方式。</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组的初始化</p><ul><li>Java中的数组必须先初始化,然后才能使用。</li><li>所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。</li></ul></li></ul><ul><li>初始化分类：<ul><li>a:动态初始化:   只指定长度，由系统给出初始化值</li><li>b:静态初始化:    给出初始化值，由系统决定长度</li><li>注意事项：这两种方式，只能使用一种，不能进行动静结合   </li></ul></li></ul><ul><li><strong>9.3 二维数组</strong></li><li>数组定义格式<ul><li>数据类型[][] 变量名 = new 数据类型[m][n];</li><li>m表示这个二维数组有多少个一维数组</li><li>n表示每一个一维数组的元素个数</li></ul></li></ul><ul><li>举例:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr = new int[3][2];</span><br><span class="line">定义了一个二维数组arr</span><br><span class="line">这个二维数组有3个一维数组，名称是arr[0],arr[1],arr[2]</span><br><span class="line">每个一维数组有2个元素，可以通过arr[m][n]来获取,表示获取第m+1个一维数组的第n+1个元素</span><br></pre></td></tr></table></figure><h4 id="10-Java的内存分配以及栈和堆的区别"><a href="#10-Java的内存分配以及栈和堆的区别" class="headerlink" title="10.Java的内存分配以及栈和堆的区别"></a>10.Java的内存分配以及栈和堆的区别</h4><ul><li><strong>10.1 先了解几个概念</strong><ul><li>栈</li><li>堆</li><li>方法区</li><li>本地方法去</li><li>寄存器</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A:栈: 存放的是局部变量</span><br><span class="line">局部变量：在方法定义或者方法声明上的变量都是局部变量。</span><br><span class="line">B:堆: 存放的是所有new出来的东西</span><br><span class="line">特点：</span><br><span class="line">    a: 每一个new出来的东西都会为其分配一个地制值。</span><br><span class="line">    b: 每一个变量都有一个默认的值</span><br><span class="line">        byte，short，int，long  -- 0</span><br><span class="line">        float，double            -- 0.0</span><br><span class="line">        char                    -- &apos;\u0000&apos;</span><br><span class="line">        boolean                -- false</span><br><span class="line">        引用数据类型               -- null       </span><br><span class="line">    c: 使用完毕就变成了垃圾，等待垃圾回收器对其回收</span><br><span class="line">C:方法区:(面向对象部分讲解)</span><br><span class="line">D:本地方法区:(和系统相关)</span><br><span class="line">E:寄存器:(cpu使用)</span><br></pre></td></tr></table></figure><h4 id="11-使用switch和if-else区别"><a href="#11-使用switch和if-else区别" class="headerlink" title="11.使用switch和if-else区别"></a>11.使用switch和if-else区别</h4><ul><li><strong>11.1 switch语句特点</strong></li><li>使用switch语句时，要注意表达式必须是符合byte，char，short，int或枚举类型的表达式，而不能使用浮点类型或long类型。</li><li>switch语句将表达式的值依次与每个case子语句中的常量值相比较。如果匹配成功，则执行该case语句中的语句，直到遇到break语句为止。</li><li>default语句是可选的，当表达式的值与任何一个case语句都不匹配时，就执行default后的语句。</li></ul><ul><li><strong>11.2 switch语句与if-else比较</strong></li><li>if-else只是单纯地一个接一个比较；if…else每个条件都计算一遍；</li><li>使用了Binary，Tree算法；绝大部分情况下switch会快一点，除非是if-else的第一个条件就为true。编译器编译switch与编译if…else…不同。不管有多少case，都直接跳转，不需逐个比较查询；switch只计算一次值，然后都是test , jmp……有很多else if的时候，用switch case比较清晰</li><li>switch…case与if…else，if的根本区别在于，switch…case会生成一个跳转表来指示实际的case分支的地址，而这个跳转表的索引号与switch变量的值是相等的。从而，switch…case不用像if…else那样遍历条件分支直到命中条件，而只需访问对应索引号的表项从而到达定位分支的目的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IO流注意事项</title>
      <link href="/2019/02/19/IO%E6%B5%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2019/02/19/IO%E6%B5%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="IO流其他知识"><a href="#IO流其他知识" class="headerlink" title="IO流其他知识"></a>IO流其他知识</h4><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul><li>1.字符流出现的原因</li><li>2.String中的编解码问题[理解]</li><li>3.转换流[掌握]<ul><li>3.1 转换流OutputStreamWriter的使用</li><li>3.2 转换流InputStreamReader的使用</li><li>3.3 字符流的5种写数据的方式</li><li>3.4 字符流的2种读数据的方式</li><li>3.5 高效流FileWriter和FileReader</li><li>3.6 字符缓冲流的基本使用</li><li>3.7 字符缓冲流的特殊功能</li></ul></li><li>4.IO流的练习题<ul><li>4.1 字符流复制文本文件</li><li>4.2 FileWriter和FileReader复制文本文件</li><li>4.3 字符缓冲流的特殊功能复制文本文件</li><li>4.4 把集合中的数据存储到文本文件</li><li>4.5 把文本文件中的数据存储到集合中</li><li>4.6 随机获取文本文件中的姓名</li><li>4.7 复制单级文件夹</li><li>4.8 复制指定目录下指定后缀名的文件并修改名称</li><li>4.7和4.8工具类</li><li>4.9 键盘录入学生信息按照总分排序并写入文本文件</li></ul></li><li>5.IO流大总结<ul><li>5.1 按操作方式分类结构图</li><li>5.2 按操作对象分类结构图</li></ul></li></ul><h3 id="1-字符流出现的原因"><a href="#1-字符流出现的原因" class="headerlink" title="1.字符流出现的原因"></a>1.字符流出现的原因</h3><h4 id="1-1-字符流出现的原因及编码表概述"><a href="#1-1-字符流出现的原因及编码表概述" class="headerlink" title="1.1 字符流出现的原因及编码表概述"></a>1.1 字符流出现的原因及编码表概述</h4><ul><li>字符流出现的原因:由于字节流操作中文不是特别方便，所以，java就提供了字符流。</li><li>字符流:  字符流 = 字节流 + 编码表</li></ul><h3 id="2-String中的编解码问题"><a href="#2-String中的编解码问题" class="headerlink" title="2.String中的编解码问题"></a>2.String中的编解码问题</h3><h4 id="2-1-String类中的编码和解码问题"><a href="#2-1-String类中的编码和解码问题" class="headerlink" title="2.1 String类中的编码和解码问题"></a>2.1 String类中的编码和解码问题</h4><ul><li>String(byte[] bytes, String charsetName):通过指定的字符集解码字节数组</li><li>byte[] getBytes(String charsetName):使用指定的字符集合把字符串编码为字节数组</li><li>编码:把看得懂的变成看不懂的:    String – byte[]</li><li>解码:把看不懂的变成看得懂的:    byte[] – String</li></ul><h3 id="3-转换流-掌握"><a href="#3-转换流-掌握" class="headerlink" title="3.转换流[掌握]"></a>3.转换流[掌握]</h3><h4 id="3-1-转换流OutputStreamWriter的使用"><a href="#3-1-转换流OutputStreamWriter的使用" class="headerlink" title="3.1 转换流OutputStreamWriter的使用"></a>3.1 转换流OutputStreamWriter的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 字符输出流:OutputStreamWriter (转换输出流)字符流通向字节流的桥梁</span><br><span class="line"> * 构造方法:</span><br><span class="line"> * public OutputStreamWriter(OutputStream out): 使用默认字符集</span><br><span class="line"> * public OutputStreamWriter(OutputStream out , String charsetName):使用指定的字符集</span><br><span class="line"> * 字符输入流:InputStreamReader  (转换输入流)字节流通向字符流的桥梁</span><br><span class="line"> * 构造方法:</span><br><span class="line"> * public InputStreamReader(InputStream in)使用的默认的编码表(GBK)</span><br><span class="line"> * public InputStreamReader(InputStream in , String charsetName)使用指定的编码表</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class OutputStreamWriterDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">// 创建: OutputStreamWriter</span><br><span class="line">// 创建: OutputStream的对象</span><br><span class="line">//FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;) ;</span><br><span class="line">//OutputStreamWriter osw = new OutputStreamWriter(fos) ;</span><br><span class="line">//OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;)) ;</span><br><span class="line">// public InputStreamReader(InputStream in , String charsetName)使用指定的编码表</span><br><span class="line">OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;a.txt&quot;) , &quot;UTF-8&quot;) ;</span><br><span class="line">// 调用方法</span><br><span class="line">osw.write(&quot;中国&quot;) ;</span><br><span class="line">// 释放资源</span><br><span class="line">osw.close() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-转换流InputStreamReader的使用"><a href="#3-2-转换流InputStreamReader的使用" class="headerlink" title="3.2 转换流InputStreamReader的使用"></a>3.2 转换流InputStreamReader的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class InputStreamReaderDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">// 创建对象InputStreamReader的对象</span><br><span class="line">// public InputStreamReader(InputStream in): 使用的默认的编码表(GBK)</span><br><span class="line">//FileInputStream fis = new FileInputStream(&quot;a.txt&quot;) ;</span><br><span class="line">//InputStreamReader isr = new InputStreamReader(fis) ;</span><br><span class="line">//InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;)) ;// 默认的字符集就是GBK</span><br><span class="line"></span><br><span class="line">// public InputStreamReader(InputStream in , String charsetName)使用指定的编码表</span><br><span class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;a.txt&quot;) , &quot;utf-8&quot;) ;</span><br><span class="line">// 读取数据</span><br><span class="line">int ch = 0 ;</span><br><span class="line">while((ch = isr.read()) != -1)&#123;</span><br><span class="line">System.out.print((char)ch);</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">isr.close() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-字符流的5种写数据的方式"><a href="#3-3-字符流的5种写数据的方式" class="headerlink" title="3.3 字符流的5种写数据的方式"></a>3.3 字符流的5种写数据的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void write(int c)</span><br><span class="line">public void write(char[] cbuf)</span><br><span class="line">public void write(char[] cbuf,int off,int len)</span><br><span class="line">public void write(String str)</span><br><span class="line">public void write(String str,int off,int len)</span><br></pre></td></tr></table></figure><h4 id="3-4-字符流的2种读数据的方式"><a href="#3-4-字符流的2种读数据的方式" class="headerlink" title="3.4 字符流的2种读数据的方式"></a>3.4 字符流的2种读数据的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public int read()</span><br><span class="line">public int read(char[] cbuf)</span><br></pre></td></tr></table></figure><h4 id="3-5-高效流FileWriter和FileReader"><a href="#3-5-高效流FileWriter和FileReader" class="headerlink" title="3.5 高效流FileWriter和FileReader"></a>3.5 高效流FileWriter和FileReader</h4><h4 id="3-6-字符缓冲流的基本使用"><a href="#3-6-字符缓冲流的基本使用" class="headerlink" title="3.6 字符缓冲流的基本使用"></a>3.6 字符缓冲流的基本使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 高效的字符输入流BufferedReader</span><br><span class="line"> * 高效的字符输出流BufferedWriter</span><br><span class="line"> */</span><br><span class="line">public class BufferedWriterDemo &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//写数据的方式</span><br><span class="line">//write() ;</span><br><span class="line">// 读取数据的方式</span><br><span class="line">read() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用高效的字符输入流进行读取数据</span><br><span class="line"> * @throws IOException</span><br><span class="line"> */</span><br><span class="line">private static void read() throws IOException&#123;</span><br><span class="line">// 创建高效的字符输入流对象</span><br><span class="line">// public BufferedReader(Reader in)</span><br><span class="line">//BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;c.txt&quot;))) ;</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;c.txt&quot;)) ;</span><br><span class="line">// 读取数据</span><br><span class="line">//int ch = 0 ;</span><br><span class="line">//while((ch = br.read()) != -1)&#123;</span><br><span class="line">//System.out.print((char)ch);</span><br><span class="line">//&#125;</span><br><span class="line">char[] chs = new char[1024] ;</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = br.read(chs)) != -1)&#123;</span><br><span class="line">System.out.print(new String(chs , 0 , len));</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">br.close() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用高效的字符输出流进行写数据</span><br><span class="line"> * @throws IOException </span><br><span class="line"> */</span><br><span class="line">private static void write() throws IOException &#123;</span><br><span class="line">// 创建BufferedWriter对象</span><br><span class="line">// public BufferedWriter(Writer out)</span><br><span class="line">//OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;c.txt&quot;)) ;</span><br><span class="line">//BufferedWriter bw = new BufferedWriter(osw) ;</span><br><span class="line">//BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;c.txt&quot;))) ;</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;c.txt&quot;)) ;</span><br><span class="line">// 写数据</span><br><span class="line">bw.write(&quot;你好&quot;) ;</span><br><span class="line">// 释放资源</span><br><span class="line">bw.close() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-字符缓冲流的特殊功能"><a href="#3-7-字符缓冲流的特殊功能" class="headerlink" title="3.7 字符缓冲流的特殊功能"></a>3.7 字符缓冲流的特殊功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter:public void newLine():根据系统来决定换行符</span><br><span class="line">BufferedReader:public String readLine()：一次读取一行数据</span><br><span class="line">包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null</span><br></pre></td></tr></table></figure><h3 id="4-IO流的练习题"><a href="#4-IO流的练习题" class="headerlink" title="4.IO流的练习题"></a>4.IO流的练习题</h3><h4 id="4-1-字符流复制文本文件"><a href="#4-1-字符流复制文本文件" class="headerlink" title="4.1 字符流复制文本文件"></a>4.1 字符流复制文本文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class CopyFileDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">// 创建转换输入流对象</span><br><span class="line">InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;OutputStreamWriterDemo.java&quot;)) ;</span><br><span class="line">// 创建转换输出流对象</span><br><span class="line">OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;copyFile.java&quot;)) ;</span><br><span class="line">// 复制文件</span><br><span class="line">// 一次读取一个字符复制</span><br><span class="line">//int ch = 0 ;</span><br><span class="line">//while((ch = isr.read()) != -1)&#123;</span><br><span class="line">//osw.write(ch) ;</span><br><span class="line">//&#125;</span><br><span class="line">// 一次读取一个字符数组复制文件</span><br><span class="line">char[] chs = new char[1024] ;</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = isr.read(chs)) != -1)&#123;</span><br><span class="line">osw.write(chs, 0, len) ;</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">osw.close() ;</span><br><span class="line">isr.close() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-FileWriter和FileReader复制文本文件"><a href="#4-2-FileWriter和FileReader复制文本文件" class="headerlink" title="4.2 FileWriter和FileReader复制文本文件"></a>4.2 FileWriter和FileReader复制文本文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class CopyFileDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">// 创建高效的字符输入流对象</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;OutputStreamWriterDemo.java&quot;)) ;</span><br><span class="line">// 创建高效的字符输出流对象</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;copyFile3.java&quot;)) ;</span><br><span class="line">// 一次读取一个字符数组复制文件</span><br><span class="line">char[] chs = new char[1024] ;</span><br><span class="line">int len = 0;</span><br><span class="line">while((len = br.read(chs)) != -1)&#123;</span><br><span class="line">bw.write(chs, 0, len) ;</span><br><span class="line">&#125; </span><br><span class="line">// 释放资源</span><br><span class="line">bw.close() ;</span><br><span class="line">br.close() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-字符缓冲流的特殊功能复制文本文件"><a href="#4-3-字符缓冲流的特殊功能复制文本文件" class="headerlink" title="4.3 字符缓冲流的特殊功能复制文本文件"></a>4.3 字符缓冲流的特殊功能复制文本文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CopyFileDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">/**</span><br><span class="line"> * 需求: 使用高效的字符流中特有的功能复制文本文件</span><br><span class="line"> */</span><br><span class="line">// 创建高效的字符输入流对象</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;OutputStreamWriterDemo.java&quot;)) ;</span><br><span class="line"></span><br><span class="line">// 高效的字符输出流对象</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;copyFile4.java&quot;)) ;</span><br><span class="line"></span><br><span class="line">// 复制文件</span><br><span class="line">// 一次读取一行复制文件</span><br><span class="line">String line = null ;</span><br><span class="line">while((line = br.readLine()) != null) &#123;</span><br><span class="line">bw.write(line) ;</span><br><span class="line">bw.newLine() ;</span><br><span class="line">bw.flush() ;</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">bw.close() ;</span><br><span class="line">br.close() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-把集合中的数据存储到文本文件"><a href="#4-4-把集合中的数据存储到文本文件" class="headerlink" title="4.4 把集合中的数据存储到文本文件"></a>4.4 把集合中的数据存储到文本文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">/**</span><br><span class="line"> * 把ArrayList集合中的数据存储到文本文件中</span><br><span class="line"> * 分析:</span><br><span class="line"> * 1: 创建ArrayList集合对象</span><br><span class="line"> * 2: 添加数据</span><br><span class="line"> * 3: 创建高效的字符输出流对象</span><br><span class="line"> * 4: 遍历集合,获取每一个元素,然后通过流对象写出去</span><br><span class="line"> * 5: 释放资源</span><br><span class="line"> */</span><br><span class="line">// 创建ArrayList集合对象</span><br><span class="line">ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;() ;</span><br><span class="line">// 添加数据</span><br><span class="line">al.add(&quot;西施&quot;) ;</span><br><span class="line">al.add(&quot;貂蝉&quot;) ;</span><br><span class="line">al.add(&quot;杨玉环&quot;) ;</span><br><span class="line">al.add(&quot;王昭君&quot;) ;</span><br><span class="line">// 创建高效的字符输出流对象</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;names.txt&quot;)) ;</span><br><span class="line">// 遍历集合,获取每一个元素,然后通过流对象写出去</span><br><span class="line">for(String name : al) &#123;</span><br><span class="line">bw.write(name) ;</span><br><span class="line">bw.newLine() ;</span><br><span class="line">bw.flush() ;</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">bw.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-把文本文件中的数据存储到集合中"><a href="#4-5-把文本文件中的数据存储到集合中" class="headerlink" title="4.5 把文本文件中的数据存储到集合中"></a>4.5 把文本文件中的数据存储到集合中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">/**</span><br><span class="line"> * 从文本文件中读取数据(每一行为一个字符串数据)到集合中，并遍历集合</span><br><span class="line"> * 分析:</span><br><span class="line"> * 1: 创建高效的字符输入流对象</span><br><span class="line"> * 2: 创建集合对象</span><br><span class="line"> * 3: 读取文本文件中的数据,将数据存储到集合中</span><br><span class="line"> * 4: 释放资源</span><br><span class="line"> * 5: 遍历集合</span><br><span class="line"> */</span><br><span class="line">// 1: 创建高效的字符输入流对象</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;names.txt&quot;)) ;</span><br><span class="line">// 2: 创建集合对象</span><br><span class="line">ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;() ;</span><br><span class="line">// 3: 读取文本文件中的数据,将数据存储到集合中</span><br><span class="line">String line = null ;// 作用: 用来记录读取到的行数据</span><br><span class="line">while((line = br.readLine()) != null) &#123;</span><br><span class="line">al.add(line) ;</span><br><span class="line">&#125;</span><br><span class="line">// 4: 释放资源</span><br><span class="line">br.close() ;</span><br><span class="line">// 5: 遍历集合</span><br><span class="line">for(String name : al) &#123;</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-随机获取文本文件中的姓名"><a href="#4-6-随机获取文本文件中的姓名" class="headerlink" title="4.6 随机获取文本文件中的姓名"></a>4.6 随机获取文本文件中的姓名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">// 1: 创建集合对象</span><br><span class="line">ArrayList&lt;String&gt; students = new ArrayList&lt;String&gt; () ;</span><br><span class="line">// 2: 创建BufferedReader对象</span><br><span class="line">BufferedReader br = new BufferedReader(new FileReader(&quot;students.txt&quot;)) ;</span><br><span class="line">// 3: 读取数据,把数据存储到集合中</span><br><span class="line">String line = null ;</span><br><span class="line">while((line = br.readLine()) != null) &#123;</span><br><span class="line">students.add(line) ;</span><br><span class="line">&#125;</span><br><span class="line">// 4: 释放资源</span><br><span class="line">br.close() ;</span><br><span class="line">// 5: 生成一个随机数</span><br><span class="line">Random random = new Random() ;</span><br><span class="line">int index = random.nextInt(students.size());</span><br><span class="line">// 6: 把生成的随机数作为集合元素的索引,来获取一个元素</span><br><span class="line">String name = students.get(index) ;</span><br><span class="line">// 7: 把获取到的元素打印到控制台</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-复制单级文件夹"><a href="#4-7-复制单级文件夹" class="headerlink" title="4.7 复制单级文件夹"></a>4.7 复制单级文件夹</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">/**</span><br><span class="line"> * 需求: 把C:\\course这个文件夹复制到D:\\course盘下</span><br><span class="line"> * 分析:</span><br><span class="line"> * 1: 把C:\\course这个目录封装成一个File对象</span><br><span class="line"> * 2: 把D:\\course这个目录封装成一个File对象</span><br><span class="line"> * 3: 判断D:\\course是否存在,如果存在就创建一个文件夹</span><br><span class="line"> * 4: 获取C:\\course这个目录下所有的文件对应的File数组</span><br><span class="line"> * 5: 遍历数组,获取元素进行复制</span><br><span class="line"> */</span><br><span class="line">// 把C:\\course这个目录封装成一个File对象</span><br><span class="line">File srcFolder = new File(&quot;C:\\course&quot;) ;</span><br><span class="line">// 把D:\\course这个目录封装成一个File对象</span><br><span class="line">File destFolder = new File(&quot;D:\\course&quot;) ;</span><br><span class="line">// 判断D:\\course是否存在,如果存在就创建一个文件夹</span><br><span class="line">if(!destFolder.exists())&#123;</span><br><span class="line">destFolder.mkdir() ;</span><br><span class="line">&#125;</span><br><span class="line">// 复制文件夹</span><br><span class="line">IOUtils.copyFolder(srcFolder, destFolder, null) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-8-复制指定目录下指定后缀名的文件并修改名称"><a href="#4-8-复制指定目录下指定后缀名的文件并修改名称" class="headerlink" title="4.8 复制指定目录下指定后缀名的文件并修改名称"></a>4.8 复制指定目录下指定后缀名的文件并修改名称</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">/**</span><br><span class="line"> * 把C:\\demo这个目录下所有的以.java结尾的文件复制到D:\\demo中,然后将这个文件的后缀名更改为.jad</span><br><span class="line"> */</span><br><span class="line">// 把C:\\demo这个目录下所有的以.java结尾的文件复制到D:\\demo中</span><br><span class="line">// 1: 把C:\\demo这个目录封装成一个File对象</span><br><span class="line">File srcFolder = new File(&quot;C:\\demo&quot;) ;</span><br><span class="line">// 2: 把D:\\demo这么目录封装成一个File对象</span><br><span class="line">File destFolder = new File(&quot;D:\\demo&quot;) ;</span><br><span class="line">// 3: 判断D:\\demo这个路径是否存在</span><br><span class="line">if(!destFolder.exists()) &#123;</span><br><span class="line">destFolder.mkdir() ;</span><br><span class="line">&#125;</span><br><span class="line">// 调用方法</span><br><span class="line">IOUtils.copyFolder(srcFolder, destFolder, new FilenameFilter() &#123;</span><br><span class="line">@Override</span><br><span class="line">public boolean accept(File dir, String name) &#123;</span><br><span class="line">return new File(dir , name).isFile() &amp;&amp; name.endsWith(&quot;.java&quot;) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;) ;</span><br><span class="line">System.out.println(&quot;-----------------------------------------------------&quot;);</span><br><span class="line">// 获取destFolder下所有的文件对应的File数组</span><br><span class="line">File[] files = destFolder.listFiles() ;</span><br><span class="line">for(File f : files) &#123;</span><br><span class="line">// 创建目标文件名称</span><br><span class="line">String destFileName = f.getName().replace(&quot;.java&quot;, &quot;.jad&quot;) ;</span><br><span class="line">// 创建目标文件</span><br><span class="line">File destFile = new File(destFolder , destFileName) ;</span><br><span class="line">// 调用</span><br><span class="line">f.renameTo(destFile) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7和4-8工具类"><a href="#4-7和4-8工具类" class="headerlink" title="4.7和4.8工具类"></a>4.7和4.8工具类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class IOUtils &#123;</span><br><span class="line"></span><br><span class="line">public static void copyFolder(String srcPahtName , String destPathName , FilenameFilter filenameFilter) throws IOException &#123;</span><br><span class="line">File srcFolder = new File(srcPahtName) ;</span><br><span class="line">File destFolder = new File(destPathName) ;</span><br><span class="line">if(!destFolder.exists()) &#123;</span><br><span class="line">destFolder.mkdir() ;</span><br><span class="line">&#125;</span><br><span class="line">copyFolder(srcFolder , destFolder , filenameFilter) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void copyFolder(File srcFolder , File destFolder , FilenameFilter filenameFilter) throws IOException &#123;</span><br><span class="line">File[] files = null ;</span><br><span class="line">if(filenameFilter == null) &#123;</span><br><span class="line">files = srcFolder.listFiles() ;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">files = srcFolder.listFiles(filenameFilter) ;</span><br><span class="line">&#125;</span><br><span class="line">// 遍历</span><br><span class="line">for(File f : files) &#123;</span><br><span class="line">// 创建目标文件</span><br><span class="line">String destFileName = f.getName() ;</span><br><span class="line">File destFile = new File(destFolder , destFileName) ; </span><br><span class="line">// 复制文件</span><br><span class="line">copyFile(f , destFile) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public static void copyFile(File srcFile , File destFile) throws IOException &#123;</span><br><span class="line">// 创建流对象</span><br><span class="line">BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile)) ;</span><br><span class="line">BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile)) ;</span><br><span class="line"></span><br><span class="line">// 一次读取一个字节数组复制文件</span><br><span class="line">byte[] bytes = new byte[1024] ;</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = bis.read(bytes)) != -1)&#123;</span><br><span class="line">bos.write(bytes, 0, len) ;</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">bos.close() ;</span><br><span class="line">bis.close() ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-9-键盘录入学生信息按照总分排序并写入文本文件"><a href="#4-9-键盘录入学生信息按照总分排序并写入文本文件" class="headerlink" title="4.9 键盘录入学生信息按照总分排序并写入文本文件"></a>4.9 键盘录入学生信息按照总分排序并写入文本文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 需求：键盘录入3个学生信息(姓名,语文成绩(chineseScore),数学成绩(mathScore),英语成绩(englishScore)),按照总分从高到低存入文本文件</span><br><span class="line"> * 分析:</span><br><span class="line"> * 1: 创建一个学生类</span><br><span class="line"> * 2: 创建一个集合对象TreeSet集合</span><br><span class="line"> * 3: 键盘录入学生信息,把学生信息封装到学生对象中,然后把学生对象添加到集合中</span><br><span class="line"> * 4: 创建一个高效的字符输出流对象</span><br><span class="line"> * 5: 遍历集合,获取每一个元素,把其信息写入到文件中</span><br><span class="line"> * 6: 释放资源</span><br><span class="line"> */</span><br><span class="line">//  创建一个集合对象TreeSet集合</span><br><span class="line">TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public int compare(Student s1, Student s2) &#123;</span><br><span class="line">// 总分</span><br><span class="line">int num = s2.getTotalScore() - s1.getTotalScore() ;</span><br><span class="line">// 比较姓名</span><br><span class="line">int num2 = (num == 0) ? s2.getName().compareTo(s1.getName()) : num ;</span><br><span class="line">// 返回</span><br><span class="line">return num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;) ;</span><br><span class="line"></span><br><span class="line">// 3: 键盘录入学生信息,把学生信息封装到学生对象中,然后把学生对象添加到集合中</span><br><span class="line">for(int x = 1 ; x &lt;= 3 ; x++) &#123;</span><br><span class="line">// 创建Scanner对象</span><br><span class="line">Scanner sc = new Scanner(System.in) ;</span><br><span class="line">System.out.println(&quot;请您输入第&quot; + x + &quot;个学生的姓名&quot; );</span><br><span class="line">String sutName = sc.nextLine() ;</span><br><span class="line">System.out.println(&quot;请您输入第&quot; + x + &quot;个学生的语文成绩&quot; );</span><br><span class="line">int chineseScore = sc.nextInt() ;</span><br><span class="line">System.out.println(&quot;请您输入第&quot; + x + &quot;个学生的数学成绩&quot; );</span><br><span class="line">int mathScore = sc.nextInt() ;</span><br><span class="line">System.out.println(&quot;请您输入第&quot; + x + &quot;个学生的英语成绩&quot; );</span><br><span class="line">int englishScore = sc.nextInt() ;</span><br><span class="line"></span><br><span class="line">// 把学生的信封装到一个学生对象中</span><br><span class="line">Student s = new Student() ;</span><br><span class="line">s.setName(sutName) ;</span><br><span class="line">s.setMathScore(mathScore) ;</span><br><span class="line">s.setChineseScore(chineseScore) ;</span><br><span class="line">s.setEnglishScore(englishScore) ;</span><br><span class="line">// 把学生的信息添加到集合中</span><br><span class="line">ts.add(s) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一个高效的字符输出流对象</span><br><span class="line">BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;student.info&quot;)) ;</span><br><span class="line">bw.write(&quot;==========================================学生的信息如下====================================================&quot;) ;</span><br><span class="line">bw.newLine() ;</span><br><span class="line">bw.flush() ;</span><br><span class="line">bw.write(&quot;姓名\t\t总分\t\t数学成绩\t\t语文成绩\t\t英语成绩\t\t&quot;) ;</span><br><span class="line">bw.newLine() ;</span><br><span class="line">bw.flush() ;</span><br><span class="line">for(Student t : ts) &#123;</span><br><span class="line">bw.write(t.getName() + &quot;\t\t&quot; + t.getTotalScore() + &quot;\t\t&quot; + t.getMathScore() + &quot;\t\t&quot; + t.getChineseScore() + &quot;\t\t&quot; + t.getEnglishScore()) ;</span><br><span class="line">bw.newLine() ;</span><br><span class="line">bw.flush() ;</span><br><span class="line">&#125;</span><br><span class="line">// 释放资源</span><br><span class="line">bw.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-IO流大总结【图是摘自网络，感觉很棒】"><a href="#5-IO流大总结【图是摘自网络，感觉很棒】" class="headerlink" title="5.IO流大总结【图是摘自网络，感觉很棒】"></a>5.IO流大总结【图是摘自网络，感觉很棒】</h3><h4 id="5-1-按操作方式分类结构图"><a href="#5-1-按操作方式分类结构图" class="headerlink" title="5.1 按操作方式分类结构图"></a>5.1 按操作方式分类结构图</h4><ul><li>关于IO流总结如下图所示</li><li><img src="https://upload-images.jianshu.io/upload_images/4432347-ddbc1b96f5ccb688.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul><h4 id="5-2-按操作对象分类结构图"><a href="#5-2-按操作对象分类结构图" class="headerlink" title="5.2 按操作对象分类结构图"></a>5.2 按操作对象分类结构图</h4><ul><li>关于IO流总结如下图所示</li><li><img src="https://upload-images.jianshu.io/upload_images/4432347-1ce768b945041ce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IO流</title>
      <link href="/2019/02/19/IO%E6%B5%81/"/>
      <url>/2019/02/19/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h4 id="IO流基础知识"><a href="#IO流基础知识" class="headerlink" title="IO流基础知识"></a>IO流基础知识</h4><h3 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h3><ul><li>1.IO的概述<ul><li>1.1 IO流概述及其前奏</li></ul></li><li>2.IO流整体介绍</li><li>3.File文件类<ul><li>3.1 File类的概述和方法介绍【掌握】</li></ul></li><li>4.递归<ul><li>4.1 递归概述和注意事项</li></ul></li><li>5.IO流<ul><li>5.1 IO流概述及其分类【掌握】</li><li>5.2 输入流和输出流分类</li><li>5.3 IO流基类概述和FileOutputStream的构造方法【掌握】</li><li>5.4 FileOutputStream【掌握】</li><li>5.5 FileInputStream【掌握】</li></ul></li><li>6.IO流案例<ul><li>6.1 字节流复制文本文件【字节流一次读写一个字节复制文本文件】</li><li>6.2 字节流复制MP3【字节流一次读写一个字节复制MP3】</li><li>6.3 FileInputStream读取数据一次一个字节数组【】</li><li>6.4 FileInputStream读取数据的两种方式比较</li><li>6.5 字节流复制文本文件【字节流一次读写一个字节数组复制文本文件】</li><li>6.6 字节流复制MP3【字节流一次读写一个字节数组复制MP3】</li></ul></li><li>7.Buffer缓冲数据流<ul><li>7.1 BufferedOutputStream写出数据</li><li>7.2 BufferedInputStream读取数据</li><li>7.3 字节流四种方式复制MP3并测试效率<ul><li>基本字节流一次读写一个字节</li><li>基本字节流一次读写一个字节数组</li><li>高效字节流一次读写一个字节</li><li>高效字节流一次读写一个字节数组</li></ul></li></ul></li></ul><h3 id="1-IO的概述"><a href="#1-IO的概述" class="headerlink" title="1.IO的概述"></a>1.IO的概述</h3><ul><li>1.1 IO流概述及其前奏<ul><li>A:IO流概述<ul><li>IO流用来处理设备之间的数据传输</li><li>上传文件和下载文件</li></ul></li><li>B:IO流前奏<ul><li>讲解IO流之前为什么先讲解异常和File类呢?</li><li>因为File表示的是IO流将来要操作的文件，所以我们需要学习File类。</li><li>而常见操作文件无非就是上传文件和下载文件，在这个操作的过程中可能出现问题，</li><li>出现问题后，我们需要对对应的代码进行处理。所以我们需要学习异常。</li></ul></li></ul></li></ul><h3 id="2-IO流整体介绍"><a href="#2-IO流整体介绍" class="headerlink" title="2.IO流整体介绍"></a>2.IO流整体介绍</h3><h3 id="3-File文件类"><a href="#3-File文件类" class="headerlink" title="3.File文件类"></a>3.File文件类</h3><ul><li><strong>3.1 File类的概述和方法介绍【掌握】</strong><ul><li>A:File类的概述<ul><li>文件和目录路径名的抽象表示形式</li></ul></li><li>B:构造方法<ul><li>File(String pathname)：                 根据一个路径得到File对象</li><li>File(String parent, String child):    根据一个目录和一个子文件/目录得到File对象</li><li>File(File parent, String child):        根据一个父File对象和一个子文件/目录得到File对象</li></ul></li><li>C:创建功能<ul><li>public boolean createNewFile():        创建文件 如果存在这样的文件，就不创建了</li><li>public boolean mkdir():                 创建文件夹 如果存在这样的文件夹，就不创建了</li><li>public boolean mkdirs():                创建文件夹,如果父文件夹不存在，会帮你创建出来</li><li>注意事项：如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。</li></ul></li><li>D:删除功能<ul><li>public boolean delete():        删除文件或者文件夹</li><li>注意事项：Java中的删除不走回收站。要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹</li></ul></li><li>E:重命名功能<ul><li>public boolean renameTo(File dest):    把文件重命名为指定的文件路径</li><li>注意事项：如果路径名相同，就是改名。如果路径名不同，就是改名并剪切。</li></ul></li><li>F:判断功能<ul><li>public boolean isDirectory():        判断是否是目录</li><li>public boolean isFile():        判断是否是文件</li><li>public boolean exists():        判断是否存在</li><li>public boolean canRead():        判断是否可读</li><li>public boolean canWrite():        判断是否可写</li><li>public boolean isHidden():        判断是否隐藏</li></ul></li><li>G:获取功能<ul><li>public String getAbsolutePath()：    获取绝对路径</li><li>public String getPath():        获取相对路径</li><li>public String getName():        获取名称</li><li>public long length():            获取长度。字节数</li><li>public long lastModified():        获取最后一次的修改时间，毫秒值</li><li>public String[] list():            获取指定目录下的所有文件或者文件夹的名称数组</li><li>public File[] listFiles():        获取指定目录下的所有文件或者文件夹的File数组</li></ul></li></ul></li></ul><h3 id="4-递归"><a href="#4-递归" class="headerlink" title="4.递归"></a>4.递归</h3><ul><li><strong>4.1 递归概述和注意事项</strong><ul><li>递归概述:    方法定义中调用方法本身的现象</li><li>递归注意事项    要有出口，否则就是死递归。次数不能太多，否则就内存溢出</li><li>递归解决问题的思想及图解</li><li>案例代码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    show(5) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 递归</span><br><span class="line"> */</span><br><span class="line">public static void show(int n) &#123;</span><br><span class="line">    if(n == 0)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">    show(--n) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-IO流"><a href="#5-IO流" class="headerlink" title="5.IO流"></a>5.IO流</h3><ul><li><strong>5.1 IO流概述及其分类【掌握】</strong><ul><li>A:IO流概述<ul><li>IO流用来处理设备之间的数据传输</li><li>Java对数据的操作是通过流的方式</li><li>Java用于操作流的对象都在IO包中</li></ul></li><li>B:IO流分类<ul><li>a:按照数据流向<ul><li>输入流    读入数据</li><li>输出流    写出数据</li></ul></li><li>b:按照数据类型<ul><li>字节流</li><li>字符流</li><li>什么情况下使用哪种流呢?</li><li>如果数据所在的文件通过windows自带的记事本打开并能读懂里面的内容，就用字符流。其他用字节流。</li><li>如果你什么都不知道，就用字节流</li></ul></li><li>c:字节流和字符流<ul><li>字节流   <ul><li>字节输入流                InputStream            读</li><li>字节输出流                OutputStream         写</li></ul></li><li>字符流<ul><li>字符输入流                Reader                     读</li><li>字符输出流                Writer                      写</li></ul></li><li>上面的4个流对象都是抽象类,我们不能直接使用,我们需要使用子类</li></ul></li></ul></li></ul></li></ul><ul><li><strong>5.2 输入流和输出流分类</strong></li></ul><ul><li><strong>5.3 IO流基类概述和FileOutputStream的构造方法【掌握】</strong></li><li>IO流基类概述<ul><li>a:字节流的抽象基类：<ul><li>InputStream ，OutputStream。</li></ul></li><li>b:字符流的抽象基类：<ul><li>Reader ， Writer。</li><li>注：由这四个类派生出来的子类名称都是以其父类名作为子类名的后缀。</li><li>如：InputStream的子类FileInputStream。</li><li>如：Reader的子类FileReader。</li></ul></li></ul></li></ul><ul><li><strong>5.4 FileOutputStream【掌握】</strong></li></ul><ul><li><p>A: 构造方法</p><ul><li>FileOutputStream(File file)</li><li>FileOutputStream(String name)</li><li>注意事项：创建字节输出流对象了做了几件事情?为什么一定要close()?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;a.txt&quot;) ;</span><br><span class="line">    /**</span><br><span class="line">     * 上面的代码做了什么事情?</span><br><span class="line">     *         1: 调用系统资源,创建了一个a.txt文件</span><br><span class="line">     *         2: 创建一个fos对象</span><br><span class="line">     *         3: 把fos指向a.txt</span><br><span class="line">     */</span><br><span class="line">    String s = &quot;hello, IO , 我来了&quot; ;</span><br><span class="line">    // 把字符串转换成字节数组</span><br><span class="line">    byte[] bytes = s.getBytes() ;</span><br><span class="line">    // 调用方法写数据</span><br><span class="line">    fos.write(bytes) ;</span><br><span class="line">    /**</span><br><span class="line">     * 关闭流对象</span><br><span class="line">     * 作用: 通知系统释放关于该文件的资源</span><br><span class="line">     */</span><br><span class="line">    fos.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>B:FileOutputStream的三个write()方法</p><ul><li>public void write(int b):写一个字节</li><li>public void write(byte[] b):写一个字节数组</li><li>public void write(byte[] b,int off,int len):写一个字节数组的一部分</li><li>FileOutputStream写出数据实现换行和追加写入<ul><li>实现数据的换行</li><li>实现数据的追加写入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    // public FileOutputStream(String name,  boolean append)</span><br><span class="line">    // 表示追加写入</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;c.txt&quot; , true) ;       </span><br><span class="line">    // 写数据</span><br><span class="line">    for(int x = 0 ; x &lt; 5 ; x++) &#123;</span><br><span class="line">        byte[] bytes = (&quot;呵呵&quot; + x + &quot;\r\n&quot;).getBytes() ;</span><br><span class="line">        fos.write(bytes) ;</span><br><span class="line">    &#125;</span><br><span class="line">    // 是否资源</span><br><span class="line">    fos.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><strong>5.5 FileInputStream【掌握】</strong></li></ul><ul><li>FileInputStream读取数据一次一个字节<ul><li>int read():一次读取一个字节</li></ul></li></ul><h3 id="6-IO流案例"><a href="#6-IO流案例" class="headerlink" title="6.IO流案例"></a>6.IO流案例</h3><h4 id="6-1-字节流复制文本文件【字节流一次读写一个字节复制文本文件】"><a href="#6-1-字节流复制文本文件【字节流一次读写一个字节复制文本文件】" class="headerlink" title="6.1 字节流复制文本文件【字节流一次读写一个字节复制文本文件】"></a>6.1 字节流复制文本文件【字节流一次读写一个字节复制文本文件】</h4><ul><li>一次读取一个字节  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 复制文本文件:</span><br><span class="line">     *         读和写</span><br><span class="line">     *     分析:</span><br><span class="line">     *         1: 创建两个对象一个是字节输入流对象,一个是字节输出流对象</span><br><span class="line">     *         2: 一次读取一个字节,一次写一个字节</span><br><span class="line">     *         3: 释放资源</span><br><span class="line">     */</span><br><span class="line">    // 创建两个对象一个是字节输入流对象,一个是字节输出流对象</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;FileOutputStreamDemo.java&quot;) ;</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;copyFile.java&quot;) ;</span><br><span class="line">    // 一次读取一个字节,一次写一个字节</span><br><span class="line">    int by = 0 ;</span><br><span class="line">    while((by = fis.read()) != -1)&#123;</span><br><span class="line">        fos.write(by) ;</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放资源</span><br><span class="line">    fos.close() ;</span><br><span class="line">    fis.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-2-字节流复制MP3【字节流一次读写一个字节复制MP3】"><a href="#6-2-字节流复制MP3【字节流一次读写一个字节复制MP3】" class="headerlink" title="6.2 字节流复制MP3【字节流一次读写一个字节复制MP3】"></a>6.2 字节流复制MP3【字节流一次读写一个字节复制MP3】</h4><ul><li>一次读取一个字节  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    // 需求: 使用字节流复制mp3文件</span><br><span class="line">    // 创建字节输入流和字节输出流对象</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;C:\\a.mp3&quot;) ;</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;D:\\a.mp3&quot;) ;</span><br><span class="line">    // 复制文件</span><br><span class="line">    int by = 0 ;</span><br><span class="line">    while((by = fis.read()) != -1)&#123;</span><br><span class="line">        fos.write(by) ;</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放资源</span><br><span class="line">    fos.close() ;</span><br><span class="line">    fis.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-3-FileInputStream读取数据一次一个字节数组"><a href="#6-3-FileInputStream读取数据一次一个字节数组" class="headerlink" title="6.3 FileInputStream读取数据一次一个字节数组"></a>6.3 FileInputStream读取数据一次一个字节数组</h4><h4 id="6-4-FileInputStream读取数据的两种方式比较"><a href="#6-4-FileInputStream读取数据的两种方式比较" class="headerlink" title="6.4 FileInputStream读取数据的两种方式比较"></a>6.4 FileInputStream读取数据的两种方式比较</h4><h4 id="6-5-字节流复制文本文件【字节流一次读写一个字节数组复制文本文件】"><a href="#6-5-字节流复制文本文件【字节流一次读写一个字节数组复制文本文件】" class="headerlink" title="6.5 字节流复制文本文件【字节流一次读写一个字节数组复制文本文件】"></a>6.5 字节流复制文本文件【字节流一次读写一个字节数组复制文本文件】</h4><ul><li>字节流一次读写一个字节数组  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 需求: 使用字节流复制文本文件,采用字节输入流的第二种读取数据的方式</span><br><span class="line">     */</span><br><span class="line">    // 创建字节输入流对象和字节输出流对象</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;FileOutputStreamDemo.java&quot;) ;</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;copyFile2.java&quot;) ;</span><br><span class="line">    // 一次读取一个字节数组复制文件</span><br><span class="line">    byte[] bytes = new byte[1024] ;</span><br><span class="line">    int len = 0 ;        // 作用: 记录读取到的有效的字节个数</span><br><span class="line">    while((len = fis.read(bytes)) != -1)&#123;</span><br><span class="line">        fos.write(bytes, 0, len) ;</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放资源</span><br><span class="line">    fos.close() ;</span><br><span class="line">    fis.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-6-字节流复制MP3【字节流一次读写一个字节数组复制MP3】"><a href="#6-6-字节流复制MP3【字节流一次读写一个字节数组复制MP3】" class="headerlink" title="6.6 字节流复制MP3【字节流一次读写一个字节数组复制MP3】"></a>6.6 字节流复制MP3【字节流一次读写一个字节数组复制MP3】</h4><ul><li>一次读取一个字节数组  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 需求: 使用字节流复制mp3文件一次读取一个字节数组</span><br><span class="line">     */</span><br><span class="line">    // 创建对象</span><br><span class="line">    FileInputStream fis = new FileInputStream(&quot;C:\\a.mp3&quot;) ;</span><br><span class="line">    FileOutputStream fos = new FileOutputStream(&quot;D:\\a.mp3&quot;) ;</span><br><span class="line">    // 一次读取一个字节数组复制文件</span><br><span class="line">    byte[] bytes = new byte[1024] ;</span><br><span class="line">    int len = 0 ;</span><br><span class="line">    while((len = fis.read(bytes)) != -1)&#123;</span><br><span class="line">        fos.write(bytes, 0, len) ;</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放资源</span><br><span class="line">    fos.close() ;</span><br><span class="line">    fis.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-Buffer缓冲数据流"><a href="#7-Buffer缓冲数据流" class="headerlink" title="7.Buffer缓冲数据流"></a>7.Buffer缓冲数据流</h3><h4 id="7-1-BufferedOutputStream写出数据"><a href="#7-1-BufferedOutputStream写出数据" class="headerlink" title="7.1 BufferedOutputStream写出数据"></a>7.1 BufferedOutputStream写出数据</h4><ul><li>代码如下所示：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    /**</span><br><span class="line">     * BufferedOutputStream构造方法:</span><br><span class="line">     *         public BufferedOutputStream(OutputStream out)</span><br><span class="line">     */</span><br><span class="line">    // 创建FileOutputStream对象</span><br><span class="line">    //FileOutputStream fos = new FileOutputStream(&quot;buf.txt&quot;) ;</span><br><span class="line">    //BufferedOutputStream bof = new BufferedOutputStream(fos) ;</span><br><span class="line">    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;buf.txt&quot;)) ;</span><br><span class="line">    // 调用方法</span><br><span class="line">    bos.write(&quot;哈哈,我来了&quot;.getBytes()) ;</span><br><span class="line">    // 释放资源</span><br><span class="line">    bos.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-2-BufferedInputStream读取数据"><a href="#7-2-BufferedInputStream读取数据" class="headerlink" title="7.2 BufferedInputStream读取数据"></a>7.2 BufferedInputStream读取数据</h4><ul><li>代码如下所示：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">    /**</span><br><span class="line">     * BufferedInputStream构造方法:</span><br><span class="line">     *         public BufferedInputStream(InputStream in)</span><br><span class="line">     */</span><br><span class="line">    BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;e.txt&quot;)) ;</span><br><span class="line">    // 一次读取一个字节</span><br><span class="line">    //int by = 0 ;</span><br><span class="line">    //while((by = bis.read()) != -1)&#123;</span><br><span class="line">    //    System.out.print((char)by);</span><br><span class="line">    //&#125;</span><br><span class="line">    // 一次读取一个字节数组</span><br><span class="line">    byte[] bytes = new byte[1024] ;</span><br><span class="line">    int len = 0 ;</span><br><span class="line">    while((len = bis.read(bytes)) != -1)&#123;</span><br><span class="line">        System.out.print(new String(bytes , 0 , len));</span><br><span class="line">    &#125;</span><br><span class="line">    // 释放资源</span><br><span class="line">    bis.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-3-字节流四种方式复制MP3并测试效率"><a href="#7-3-字节流四种方式复制MP3并测试效率" class="headerlink" title="7.3 字节流四种方式复制MP3并测试效率"></a>7.3 字节流四种方式复制MP3并测试效率</h4><ul><li>基本字节流一次读写一个字节</li><li>基本字节流一次读写一个字节数组</li><li>高效字节流一次读写一个字节</li><li>高效字节流一次读写一个字节数组  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public class CopyFileDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // 获取开始时间</span><br><span class="line">        long startTime = System.currentTimeMillis() ;</span><br><span class="line">        // 复制文件</span><br><span class="line">        copyFile_4() ;</span><br><span class="line">        // 获取结束时间</span><br><span class="line">        long endTime = System.currentTimeMillis() ;</span><br><span class="line">        // 输出</span><br><span class="line">        System.out.println(&quot;复制文件使用的时间是:&quot; + (endTime - startTime) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 高效流一次读取一个字节数组赋值文件</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static void copyFile_4() throws IOException &#123;       </span><br><span class="line">        // 复制文件使用的时间是:50毫秒</span><br><span class="line">        // 创建高效流对象</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;C:\\a.avi&quot;)) ;</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\a.avi&quot;)) ;</span><br><span class="line">        // 一次读取一个字节数组</span><br><span class="line">        byte[] bytes = new byte[1024] ;</span><br><span class="line">        int len = 0 ;</span><br><span class="line">        while((len = bis.read(bytes)) != -1)&#123;</span><br><span class="line">            bos.write(bytes, 0, len) ;</span><br><span class="line">        &#125;</span><br><span class="line">        // 释放资源</span><br><span class="line">        bos.close() ;</span><br><span class="line">        bis.close() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 高效流一次读取一个字节复制文件</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static void copyFile_3() throws IOException &#123;       </span><br><span class="line">        // 复制文件使用的时间是:990毫秒</span><br><span class="line">        // 创建高效流对象</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;C:\\a.avi&quot;)) ;</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\a.avi&quot;)) ;</span><br><span class="line">        // 一次读取一个字节</span><br><span class="line">        int by = 0 ;</span><br><span class="line">        while((by = bis.read()) != -1)&#123;</span><br><span class="line">            bos.write(by) ;</span><br><span class="line">        &#125;</span><br><span class="line">        // 释放资源</span><br><span class="line">        bos.close() ;</span><br><span class="line">        bis.close() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 基本流一次读取一个字节数组复制文件</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    private static void copyFile_2() throws IOException &#123;       </span><br><span class="line">        // 复制文件使用的时间是:130毫秒</span><br><span class="line">        // 创建对象</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;C:\\a.avi&quot;) ;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\a.avi&quot;) ;</span><br><span class="line"></span><br><span class="line">        // 一次读取一个字节数组</span><br><span class="line">        byte[] bytes = new byte[1024] ;</span><br><span class="line">        int len = 0 ;</span><br><span class="line">        while((len = fis.read(bytes)) != -1)&#123;</span><br><span class="line">            fos.write(bytes, 0, len) ;</span><br><span class="line">        &#125;</span><br><span class="line">        // 释放资源</span><br><span class="line">        fos.close() ;</span><br><span class="line">        fis.close() ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 基本流一次读取一个字节复制文件</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    private static void copyFile_1() throws IOException &#123;   </span><br><span class="line">        // 复制文件使用的时间是:88670毫秒</span><br><span class="line">        // 创建对象</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;C:\\a.avi&quot;) ;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\a.avi&quot;) ;</span><br><span class="line">        // 一次读取一个字节</span><br><span class="line">        int by = 0 ;</span><br><span class="line">        while((by = fis.read()) != -1)&#123;</span><br><span class="line">            fos.write(by) ;</span><br><span class="line">        &#125;</span><br><span class="line">        // 释放资源</span><br><span class="line">        fos.close() ;</span><br><span class="line">        fis.close() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title> 运算符and语句</title>
      <link href="/2019/01/17/%E8%BF%90%E7%AE%97%E7%AC%A6and%E8%AF%AD%E5%8F%A5/"/>
      <url>/2019/01/17/%E8%BF%90%E7%AE%97%E7%AC%A6and%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><ul><li>算术运算符包括：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - * / % ++  --</span><br></pre></td></tr></table></figure></li></ul><h3 id="“-”号的几种作用："><a href="#“-”号的几种作用：" class="headerlink" title="“+”号的几种作用："></a>“+”号的几种作用：</h3><ol><li>加法</li><li>正数</li><li>字符串连接符</li></ol><h3 id="“-“使用的时候要注意"><a href="#“-“使用的时候要注意" class="headerlink" title="“-“使用的时候要注意:"></a>“-“使用的时候要注意:</h3><ul><li>整数相除，只能得到整数</li><li>要想要得到小数，可以*1.0</li></ul><h3 id="和–的应用"><a href="#和–的应用" class="headerlink" title="++和–的应用"></a>++和–的应用</h3><ul><li>单独使用效果相同</li><li>参与运算使用，在操作数的前后效果不同</li></ul><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><ul><li><p>关系运算符包括:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br></pre></td></tr></table></figure></li><li><p>注意：<br>关系运算符的结果都是boolean型的，也就是不是true,就是false<br>关系运算符的“==”是代表等于号</p></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul><li>“=”<br>int a=1;<br>int b=2;  </li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li><p>逻辑运算符包括:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;  |  ^    !  &amp;&amp;    ||</span><br><span class="line">与 或 异或  非 and or</span><br></pre></td></tr></table></figure></li><li><p>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;6，应该写成x&gt;3 &amp; x&lt;6 。</p></li><li>“&amp;”和“&amp;&amp;”的区别：</li></ul><ol><li>单&amp;时，左边无论真假，右边都进行运算；</li><li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li></ol><ul><li>“|”和“||”的区别同理，双或时，左边为真，右边不参与运算。</li><li>异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。</li></ul><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">左移：&lt;&lt;</span><br><span class="line">右移：&gt;&gt;</span><br><span class="line">无符号右移: &gt;&gt;&gt;</span><br><span class="line">与运算: &amp;</span><br><span class="line">或运算: |</span><br><span class="line">异或运算： ^</span><br><span class="line">反码: ~</span><br></pre></td></tr></table></figure><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ul><li>(关系表达式)?表达式1：表达式2；</li><li>如果条件为true，运算后的结果是表达式1；</li><li>如果条件为false，运算后的结果是表达式2；</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取两个数中大数。</span><br><span class="line">int x=3,y=4,z;</span><br><span class="line">z = (x&gt;y)?x:y;//z变量存储的就是两个数的大数。</span><br></pre></td></tr></table></figure><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>从上到下执行</p><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><ul><li>分支结构 </li></ul><ol><li>if</li><li>switch</li></ol><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><h3 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h3><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><h4 id="return"><a href="#return" class="headerlink" title="return"></a>return</h4>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>java基础知识</title>
      <link href="/2018/12/24/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2018/12/24/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><ol><li>计算机<br>电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成  </li><li>计算机硬件<br>计算机通常由CPU、主板、内存、电源、主机箱、硬盘、显卡、键盘、鼠标，显示器等多个部件组成。  </li><li>计算机软件<br>使用计算机过程中必不可少的东西，计算机按照事先预定好的顺序完成特定的功能，按照其功能可以分为系统软件和应用软件。  </li></ol><ul><li>应用软件  <blockquote><p>我们平常使用的电脑软件就是应用软件，例如QQ，eclipse等  </p></blockquote></li><li>系统软件  <blockquote><p>Windows,Linux,Unix,Mac,Anadroid,iOS</p></blockquote></li></ul><h2 id="软件开发"><a href="#软件开发" class="headerlink" title="软件开发"></a>软件开发</h2><ul><li>软件<br>按照特定顺序组织的计算机数据和指令的集合  </li><li>软件开发<br>借助开发工具与计算机语言制作软件的过程  </li></ul><h2 id="计算机语言"><a href="#计算机语言" class="headerlink" title="计算机语言"></a>计算机语言</h2><p>人与计算机之间进行交流沟通的一种特殊的语言，方便人与计算机之间的交流  </p><ul><li>常用的计算机语言  <blockquote><p>java<br>python<br>c<br>c++<br>c#</p></blockquote></li></ul><h2 id="常用的快捷键"><a href="#常用的快捷键" class="headerlink" title="常用的快捷键"></a>常用的快捷键</h2><pre><code>Ctrl+A:全选    Ctrl+C:复制Ctrl+V:粘贴    Ctrl+S:剪切Ctrl+Z:撤销    Ctrl+S:保存</code></pre><h2 id="DOS命令"><a href="#DOS命令" class="headerlink" title="DOS命令"></a>DOS命令</h2><pre><code>(1)切换盘符(掌握)    d: 回车(2)显示某目录下的所有文件或者文件夹(掌握)    dir 回车(3)创建文件夹    md 文件夹名称 回车(4)删除文件夹    rd 文件夹名称 回车(5)进入目录(掌握)    单级进入 cd 目录名称     多级进入 cd 目录名称1\目录名称2\...(6)回退目录(掌握)    单级回退 cd..    回退根目录 cd\(7)删除文件    del 文件名称    *.txt 可以表示多个文件名称(8)清屏(掌握)    cls(9)退出    exit(10)扩展DOS命令    删除带内容的文件夹    rd /s 文件夹名称 会提示是否删除    rd /q /s 文件夹名称 直接删除</code></pre><h1 id="Java发展历史"><a href="#Java发展历史" class="headerlink" title="Java发展历史"></a>Java发展历史</h1><p>略</p><ul><li>java语言版本  </li></ul><ol><li>javaSE   </li><li>javaME  </li><li>javaEE  </li></ol><h2 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h2><blockquote><p>简单性<br>面向对象<br>健壮性<br>结构中立<br>高性能<br>多线程<br>动态<br>安全性<br>跨平台  </p></blockquote><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>因为有了JVM，所以同一个Java程序在三个不同的操作系统中都可以执行。这样就实现了Java程序的跨平台性。也称为Java具有良好的可移植性。  </p><h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>(Java Runtime Environment)Java运行环境  </p><blockquote><p>包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p></blockquote><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>(Java Development Kit    Java开发工具包)  </p><blockquote><p>JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。<br>其中的开发工具：编译工具(javac.exe)  打包工具(jar.exe)等  </p></blockquote><h3 id="JDK、JRE、JVM三者关系"><a href="#JDK、JRE、JVM三者关系" class="headerlink" title="JDK、JRE、JVM三者关系"></a>JDK、JRE、JVM三者关系</h3><ul><li>Jdk&gt;jre&gt;jvm  </li></ul><h2 id="环境变量的配置"><a href="#环境变量的配置" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h2><ol><li>系统环境变量<ol><li>JAVA_HOME:&gt;&gt;&gt; D:\jdk1.8(JDK的安装路径)  </li><li>Classpath:&gt;&gt;&gt; .;(基本不用安装)  </li><li>Path :&gt;&gt;&gt; %JAVA_HOME%\bin</li></ol></li><li>path和classpath的区别:<ol><li>path环境变量里面记录的是可执行性文件，如.exe文件，对可执行文件先在当前路径去找，如果没找到就去path环境变量中配置的路径去找  </li><li>classpath环境变量里记录的是java类的运行文件所在的目录  </li></ol></li></ol><blockquote><p>Path环境变量配错的话就会报这个错误：Java.dll 文件找不到<br>验证安装JDK是否成功：进入doc–&gt;cmd–&gt;java   </p></blockquote><h2 id="编辑java程序："><a href="#编辑java程序：" class="headerlink" title="编辑java程序："></a>编辑java程序：</h2><h3 id="记事本"><a href="#记事本" class="headerlink" title="记事本"></a>记事本</h3><p>使用记事本编辑java程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class test&#123;</span><br><span class="line">    //程序的入口</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">    System.out.println(&quot;java hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="程序的执行流程"><a href="#程序的执行流程" class="headerlink" title="程序的执行流程"></a>程序的执行流程</h4><p>将我们的java成程序放到JVM中，把java程序进行编译成java.class文件（字节码文件，二进制文件。还要经过类加载器将java.class文件加载到jvm中）。  </p><ul><li>Javac:将java文件编程字节码文件。（java.class文件)  </li><li>Java:运行java字节码文件，执行程序。  <blockquote><p>以后开发Java程序基本都会用开发工具来进行开发，好处：不用我们自己手动编译，开发工具会帮我们自动的编译java文件并且校验java程序。 </p></blockquote></li></ul><h3 id="开发工具的使用"><a href="#开发工具的使用" class="headerlink" title="开发工具的使用"></a>开发工具的使用</h3><h4 id="工程创建"><a href="#工程创建" class="headerlink" title="工程创建"></a>工程创建</h4><ul><li>用java se 视图创建java工程。<br>  File–&gt;new—&gt;javaprojiect.</li><li>eclipse中经常用到的快捷键  <blockquote><p>语句的补全：alt+/<br>删除整行：ctrl+D<br>恢复上一步：ctrl+z<br>进入下一步：ctrl+y<br>代码行的移动：alt+上/下键<br>代码的格式化之一：alt+shift+f<br>代码的格式化之二：alt+shift+s<br>单行注释：ctrl+/<br>解除注释 ：ctrl+/<br>多行注释：ctrl+shift+/<br>解除注释 ：ctrl+shift+\</p></blockquote></li></ul><h4 id="Java程序的创建"><a href="#Java程序的创建" class="headerlink" title="Java程序的创建"></a>Java程序的创建</h4><p>工程名–&gt;包–&gt;类</p><pre><code>- 注释：1. 单行注释:  //2. 多行注释：/***/3. 文档注释: /** **/</code></pre><h1 id="java基础知识"><a href="#java基础知识" class="headerlink" title="java基础知识"></a>java基础知识</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><ol><li>概述<br>被Java语言赋予特定含义的单词  </li><li>特点<br>组成关键字的字母全部小写  </li><li>举例  </li></ol><ul><li>用于定义数据类型的关键字  <blockquote><p>long  float double char boolean int short byte interface class void</p></blockquote></li><li>用于定于数据类型值的关键字<blockquote><p>true false null</p></blockquote></li><li>用于定于流程控制的关键字  <blockquote><p>if else switch case  default while do for break continue return </p></blockquote></li><li>用于定于访问修饰符的关键字<blockquote><p>public protected private  </p></blockquote></li><li>用于定于类，函数，变量修饰符的关键字<blockquote><p>abstract final static synchronized   </p></blockquote></li><li>用于定于类与类之间关系的关键字<blockquote><p>extends implements</p></blockquote></li><li>用于定于建立实例及引用实例，判断实例的关键字<blockquote><p>new  this super instanceof </p></blockquote></li><li>用于异常处理的关键字  <blockquote><p>try catch finally throw throws  </p></blockquote></li><li>用于包的关键字  <blockquote><p>import package  </p></blockquote></li><li>其他修饰符关键字<blockquote><p>native strictfp transient volatile assert</p></blockquote></li></ul><p>关键字其实就是英语单词，但是这个英语单词代表特殊含义。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ol><li>概述:<br>给类,接口,方法,变量等起名字时使用的字符序列  </li><li><p>规则:</p><blockquote><p>英文大小写字母<br>数字字符<br>$和—_</p></blockquote></li><li><p>注意事项:</p><blockquote><p>不能以数字开头<br>不能是java中的关键字<br>区分大小写</p></blockquote></li><li><p>常见命名方式：</p><pre><code>A:包 其实就是文件夹,用于解决相同类名问题    全部小写    单级：com    多级：cn.itcastB:类或者接口    一个单词：首字母大写        Student,Person,Teacher    多个单词：每个单词的首字母大写        HelloWorld,MyName,NameDemoC:方法或者变量    一个单词：全部小写        name,age,show()    多个单词：从第二个单词开始，每个单词首字母大写        myName,showAllStudentNames()D:常量    一个单词：全部大写        AGE    多个单词：每个单词都大写，用_连接        STUDENT_MAX_AGE</code></pre></li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote><p>Int byte short long boolean char float double </p></blockquote><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">占用存储空间</th><th style="text-align:center">表示范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1字节</td><td style="text-align:center">-127~127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2字节</td><td style="text-align:center">-2^15~2^15+1</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2个字节</td><td style="text-align:center">0~2^15-1</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">四个字节</td><td style="text-align:center">-2^31~2^31+1</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">八个字节</td><td style="text-align:center">-2^63~2^63+1</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4个字节</td><td style="text-align:center">-2^31~2^31+1</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">八个字节</td><td style="text-align:center">-2^63~2^63+1</td></tr></tbody></table><h4 id="数据的转换"><a href="#数据的转换" class="headerlink" title="数据的转换"></a>数据的转换</h4><ul><li><p>强制转换：<br>  大–&gt;小  </p></li><li><p>自动转换：<br>小–&gt;大</p></li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><blockquote><p>String 数组 类 接口</p></blockquote><ul><li>特点:<br>都可以创建对象（基本） </li><li>基本用法  </li></ul><ol><li>充当变量；<br> 变量的定义：<br> （相对）局部变量： <pre><code>方法中的变量、异常中的变量、内部类中的变量。生命周期：例如方法中：随着方法的创建而创建，随着方法的销毁而销毁。</code></pre> （相对）全局变量：<pre><code>类中的变量。修饰符：public private proteced (default)格式：修饰符+数据类型+变量名;   定义：private int num;</code></pre></li><li>方法参数;</li><li>返回值；<br>标识符<br>例如：类名、方法名、接口名、变量名等等；<br>规范：TestDemo（类） setName(驼峰结构) namePassword(驼峰结构/全部小写)</li></ol><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>在计算机内，有符号数有3种表示法：原码、反码和补码。所有数据的运算都是采用补码进行的。  </p><blockquote><p>GBK、UTF-8、ISO-8859-1、Unicode 、URLUnicode 、ASSCII </p></blockquote><ul><li>ASSCII:<br>字符跟数字的关系。一个</li><li>GBK：<br>2个</li><li>UTF-8：<br>英文2个、中文3个。</li></ul><ol><li><p>原码<br>就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。  </p></li><li><p>反码<br>正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。  </p></li><li><p>补码<br>正数的补码与其原码相同；负数的补码是在其反码的末位加1</p></li></ol><ul><li>正负数编码</li></ul><ol><li><p>负数:</p><blockquote><p>原码  反码  补码–&gt;  原码—按位取反–&gt;反码— +1 –&gt;补码<br> 负数取值：例如-3   1000 0011（原码）–&gt; 0111 1100（反码）–&gt;0111 1101(补码)<br> 取值：看原码，转换：看补码。<br> 数值：符号位也是数值位。</p></blockquote></li><li><p>正数：<br>原码  反码  补码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Markdown学习</title>
      <link href="/2018/12/22/Markdown%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/12/22/Markdown%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。  </p><h1 id="一-设置标题"><a href="#一-设置标题" class="headerlink" title="一 设置标题"></a>一 设置标题</h1><h2 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h2><p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># h1标题</span><br><span class="line">## h2标题</span><br><span class="line">### h3标题</span><br><span class="line">#### h4标题</span><br><span class="line">##### h5标题</span><br><span class="line">###### h6标题</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><h1 id="h1标题"><a href="#h1标题" class="headerlink" title="h1标题"></a>h1标题</h1><h2 id="h2标题"><a href="#h2标题" class="headerlink" title="h2标题"></a>h2标题</h2><h3 id="h3标题"><a href="#h3标题" class="headerlink" title="h3标题"></a>h3标题</h3><h4 id="h4标题"><a href="#h4标题" class="headerlink" title="h4标题"></a>h4标题</h4><h5 id="h5标题"><a href="#h5标题" class="headerlink" title="h5标题"></a>h5标题</h5><h6 id="h6标题"><a href="#h6标题" class="headerlink" title="h6标题"></a>h6标题</h6><h2 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h2><ul><li><p>示例  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 第一种</span><br><span class="line">h1标题</span><br><span class="line">===</span><br><span class="line">第二种  </span><br><span class="line">h2标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li><li><p>效果: </p></li></ul><h1 id="h1标题-1"><a href="#h1标题-1" class="headerlink" title="h1标题"></a>h1标题</h1><h2 id="h2标题-1"><a href="#h2标题-1" class="headerlink" title="h2标题"></a>h2标题</h2><p>-</p><h1 id="二-字体"><a href="#二-字体" class="headerlink" title="二 字体"></a>二 字体</h1><ul><li>加粗<br>要加粗的文字左右分别用两个*号包起来  </li></ul><ul><li>斜体<br>-要倾斜的文字左右分别用一个*号包起来  </li></ul><ul><li>斜体加粗<br>要倾斜和加粗的文字左右分别用三个*号包起来</li><li>删除线<br>要加删除线的文字左右分别用两个~~号包起来  </li></ul><ul><li><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure></li><li><p>显示效果:  </p><p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字</em></strong><br><del>这是加删除线的文字</del>  </p></li></ul><h1 id="三-自然段换行"><a href="#三-自然段换行" class="headerlink" title="三 自然段换行"></a>三 自然段换行</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><ul><li>在一段话结束的位置加上<strong>两个空格</strong> </li><li>aaa  bbb  ccc   </li></ul><ul><li>aaa  </li><li>bbb  </li><li>ccc </li></ul><h1 id="四-引用"><a href="#四-引用" class="headerlink" title="四 引用"></a>四 引用</h1><p>在引用的文字前面加上”&gt;”,</p><ul><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello world </span><br><span class="line">&gt;hello world最外层引用</span><br><span class="line">&gt;&gt;Loong中间层的引用</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;dragon 这里是最里面的引用</span><br></pre></td></tr></table></figure></li><li><p>效果如下<br>hello world </p><blockquote><p>hello world最外层引用</p><blockquote><p>Loong中间层的引用</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>dragon 这里是最里面的引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></li></ul><h1 id="五-增加分割线"><a href="#五-增加分割线" class="headerlink" title="五 增加分割线"></a>五 增加分割线</h1><p>增加分割线有二种写法，-和*都可以</p><ul><li><p>示例  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---  </span><br><span class="line">***</span><br></pre></td></tr></table></figure></li><li><p>显示结果  </p></li></ul><hr><hr><p>可以看到他们显示的效果是一样的</p><h1 id="六-列表表示方法"><a href="#六-列表表示方法" class="headerlink" title="六 列表表示方法"></a>六 列表表示方法</h1><h2 id="（1）有序列表"><a href="#（1）有序列表" class="headerlink" title="（1）有序列表"></a>（1）有序列表</h2><p>使用数字表示有序列表，和平常我们使用的是一样的<br>数字加点表示</p><ul><li>示例  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 一</span><br><span class="line">2. 二</span><br><span class="line">3. 三</span><br></pre></td></tr></table></figure></li></ul><ul><li>数字表示有序列表  </li></ul><ol><li>一</li><li>二</li><li>三</li></ol><p><strong>这里踩的坑</strong><br>这里的1.和后面的内容要有一个空格</p><h2 id="（2）无序列表"><a href="#（2）无序列表" class="headerlink" title="（2）无序列表"></a>（2）无序列表</h2><p>无序列表和有序列表差不多，只是无序列表使用的是数学符号替代  </p><ul><li>可以用三种符号表示</li></ul><blockquote><p>列表符号：-<br>列表符号：+<br>列表符号：*    </p></blockquote><ul><li>示例   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 一级列表</span><br><span class="line">- 一级列表</span><br><span class="line">  - 二级列表</span><br><span class="line">  - 二级列表</span><br><span class="line">+ 一级列表</span><br><span class="line">  + 二级列表</span><br><span class="line">    + 三级列表</span><br><span class="line">    + 三级列表</span><br><span class="line">  * 二级列表</span><br><span class="line">    * 三级列表</span><br><span class="line">    * 三级列表</span><br><span class="line">    * 三级列表</span><br></pre></td></tr></table></figure></li></ul><p><strong>显示的效果如下:</strong>  </p><ul><li>一级列表</li><li>一级列表<ul><li>二级列表</li><li>二级列表</li></ul></li></ul><ul><li>一级列表<ul><li>二级列表<ul><li>三级列表</li><li>三级列表</li></ul></li></ul><ul><li>二级列表<ul><li>三级列表</li><li>三级列表</li><li>三级列表</li></ul></li></ul></li></ul><p>我们可以看到三种符号显示的效果都是一样的  </p><h1 id="七-超链接"><a href="#七-超链接" class="headerlink" title="七 超链接"></a>七 超链接</h1><ul><li><p>示例  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](https://www.baidu.com)</span><br></pre></td></tr></table></figure></li><li><p>显示结果<br><a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a></p></li><li><p>表示方法:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[超链接名字](超链接的地址URL &quot;超链接的title\&quot;)</span><br></pre></td></tr></table></figure></li><li><p>示例:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[博客](https://dlblog.xyz &quot;Loong个人博客&quot;)</span><br></pre></td></tr></table></figure></li><li><p>显示效果:<br><a href="https://dlblog.xyz" title="Loong个人博客" target="_blank" rel="noopener">我的博客</a> </p></li></ul><p><strong>这里踩的坑</strong><br>你所引用的链接的地址要写全，eg:前面一定要记得加上https://</p><h1 id="八-代码高亮显示"><a href="#八-代码高亮显示" class="headerlink" title="八 代码高亮显示"></a>八 代码高亮显示</h1><h2 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h2><p>单行代码:代码之间分别用反引号包括起来表示</p><ul><li>样式:  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`printf(&quot;i love Loong!!!&quot;)`</span><br></pre></td></tr></table></figure></li></ul><ul><li>例子:<br><code>printf(&quot;i love Loong!!!&quot;)</code>   </li></ul><h2 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h2><p>使用三个反单引号 ` 或者是三个波浪线 ~ ,其中反单引号使用的更多<br>注意: 上下的三个反引号单独占一行表示  </p><ul><li>1.三个反单引号 ` 表示<br>效果如下:<pre><code>int add(int a,int b){  int c=a+b;  return c;}</code></pre></li><li>2.使用波浪线 ~表示<br>效果如下:  <pre><code>void print(){     printf(&quot;我的网址是:dlblog.xyz&quot;);}</code></pre></li><li><p>这里踩的坑<br>三个符号后面记得加上两个空格，代表结束，否者会出现引用的错乱</p><h1 id="九-显示图片"><a href="#九-显示图片" class="headerlink" title="九 显示图片"></a>九 显示图片</h1></li><li><p>样式语法  </p><pre><code>![ 图片alt ](  图片地址 &apos;&apos;图片title&apos;&apos;)  </code></pre><p>图片alt就是显示在图片下面的文字，相当于对图片内容的解释。<br>图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加  </p></li><li>示例     <pre><code>![Loong](https://dlblog.xyz/uploads/head.jpg &quot;图片title&quot;)</code></pre></li><li>效果如下<br><img src="https://dlblog.xyz/uploads/head.jpg" alt="Loong" title="这里是图片title"></li></ul><h1 id="十-表格"><a href="#十-表格" class="headerlink" title="十 表格"></a>十 表格</h1><ul><li>语法<pre><code>| 表头 | 表头 | 表头 ||:----|:----:|----:|| TD1 | TD2 | TD3 || TD4 | TD5 | TD6 |</code></pre>第二行表示的是:分割表头和内容。<br>其实只要有一个 - 就可以，这样表示只是为了对其更加好看<br>文字默认居左<br>在两边加”:”表示居中 eg:   :----:<br>在右边加”:”表示居右 eg:   ----:</li><li>示例<pre><code>| 居左 | 居中 | 居右 ||:---|:----:|----:|| TD1 | TD2 | TD3 || TD4 | TD5 | TD6 |</code></pre></li><li>显示如下:   </li></ul><table><thead><tr><th style="text-align:left">居左</th><th style="text-align:center">居中</th><th style="text-align:right">居右</th></tr></thead><tbody><tr><td style="text-align:left">TD1</td><td style="text-align:center">TD2</td><td style="text-align:right">TD3</td></tr><tr><td style="text-align:left">TD4</td><td style="text-align:center">TD5</td><td style="text-align:right">TD6</td></tr></tbody></table><ul><li>这里踩的坑<br>所有的|不要忘记了，还有就是注意空格，都要靠左写，这个代码的规范很重要哟</li></ul><h1 id="十一-其他"><a href="#十一-其他" class="headerlink" title="十一 其他"></a>十一 其他</h1><ul><li>特殊字符处理<br>Markdown中用反斜杠+要插入的字符来表示语法中用到的特殊字符，在Markdown中需要处理的特殊的符号主要有如下几种:<br>\  反斜杠<br>`  反引号<br>*  星号<br>_  底线<br>{} 花括号<br>[] 中括号<br>() 小括号<br>#  井号<br>+  加号<br>-  减号<br>.  英文句号<br>等。。。<br>所以，我们需要输入这些字符的时候，我们需要输入 \加上特殊字符，eg: \-表示： - </li><li>注意：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。</li><li>这个尤其要注意，真的要多注意，真的多注意，重要的事情说三遍</li></ul><h1 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h1><p>Markdown是一门比html更简单的标记语言，其主要用于日常写作。最终通过相应的编辑器或者脚本转换成html用于页面渲染。为了以后能够继续将自己学到的东西写在自己的博客上，所以今天学了下Markdown，感觉这个软件是真的好用，第一次用Markdown编辑博客的内容，不求最好，只求更好。继续加油！！！其中有什么好的建议的话，欢迎来指正哦！！！<br>最后，这个文章不知道改了多少次，自己真的是很粗心，以后多注意了，我要睡觉了（哭笑）2018/12/23/00：56 早安</p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>tensorflow</title>
      <link href="/2018/12/21/tensorflow-1/"/>
      <url>/2018/12/21/tensorflow-1/</url>
      
        <content type="html"><![CDATA[<h1 id="一-忽略CPU警告"><a href="#一-忽略CPU警告" class="headerlink" title="一 忽略CPU警告"></a>一 忽略CPU警告</h1><p>import os<br>os.environ[‘TF_CPP_MIN_LOG_LEVEL’]=’2’  </p><h1 id="二-运行TensorFlow"><a href="#二-运行TensorFlow" class="headerlink" title="二 运行TensorFlow"></a>二 运行TensorFlow</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf   </span><br><span class="line">hello = tf.constant(&apos;Hello, TensorFlow!&apos;)  </span><br><span class="line">sess = tf.Session()  </span><br><span class="line">print(sess.run(hello))  </span><br><span class="line">print(&quot;hello world!!&quot;)  </span><br><span class="line">注意：  </span><br><span class="line">global_variables_initializer()替换</span><br></pre></td></tr></table></figure><h1 id="三-spyder-kreas检测是不是可以使用"><a href="#三-spyder-kreas检测是不是可以使用" class="headerlink" title="三 spyder kreas检测是不是可以使用"></a>三 spyder kreas检测是不是可以使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import tensorflow as tf  </span><br><span class="line">import numpy as np  </span><br><span class="line"></span><br><span class="line">#import keras    装完keras后，去掉#尝试运行，用于检验安装  </span><br><span class="line"></span><br><span class="line">x=tf.placeholder(&quot;float&quot;)  </span><br><span class="line">y=tf.placeholder(&quot;float&quot;)  </span><br><span class="line">w=tf.Variable([1.0,2.0],name=&apos;w&apos;)  </span><br><span class="line">y_pred=tf.multiply(x,w[0])+w[1]  </span><br><span class="line">error=tf.square(y-y_pred)  </span><br><span class="line"> </span><br><span class="line">train_op=tf.train.GradientDescentOptimizer(0.02).minimize(error)  </span><br><span class="line">model=tf.initialize_all_variables()  </span><br><span class="line"> </span><br><span class="line">with tf.Session() as session:  </span><br><span class="line">    session.run(model)  </span><br><span class="line">    for i in range(1000):  </span><br><span class="line">        x_value=np.random.rand()  </span><br><span class="line">        y_value=x_value*2+6  </span><br><span class="line">        session.run([train_op],feed_dict=&#123;x:x_value,y:y_value&#125;)  </span><br><span class="line">    </span><br><span class="line">    w_value=session.run(w)# get w</span><br><span class="line">    print (&quot;ax+b,a=%.3f,b=%.3f&quot;%(w_value[0],w_value[1]))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> tensorflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
